"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WinConditionOn = exports.WinConditionSimple = exports.WIN_QUALIFIER = void 0;
const BaseForLines_1 = require("./BaseForLines");
var WIN_QUALIFIER;
(function (WIN_QUALIFIER) {
    WIN_QUALIFIER["NO"] = "NO";
    WIN_QUALIFIER["ALL"] = "ALL";
    WIN_QUALIFIER["ANY"] = "ANY";
    WIN_QUALIFIER["SOME"] = "SOME";
})(WIN_QUALIFIER = exports.WIN_QUALIFIER || (exports.WIN_QUALIFIER = {}));
class WinConditionSimple extends BaseForLines_1.BaseForLines {
    constructor(source, qualifierEnum, tile) {
        super(source);
        this.qualifier = qualifierEnum;
        this.tile = tile;
        if (!tile) {
            throw new Error('BUG: Could not find win condition tile');
        }
    }
    cellsThatMatchTile(cells, tile) {
        return [...cells].filter((cell) => tile.matchesCell(cell));
    }
    isSatisfied(cells) {
        const ret = this._isSatisfied(cells);
        if (ret) {
            if (process.env.NODE_ENV === 'development') {
                this.__incrementCoverage();
            }
        }
        return ret;
    }
    a11yGetTiles() {
        return [this.tile];
    }
    _isSatisfied(cells) {
        const tileCells = this.cellsThatMatchTile(cells, this.tile);
        switch (this.qualifier) {
            case WIN_QUALIFIER.NO:
                return tileCells.length === 0;
            case WIN_QUALIFIER.ANY:
            case WIN_QUALIFIER.SOME:
                return tileCells.length > 0;
            // case WIN_QUALIFIER.ALL:
            //     return ![...cells].filter(cell => !this.matchesTile(cell, this._tile))[0]
            default:
                throw new Error(`BUG: Invalid qualifier: "${this.qualifier}"`);
        }
    }
}
exports.WinConditionSimple = WinConditionSimple;
class WinConditionOn extends WinConditionSimple {
    constructor(source, qualifierEnum, tile, onTile) {
        super(source, qualifierEnum, tile);
        this.onTile = onTile;
    }
    a11yGetTiles() {
        return [this.tile, this.onTile];
    }
    _isSatisfied(cells) {
        // ALL Target ON CleanDishes
        const tileCells = this.cellsThatMatchTile(cells, this.tile);
        const onTileCells = this.cellsThatMatchTile(tileCells, this.onTile);
        switch (this.qualifier) {
            case WIN_QUALIFIER.NO:
                return onTileCells.length === 0;
            case WIN_QUALIFIER.ANY:
            case WIN_QUALIFIER.SOME:
                return onTileCells.length > 0;
            case WIN_QUALIFIER.ALL:
                return onTileCells.length === tileCells.length;
            default:
                throw new Error(`BUG: Invalid qualifier: "${this.qualifier}"`);
        }
    }
}
exports.WinConditionOn = WinConditionOn;
//# sourceMappingURL=winCondition.js.map