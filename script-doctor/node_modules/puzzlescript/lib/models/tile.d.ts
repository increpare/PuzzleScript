import { Cell } from '../engine';
import { Cellish, Optional, RULE_DIRECTION } from '../util';
import { BaseForLines, IGameCode } from './BaseForLines';
import { CollisionLayer } from './collisionLayer';
import { IColor } from './colors';
import { IGameNode } from './game';
import { SimpleTileWithModifier } from './rule';
export interface IGameTile extends IGameNode {
    subscribeToCellChanges(t: SimpleTileWithModifier): void;
    hasNegationTileWithModifier(): boolean;
    addCells(sprite: GameSprite, cells: Cell[], wantsToMove: Optional<RULE_DIRECTION>): void;
    updateCells(sprite: GameSprite, cells: Cell[], wantsToMove: RULE_DIRECTION): void;
    removeCells(sprite: GameSprite, cells: Cell[]): void;
    _getDescendantTiles(): IGameTile[];
    getSprites(): GameSprite[];
    hasSingleCollisionLayer(): boolean;
    setCollisionLayer(collisionLayer: CollisionLayer): void;
    getCollisionLayer(): CollisionLayer;
    matchesCell(cell: Cell): boolean;
    isOr(): boolean;
    getCellsThatMatch<T extends Cellish>(cells?: Iterable<T>): Set<T>;
    getSpritesThatMatch(cell: Cellish): Set<GameSprite>;
    getName(): string;
    equals(t: IGameTile): boolean;
    hasCell(cell: Cell): boolean;
}
export declare abstract class GameSprite extends BaseForLines implements IGameTile {
    allSpritesBitSetIndex: number;
    readonly _optionalLegendChar: Optional<string>;
    private readonly name;
    private collisionLayer;
    private readonly trickleCells;
    private readonly trickleTiles;
    private readonly trickleTilesWithModifier;
    private bitSet;
    constructor(source: IGameCode, name: string, optionalLegendChar: Optional<string>);
    isOr(): boolean;
    equals(t: IGameTile): boolean;
    abstract hasPixels(): boolean;
    abstract getPixels(spriteHeight: number, spriteWidth: number): IColor[][];
    abstract isTransparent(): boolean;
    abstract hasAlpha(): boolean;
    getName(): string;
    isBackground(): boolean;
    _getDescendantTiles(): IGameTile[];
    getSprites(): this[];
    hasCollisionLayer(): boolean;
    hasSingleCollisionLayer(): boolean;
    setCollisionLayer(collisionLayer: CollisionLayer): void;
    setCollisionLayerAndIndex(collisionLayer: CollisionLayer, bitSetIndex: number): void;
    getCollisionLayer(): CollisionLayer;
    clearCaches(): void;
    hasCell(cell: Cell): boolean;
    matchesCell(cell: Cellish): boolean;
    getSpritesThatMatch(cell: Cellish): Set<GameSprite>;
    subscribeToCellChanges(t: SimpleTileWithModifier): void;
    subscribeToCellChangesTile(tile: IGameTile): void;
    addCell(cell: Cell, wantsToMove: Optional<RULE_DIRECTION>): void;
    removeCell(cell: Cell): void;
    updateCell(cell: Cell, wantsToMove: RULE_DIRECTION): void;
    addCells(sprite: GameSprite, cells: Cell[], wantsToMove: Optional<RULE_DIRECTION>): void;
    updateCells(sprite: GameSprite, cells: Cell[], wantsToMove: RULE_DIRECTION): void;
    removeCells(sprite: GameSprite, cells: Cell[]): void;
    has(cell: Cell): boolean;
    hasNegationTileWithModifier(): boolean;
    getCellsThatMatch<T extends Cellish>(cells?: Iterable<T>): Set<T>;
}
export declare class GameSpriteSingleColor extends GameSprite {
    private readonly color;
    constructor(source: IGameCode, name: string, optionalLegendChar: Optional<string>, colors: IColor[]);
    isTransparent(): boolean;
    hasAlpha(): boolean;
    hasPixels(): boolean;
    getPixels(spriteHeight: number, spriteWidth: number): IColor[][];
}
export declare class GameSpritePixels extends GameSprite {
    private readonly pixels;
    private readonly _isTransparent;
    private readonly _hasAlpha;
    constructor(source: IGameCode, name: string, optionalLegendChar: Optional<string>, pixels: IColor[][]);
    isTransparent(): boolean;
    hasAlpha(): boolean;
    getSprites(): this[];
    hasPixels(): boolean;
    getPixels(spriteHeight: number, spriteWidth: number): IColor[][];
}
export declare abstract class GameLegendTile extends BaseForLines implements IGameTile {
    readonly spriteNameOrLevelChar: string;
    readonly tiles: IGameTile[];
    protected collisionLayer: Optional<CollisionLayer>;
    private trickleCells;
    private trickleTilesWithModifier;
    private spritesCache;
    constructor(source: IGameCode, spriteNameOrLevelChar: string, tiles: IGameTile[]);
    equals(t: IGameTile): boolean;
    isOr(): boolean;
    abstract matchesCell(cell: Cell): boolean;
    abstract getSpritesThatMatch(cell: Cellish): Set<GameSprite>;
    abstract hasSingleCollisionLayer(): boolean;
    getName(): string;
    _getDescendantTiles(): IGameTile[];
    getSprites(): GameSprite[];
    setCollisionLayer(collisionLayer: CollisionLayer): void;
    getCollisionLayer(): CollisionLayer;
    getCollisionLayers(): CollisionLayer[];
    getCellsThatMatch<T extends Cellish>(cells?: Iterable<T>): Set<T>;
    subscribeToCellChanges(t: SimpleTileWithModifier): void;
    hasNegationTileWithModifier(): boolean;
    addCells(sprite: GameSprite, cells: Cell[], wantsToMove: Optional<RULE_DIRECTION>): void;
    updateCells(sprite: GameSprite, cells: Cell[], wantsToMove: Optional<RULE_DIRECTION>): void;
    removeCells(sprite: GameSprite, cells: Cell[]): void;
    hasCell(cell: Cell): boolean;
}
export declare class GameLegendTileSimple extends GameLegendTile {
    constructor(source: IGameCode, spriteNameOrLevelChar: string, tile: GameSprite);
    matchesCell(cell: Cell): boolean;
    getSpritesThatMatch(cell: Cellish): Set<GameSprite>;
    hasSingleCollisionLayer(): boolean;
}
export declare class GameLegendTileAnd extends GameLegendTile {
    matchesCell(cell: Cell): boolean;
    getSpritesThatMatch(cell: Cellish): Set<GameSprite>;
    hasSingleCollisionLayer(): boolean;
}
export declare class GameLegendTileOr extends GameLegendTile {
    isOr(): boolean;
    matchesCell(cell: Cell): boolean;
    getSpritesThatMatch(cell: Cellish): Set<GameSprite>;
    hasSingleCollisionLayer(): boolean;
}
