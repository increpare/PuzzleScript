import { Cell, Level } from '../engine';
import { Command, SoundItem } from '../parser/astTypes';
import { SpriteBitSet } from '../spriteBitSet';
import { DEBUG_FLAG, ICacheable, Optional, RULE_DIRECTION } from '../util';
import { BaseForLines, IGameCode } from './BaseForLines';
import { CollisionLayer } from './collisionLayer';
import { IGameNode } from './game';
import { GameSprite, IGameTile } from './tile';
export declare const SIMPLE_DIRECTION_DIRECTIONS: RULE_DIRECTION[];
export interface IRule extends IGameNode {
    hasMatches: (level: Level) => boolean;
    evaluate: (level: Level, onlyEvaluateFirstMatch: boolean) => IMutation[];
    getChildRules: () => IRule[];
    isLate: () => boolean;
    hasRigid: () => boolean;
    clearCaches: () => void;
    addCellsToEmptyRules: (cells: Iterable<Cell>) => void;
    totalTimeMs?: number;
    timesRan?: number;
    a11yGetConditionSprites(): Array<Set<GameSprite>>;
    toKey(): string;
}
export interface IMutation {
    messages: Array<A11Y_MESSAGE<Cell, GameSprite>>;
    hasCell: () => boolean;
    getCell: () => Cell;
    getCommand: () => Command<SoundItem<IGameTile>>;
}
declare class CellMutation implements IMutation {
    readonly messages: Array<A11Y_MESSAGE<Cell, GameSprite>>;
    private cell;
    constructor(cell: Cell, messages: Array<A11Y_MESSAGE<Cell, GameSprite>>);
    hasCell(): boolean;
    getCell(): Cell;
    getCommand(): Command<SoundItem<IGameTile>>;
}
export declare class SimpleRuleGroup extends BaseForLines implements IRule {
    isRandom: boolean;
    private rules;
    constructor(source: IGameCode, isRandom: boolean, rules: IRule[]);
    hasMatches(level: Level): boolean;
    evaluate(level: Level, onlyEvaluateFirstMatch: boolean): IMutation[];
    clearCaches(): void;
    getChildRules(): IRule[];
    isLate(): boolean;
    hasRigid(): boolean;
    addCellsToEmptyRules(cells: Iterable<Cell>): void;
    toKey(): string;
    a11yGetConditionSprites(): Set<GameSprite>[];
}
export declare class SimpleRuleLoop extends SimpleRuleGroup {
}
export declare class SimpleRule extends BaseForLines implements ICacheable, IRule {
    conditionBrackets: ISimpleBracket[];
    actionBrackets: ISimpleBracket[];
    commands: Array<Command<SoundItem<IGameTile>>>;
    debugFlag: Optional<DEBUG_FLAG>;
    private _isLate;
    private readonly isRigid;
    private isSubscribedToCellChanges;
    constructor(source: IGameCode, conditionBrackets: ISimpleBracket[], actionBrackets: ISimpleBracket[], commands: Array<Command<SoundItem<IGameTile>>>, isLate: boolean, isRigid: boolean, debugFlag: Optional<DEBUG_FLAG>);
    toKey(): string;
    getChildRules(): IRule[];
    subscribeToCellChanges(): void;
    clearCaches(): void;
    getMatches(level: Level): MatchedCellsForRule[][];
    evaluate(level: Level, onlyEvaluateFirstMatch: boolean): IMutation[];
    hasMatches(level: Level): boolean;
    isLate(): boolean;
    hasRigid(): boolean;
    canCollapseBecauseBracketsMatch(rule: SimpleRule): boolean;
    addCellsToEmptyRules(cells: Iterable<Cell>): void;
    a11yGetConditionSprites(): Set<GameSprite>[];
}
export declare class SimpleTileWithModifier extends BaseForLines implements ICacheable {
    readonly _isNegated: boolean;
    readonly _isRandom: boolean;
    readonly _direction: Optional<RULE_DIRECTION>;
    readonly _tile: IGameTile;
    readonly _debugFlag: Optional<DEBUG_FLAG>;
    private neighbors;
    private trickleCells;
    constructor(source: IGameCode, isNegated: boolean, isRandom: boolean, direction: Optional<RULE_DIRECTION>, tile: IGameTile, debugFlag: Optional<DEBUG_FLAG>);
    toKey(ignoreDebugFlag?: boolean): string;
    equals(t: SimpleTileWithModifier): boolean;
    clearCaches(): void;
    isNo(): boolean;
    isRandom(): boolean;
    getCollisionLayers(): Set<CollisionLayer>;
    subscribeToCellChanges(neighbor: SimpleNeighbor): void;
    addCells(tile: IGameTile, sprite: GameSprite, cells: Cell[], wantsToMove: Optional<RULE_DIRECTION>): void;
    updateCells(sprite: GameSprite, cells: Cell[], wantsToMove: Optional<RULE_DIRECTION>): void;
    removeCells(tile: IGameTile, sprite: GameSprite, cells: Cell[]): void;
    hasCell(cell: Cell): boolean;
    private matchesCellWantsToMove;
    private matchesFirstCell;
}
export declare abstract class ISimpleBracket extends BaseForLines implements ICacheable {
    readonly debugFlag: Optional<DEBUG_FLAG>;
    readonly direction: RULE_DIRECTION;
    protected firstCells: Set<Cell>;
    private allNeighbors;
    constructor(source: IGameCode, direction: RULE_DIRECTION, allNeighbors: SimpleNeighbor[], debugFlag: Optional<DEBUG_FLAG>);
    abstract subscribeToNeighborChanges(): void;
    abstract toKey(ignoreDebugFlag?: boolean): string;
    abstract clearCaches(): void;
    abstract prepareAction(action: ISimpleBracket): void;
    abstract addCell(index: number, neighbor: SimpleNeighbor, t: SimpleTileWithModifier, sprite: GameSprite, cell: Cell, wantsToMove: Optional<RULE_DIRECTION>): void;
    abstract removeCell(index: number, neighbor: SimpleNeighbor, t: SimpleTileWithModifier, sprite: GameSprite, cell: Cell): void;
    abstract addCellsToEmptyRules(cells: Iterable<Cell>): void;
    abstract getMatches(level: Level, actionBracket: Optional<ISimpleBracket>): MatchedCellsForRule[];
    abstract a11yGetSprites(): Array<Set<GameSprite>>;
    _getAllNeighbors(): SimpleNeighbor[];
    hasMatches(level: Level, actionBracket: Optional<ISimpleBracket>): boolean;
}
interface IMatchedCellAndCorrespondingNeighbors {
    cell: Cell;
    condition: SimpleNeighbor;
    action: Optional<SimpleNeighbor>;
}
declare class MatchedCellsForRule {
    readonly cellsAndNeighbors: IMatchedCellAndCorrespondingNeighbors[];
    private cellKeys;
    constructor(cellsAndNeighbors: IMatchedCellAndCorrespondingNeighbors[]);
    firstCell(): Cell;
    lastCell(): Cell;
    doesStillMatch(): boolean;
    populateMagicOrTiles(magicOrTiles: Map<IGameTile, Set<GameSprite>>): void;
    evaluate(magicOrTiles: Map<IGameTile, Set<GameSprite>>): IMutation[];
}
export declare class SimpleBracket extends ISimpleBracket {
    protected actionDebugFlag: Optional<DEBUG_FLAG>;
    private neighbors;
    private ellipsisBracketListeners;
    private readonly spritesPresentInRowOrColumn;
    private readonly anySpritesPresentInRowOrColumn;
    constructor(source: IGameCode, direction: RULE_DIRECTION, neighbors: SimpleNeighbor[], debugFlag: Optional<DEBUG_FLAG>);
    toKey(): string;
    dependsOnDirection(): boolean;
    subscribeToNeighborChanges(): void;
    addEllipsisBracket(bracket: SimpleEllipsisBracket, token: BEFORE_OR_AFTER): void;
    clearCaches(): void;
    getNeighbors(): SimpleNeighbor[];
    prepareAction(actionBracket: ISimpleBracket): void;
    addCellsToEmptyRules(cells: Iterable<Cell>): void;
    _addFirstCell(firstCell: Cell): void;
    addCell(index: number, neighbor: SimpleNeighbor, t: SimpleTileWithModifier, sprite: GameSprite, cell: Cell, wantsToMove: Optional<RULE_DIRECTION>): void;
    removeCell(index: number, neighbor: SimpleNeighbor, t: SimpleTileWithModifier, sprite: GameSprite, cell: Cell): void;
    shouldUseOnDemandMethod(): boolean;
    getMatchesByTrickling(level: Level, actionBracket: Optional<SimpleBracket>): MatchedCellsForRule[];
    getMatchesByLooping(level: Level, actionBracket: Optional<SimpleBracket>): MatchedCellsForRule[];
    getMatches(level: Level, actionBracket: Optional<SimpleBracket>): MatchedCellsForRule[];
    a11yGetSprites(): Set<GameSprite>[];
    protected _removeFirstCell(firstCell: Cell): void;
    private matchesDownstream;
    private getUpstream;
    private matchesUpstream;
    private getFirstCellToRemove;
    private addToCellMatches;
    private addIfCellMatches;
}
declare enum BEFORE_OR_AFTER {
    BEFORE = 0,
    AFTER = 1
}
export declare class SimpleEllipsisBracket extends ISimpleBracket {
    beforeEllipsisBracket: SimpleBracket;
    afterEllipsisBracket: SimpleBracket;
    private linkages;
    constructor(source: IGameCode, direction: RULE_DIRECTION, beforeEllipsisNeighbors: SimpleNeighbor[], afterEllipsisNeighbors: SimpleNeighbor[], debugFlag: Optional<DEBUG_FLAG>);
    subscribeToNeighborChanges(): void;
    toKey(): string;
    clearCaches(): void;
    prepareAction(action: ISimpleBracket): void;
    addCellsToEmptyRules(cells: Iterable<Cell>): void;
    addCell(index: number, neighbor: SimpleNeighbor, t: SimpleTileWithModifier, sprite: GameSprite, cell: Cell, wantsToMove: Optional<RULE_DIRECTION>): void;
    removeCell(index: number, neighbor: SimpleNeighbor, t: SimpleTileWithModifier, sprite: GameSprite, cell: Cell): void;
    addFirstCell(bracket: SimpleBracket, firstCell: Cell, token: BEFORE_OR_AFTER): void;
    removeFirstCell(bracket: SimpleBracket, firstCell: Cell, token: BEFORE_OR_AFTER): void;
    getMatches(level: Level, actionBracket: Optional<SimpleEllipsisBracket>): MatchedCellsForRule[];
    a11yGetSprites(): Set<GameSprite>[];
    private checkInvariants;
}
export declare enum A11Y_MESSAGE_TYPE {
    ADD = "ADD",
    REPLACE = "REPLACE",
    REMOVE = "REMOVE",
    MOVE = "MOVE"
}
export declare type A11Y_MESSAGE<TCell, TSprite> = {
    type: A11Y_MESSAGE_TYPE.ADD;
    sprites: Iterable<TSprite>;
    cell: TCell;
} | {
    type: A11Y_MESSAGE_TYPE.REPLACE;
    replacements: Iterable<{
        oldSprite: TSprite;
        newSprite: TSprite;
    }>;
    cell: TCell;
} | {
    type: A11Y_MESSAGE_TYPE.REMOVE;
    sprites: Iterable<TSprite>;
    cell: TCell;
} | {
    type: A11Y_MESSAGE_TYPE.MOVE;
    oldCell: TCell;
    newCell: TCell;
    direction: RULE_DIRECTION;
    sprite: TSprite;
};
export declare class SimpleNeighbor extends BaseForLines implements ICacheable {
    readonly _tilesWithModifier: Set<SimpleTileWithModifier>;
    spritesPresent: SpriteBitSet;
    anySpritesPresent: Set<SpriteBitSet>;
    private brackets;
    private debugFlag;
    private staticCache;
    private cacheYesBitSets;
    private cacheNoBitSets;
    private cacheDirections;
    private cacheMultiCollisionLayerTiles;
    private spritesMissing;
    private spriteMovementsPresent;
    private orTileMovementsPresent;
    private lruCache;
    private trickleCells;
    constructor(source: IGameCode, tilesWithModifier: Set<SimpleTileWithModifier>, debugFlag: Optional<DEBUG_FLAG>);
    toKey(): string;
    dependsOnDirection(): boolean;
    prepareAction(actionNeighbor: SimpleNeighbor): void;
    evaluate(actionNeighbor: SimpleNeighbor, cell: Cell, magicOrTiles: Map<IGameTile, Set<GameSprite>>): CellMutation | null;
    clearCaches(): void;
    populateMagicOrTiles(cell: Cell, magicOrTiles: Map<IGameTile, Set<GameSprite>>): void;
    subscribeToTileChanges(bracket: ISimpleBracket, index: number): void;
    matchesCellSimple(cell: Cell): boolean;
    addCells(t: SimpleTileWithModifier, sprite: GameSprite, cells: Iterable<Cell>, wantsToMove: Optional<RULE_DIRECTION>): void;
    updateCells(t: SimpleTileWithModifier, sprite: GameSprite, cells: Iterable<Cell>, wantsToMove: RULE_DIRECTION): void;
    removeCells(t: SimpleTileWithModifier, sprite: GameSprite, cells: Iterable<Cell>): void;
    private check1;
    private check2;
    private check3;
    private check4;
    private matchesCell;
    private matchesTiles;
}
export {};
