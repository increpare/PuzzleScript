"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hexToRgb = exports.TransparentColor = exports.HexColor = exports.RGB = void 0;
const BaseForLines_1 = require("./BaseForLines");
class RGB {
    constructor(r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }
    isDark() {
        return this.r + this.g + this.b < 128 * 3;
    }
}
exports.RGB = RGB;
class HexColor extends BaseForLines_1.BaseForLines {
    constructor(source, hex) {
        super(source);
        this.hex = hex;
    }
    isTransparent() { return false; }
    hasAlpha() { return this.hex.length > 7; /*#123456aa*/ }
    toRgb() {
        return hexToRgb(this.hex);
    }
    toHex() {
        return this.hex;
    }
}
exports.HexColor = HexColor;
class TransparentColor extends BaseForLines_1.BaseForLines {
    constructor(source) {
        super(source);
    }
    isTransparent() { return true; }
    hasAlpha() { return false; }
    toRgb() {
        throw new Error('BUG: Transparent colors do not have RGB data');
    }
    toHex() {
        throw new Error('BUG: Transparent colors do not have a hex color value');
    }
}
exports.TransparentColor = TransparentColor;
function hexToRgb(hex) {
    // https://stackoverflow.com/a/5624139
    // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
    const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
    hex = hex.replace(shorthandRegex, (m, r, g, b) => {
        return r + r + g + g + b + b;
    });
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(hex);
    if (result) {
        return new RGB(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), result[4] ? parseInt(result[4], 16) / 255 : null);
    }
    else {
        throw new Error(`BUG: Invalid hex color: '${hex}'`);
    }
}
exports.hexToRgb = hexToRgb;
//# sourceMappingURL=colors.js.map