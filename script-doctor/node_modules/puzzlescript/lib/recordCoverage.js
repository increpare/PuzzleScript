"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.saveCoverageFile = void 0;
function saveCoverageFile(data, absPath, pathRelative) {
    // record the appliedRules in a coverage.json file
    // key = Line number, value = count of times the rule executed
    const codeCoverageTemp = new Map();
    // First add all the Tiles, Legend Items, collisionLayers, Rules, and Levels.
    // Then, after running, add all the matched rules.
    function coverageKey(node) {
        // the HTML reporter does not like multiline fields.
        // Rather than report multiple times, we just report the 1st line
        // This is a problem with `startloop`
        const { start, end } = node.__getLineAndColumnRange();
        if (start.line !== end.line) {
            return JSON.stringify({
                end: {
                    col: start.col + 3,
                    line: start.line
                },
                start: {
                    col: start.col - 1,
                    line: start.line
                }
            });
        }
        else {
            return JSON.stringify({
                end: {
                    col: end.col - 1,
                    line: end.line
                },
                start: {
                    col: start.col - 1,
                    line: start.line
                }
            });
        }
    }
    function addNodeToCoverage(node) {
        codeCoverageTemp.set(coverageKey(node), { count: 0, node });
    }
    // data.objects.forEach(addNodeToCoverage)
    // data.legends.forEach(addNodeToCoverage)
    // data.sounds.forEach(addNodeToCoverage)
    // data.collisionLayers.forEach(addNodeToCoverage) // these entries are sometimes (always?) null
    data.rules.forEach(addNodeToCoverage);
    data.winConditions.forEach(addNodeToCoverage);
    // data.levels.forEach(addNodeToCoverage)
    function recursivelyGetRules(rules) {
        let ret = [];
        for (const rule of rules) {
            ret.push(rule);
            ret = ret.concat(recursivelyGetRules(rule.getChildRules()));
        }
        return ret;
    }
    // record the tick coverage
    const ary = new Array();
    const nodesToCover = ary.concat(recursivelyGetRules(data.rules))
        /*.concat(data.objects).concat(data.legends)*/
        .concat(data.winConditions);
    /*.concat(data.levels)*/
    for (const node of nodesToCover) {
        const line = coverageKey(node);
        const nodeCount = node.__coverageCount || 0;
        const existingEntry = codeCoverageTemp.get(line);
        if (existingEntry) {
            codeCoverageTemp.set(line, { count: existingEntry.count + nodeCount, node });
        }
        else {
            codeCoverageTemp.set(line, { count: nodeCount, node });
        }
    }
    const codeCoverage2 = [...codeCoverageTemp.entries()].map(([key, { count, node }]) => {
        const loc = JSON.parse(key);
        return { loc, count, node };
    });
    // Generate the coverage.json file from which Rules were applied
    const statementMap = {};
    const fnMap = {};
    const f = {};
    const s = {};
    // Add all the matched rules
    codeCoverage2.forEach((entry, index) => {
        const { loc, node } = entry;
        let { count } = entry;
        // sometimes count can be null
        if (!(count >= 0)) {
            count = 0;
        }
        s[index] = count;
        statementMap[index] = loc;
        f[index] = count;
        fnMap[index] = {
            decl: loc,
            line: loc.start.line,
            loc,
            name: node.toSourceString()
        };
    });
    const relPath = pathRelative(absPath);
    const codeCoverageEntry = {
        b: {},
        branchMap: {},
        f,
        fnMap,
        path: relPath,
        s,
        statementMap
    };
    const codeCoverageObj = {};
    codeCoverageObj[relPath] = codeCoverageEntry;
    return codeCoverageObj;
}
exports.saveCoverageFile = saveCoverageFile;
//# sourceMappingURL=recordCoverage.js.map