import { IColor } from '../models/colors';
import { GameData } from '../models/game';
import { GameSprite } from '../models/tile';
import { Cellish, Optional } from '../util';
declare abstract class BaseUI {
    PIXEL_WIDTH: number;
    PIXEL_HEIGHT: number;
    protected gameData: Optional<GameData>;
    protected renderedPixels: Array<Array<{
        hex: string;
        chars: string;
    }>>;
    protected windowOffsetColStart: number;
    protected windowOffsetRowStart: number;
    protected windowOffsetWidth: Optional<number>;
    protected windowOffsetHeight: Optional<number>;
    protected isDumpingScreen: boolean;
    protected SPRITE_WIDTH: number;
    protected SPRITE_HEIGHT: number;
    protected hasVisualUi: boolean;
    private currentLevelCells;
    private currentLevelMessage;
    private readonly cellColorCache;
    constructor();
    destroy(): void;
    onGameChange(gameData: GameData): void;
    getGameData(): GameData;
    onLevelChange(level: number, cells: Optional<Cellish[][]>, message: Optional<string>): void;
    getCurrentLevelCells(): Cellish[][];
    debugRenderScreen(): void;
    renderMessageScreen(message: string): void;
    renderScreen(clearCaches: boolean, renderScreenDepth?: number): void;
    drawCells(cells: Iterable<Cellish>, dontRestoreCursor: boolean, renderScreenDepth?: number): void;
    getPixelsForCell(cell: Cellish): IColor[][];
    protected createMessageTextScreen(messageStr: string): string[];
    protected createMessageSprites(messageStr: string): Set<GameSprite>[][];
    protected abstract renderLevelScreen(levelRows: Cellish[][], renderScreenDepth: number): void;
    protected abstract setPixel(x: number, y: number, hex: string, fgHex: Optional<string>, chars: string): void;
    protected abstract checkIfCellCanBeDrawnOnScreen(cellStartX: number, cellStartY: number): boolean;
    protected cellPosToXY(cell: Cellish): {
        isOnScreen: boolean;
        cellStartX: number;
        cellStartY: number;
    };
    protected abstract getMaxSize(): {
        columns: number;
        rows: number;
    };
    protected abstract drawCellsAfterRecentering(cells: Iterable<Cellish>, renderScreenDepth: number): void;
    protected clearScreen(): void;
    private recenterPlayerIfNeeded;
}
export default BaseUI;
