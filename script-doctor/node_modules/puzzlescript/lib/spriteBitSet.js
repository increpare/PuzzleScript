"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpriteBitSet = void 0;
// BitSet does not export a default so import does not work in webpack-built file
const BitSet2 = require('bitset'); // tslint:disable-line:no-var-requires
class CustomBitSet {
    constructor(items, bitSet) {
        if (bitSet) {
            this.bitSet = bitSet;
        }
        else {
            this.bitSet = new BitSet2();
        }
        if (items) {
            this.addAll(items);
        }
    }
    // Unused
    // public clear() {
    //     this.bitSet.clear()
    // }
    isEmpty() {
        return this.bitSet.isEmpty();
    }
    addAll(items) {
        for (const sprite of items) {
            this.add(sprite);
        }
    }
    // Unused
    // public removeAll(items: Iterable<T>) {
    //     for (const sprite of items) {
    //         this.remove(sprite)
    //     }
    // }
    add(item) {
        this.bitSet.set(this._indexOf(item));
    }
    remove(item) {
        this.bitSet.clear(this._indexOf(item));
    }
    has(item) {
        return !!this.bitSet.get(this._indexOf(item));
    }
    containsAll(other) {
        return other.bitSet.cardinality() === this.bitSet.and(other.bitSet).cardinality();
    }
    containsAny(other) {
        return !this.bitSet.and(other.bitSet).isEmpty();
    }
    containsNone(other) {
        return other.bitSet.and(this.bitSet).isEmpty();
    }
    _indexOf(item) {
        const index = this.indexOf(item);
        if (index < 0) {
            throw new Error(`BUG: Expected the item index to be >= 0 but it was ${index}`);
        }
        return index;
    }
}
class SpriteBitSet extends CustomBitSet {
    indexOf(item) {
        return item.allSpritesBitSetIndex;
    }
    union(bitSets) {
        let ret = this; // tslint:disable-line:no-this-assignment
        for (const bitSet of bitSets) {
            ret = ret.or(bitSet);
        }
        return ret;
    }
    toString(gameData) {
        const str = [];
        for (const sprite of this.getSprites(gameData)) {
            str.push(sprite.getName());
        }
        return str.join(' ');
    }
    getSprites(gameData) {
        const sprites = new Set();
        for (const sprite of gameData.objects) {
            if (this.has(sprite)) {
                sprites.add(sprite);
            }
        }
        return sprites;
    }
    or(bitSet) {
        return new SpriteBitSet(undefined, this.bitSet.or(bitSet.bitSet));
    }
}
exports.SpriteBitSet = SpriteBitSet;
//# sourceMappingURL=spriteBitSet.js.map