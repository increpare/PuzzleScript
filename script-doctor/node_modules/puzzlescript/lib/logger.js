"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.logger = exports.LOG_LEVEL = void 0;
var LOG_LEVEL;
(function (LOG_LEVEL) {
    LOG_LEVEL["SEVERE"] = "SEVERE";
    LOG_LEVEL["WARN"] = "WARN";
    LOG_LEVEL["INFO"] = "INFO";
    LOG_LEVEL["DEBUG"] = "DEBUG";
    LOG_LEVEL["TRACE"] = "TRACE";
})(LOG_LEVEL = exports.LOG_LEVEL || (exports.LOG_LEVEL = {}));
const LEVELS = [
    LOG_LEVEL.SEVERE,
    LOG_LEVEL.WARN,
    LOG_LEVEL.INFO,
    LOG_LEVEL.DEBUG,
    LOG_LEVEL.TRACE
];
function toNum(level) {
    return LEVELS.indexOf(level);
}
function toLevel(level) {
    switch (level.toUpperCase()) {
        case LOG_LEVEL.SEVERE: return LOG_LEVEL.SEVERE;
        case LOG_LEVEL.WARN: return LOG_LEVEL.WARN;
        case LOG_LEVEL.INFO: return LOG_LEVEL.INFO;
        case LOG_LEVEL.DEBUG: return LOG_LEVEL.DEBUG;
        case LOG_LEVEL.TRACE: return LOG_LEVEL.TRACE;
        default:
            throw new Error(`ERROR: Invalid log level. valid levels are ${JSON.stringify(LEVELS)} but was given '${level}'`);
    }
}
class Logger {
    constructor() {
        var _a;
        this.currentLevelNum = toNum(toLevel((_a = process.env.LOG_LEVEL) !== null && _a !== void 0 ? _a : LOG_LEVEL.SEVERE));
    }
    isLevel(level) {
        return toNum(level) <= this.currentLevelNum;
    }
    warn(message) {
        this.log(LOG_LEVEL.WARN, message);
    }
    info(message) {
        this.log(LOG_LEVEL.INFO, message);
    }
    debug(message) {
        this.log(LOG_LEVEL.DEBUG, message);
    }
    trace(message) {
        this.log(LOG_LEVEL.TRACE, message);
    }
    logFn(level, fn) {
        if (this.isLevel(level)) {
            console.warn(fn()); // tslint:disable-line:no-console
        }
    }
    log(level, message) {
        if (typeof message === 'string') {
            this.logFn(level, () => message);
        }
        else {
            this.logFn(level, message);
        }
    }
}
exports.logger = new Logger();
//# sourceMappingURL=logger.js.map