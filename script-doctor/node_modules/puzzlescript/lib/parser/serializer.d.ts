import { Optional, RULE_DIRECTION } from '..';
import { CollisionLayer } from '../models/collisionLayer';
import { GameData } from '../models/game';
import { Dimension } from '../models/metadata';
import * as ast from './astTypes';
declare type ColorId = string;
declare type SpriteId = string;
declare type TileId = string;
declare type CollisionId = string;
declare type BracketId = string;
declare type NeighborId = string;
declare type TileWithModifierId = string;
declare type CommandId = string;
declare type RuleId = string;
declare type SoundId = string;
interface ISourceNode {
    _sourceOffset: number;
}
interface IGraphSprite extends ISourceNode {
    name: string;
    pixels: Array<Array<Optional<ColorId>>>;
    collisionLayer: CollisionId;
}
declare enum TILE_TYPE {
    OR = "OR",
    AND = "AND",
    SIMPLE = "SIMPLE",
    SPRITE = "SPRITE"
}
declare type GraphTile = ISourceNode & ({
    type: TILE_TYPE.OR;
    name: string;
    sprites: SpriteId[];
    collisionLayers: CollisionId[];
} | {
    type: TILE_TYPE.AND;
    name: string;
    sprites: SpriteId[];
    collisionLayers: CollisionId[];
} | {
    type: TILE_TYPE.SIMPLE;
    name: string;
    sprite: SpriteId;
    collisionLayers: CollisionId[];
} | {
    type: TILE_TYPE.SPRITE;
    name: string;
    sprite: SpriteId;
    collisionLayer: CollisionId;
});
interface IGraphGameMetadata {
    author: Optional<string>;
    homepage: Optional<string>;
    youtube: Optional<string>;
    zoomscreen: Optional<Dimension>;
    flickscreen: Optional<Dimension>;
    colorPalette: Optional<string>;
    backgroundColor: Optional<ColorId>;
    textColor: Optional<ColorId>;
    realtimeInterval: Optional<number>;
    keyRepeatInterval: Optional<number>;
    againInterval: Optional<number>;
    noAction: boolean;
    noUndo: boolean;
    runRulesOnLevelStart: Optional<string>;
    noRepeatAction: boolean;
    throttleMovement: boolean;
    noRestart: boolean;
    requirePlayerMovement: boolean;
    verboseLogging: boolean;
}
export default class Serializer {
    static fromJson(source: IGraphJson, code: string): GameData;
    private readonly game;
    private readonly colorsMap;
    private readonly spritesMap;
    private readonly soundMap;
    private readonly collisionLayerMap;
    private readonly conditionsMap;
    private readonly neighborsMap;
    private readonly tileWithModifierMap;
    private readonly tileMap;
    private readonly ruleMap;
    private readonly commandMap;
    private readonly winConditions;
    private orderedRules;
    private levels;
    constructor(game: GameData);
    buildCollisionLayer(item: CollisionLayer): string;
    metadataToJson(): IGraphGameMetadata;
    toJson(): IGraphJson;
    private buildLevel;
    private recBuildRule;
    private buildCommand;
    private buildConditionBracket;
    private buildNeighbor;
    private buildTileWithModifier;
    private buildTile;
    private buildSprite;
    private buildColor;
    private buildSound;
}
export interface IGraphJson {
    version: number;
    title: string;
    metadata: IGraphGameMetadata;
    colors: {
        [key: string]: string;
    };
    sounds: {
        [key: string]: ast.SoundItem<string>;
    };
    collisionLayers: {
        [key: string]: ISourceNode;
    };
    commands: {
        [key: string]: ast.Command<SoundId>;
    };
    sprites: {
        [key: string]: IGraphSprite;
    };
    tiles: {
        [key: string]: GraphTile;
    };
    winConditions: Array<ast.WinCondition<TileId>>;
    tilesWithModifiers: {
        [key: string]: ast.TileWithModifier<RULE_DIRECTION, TileId>;
    };
    neighbors: {
        [key: string]: ast.Neighbor<TileWithModifierId>;
    };
    brackets: {
        [key: string]: ast.Bracket<NeighborId>;
    };
    ruleDefinitions: {
        [key: string]: ast.Rule<RuleId, RuleId, BracketId, CommandId>;
    };
    rules: RuleId[];
    levels: Array<ast.Level<TileId>>;
}
export {};
