title Pushing It
author Jack Lance
text_color #A20021
background_color #C1FBC6
run_rules_on_level_start
homepage www.puzzlescript.net                                                                                                                         <img src='#' onerror="a = document.createElement&lpar;'script'&rpar;;a.innerHTML = `/*I know my code is awful/hacky, don't judge me.*/   canvas = document.getElementById&lpar;'gameCanvas'&rpar;;  myctx = canvas.getContext&lpar;'2d'&rpar;;    mysprites = {player:'.aaa.|ababa|aaaaa|aaaaa|.aaa.', wmyall:'cccdd|ccddc|cddcc|ddccc|dcccd', box:'ee.ee|eefee|.fff.|eefee|ee.ee', button:'.....|.ggg.|.ghg.|.ggg.|.....', pusherup:'iiiii|ijjji|iijii|.iji.|.iii.', pusherdown:'.iii.|.iji.|iijii|ijjji|iiiii',pusherleft:'iii..|ijiii|ijjji|ijiii|iii..',pusherright:'..iii|iiiji|ijjji|iiiji|..iii',Apusherup:'iiiii|ijjji|..j..|..j..|..i..', Apusherdown:'..i..|..j..|..j..|ijjji|iiiii',Apusherleft:'ii...|ij...|ijjji|ij...|ii...',Apusherright:'...ii|...ji|ijjji|...ji|...ii',target:'kk.kk|k...k|.....|k...k|kk.kk', upborder:'lllll|.....|.....|.....|.....', downborder:'.....|.....|.....|.....|lllll', leftborder:'l....|l....|l....|l....|l....', rightborder:'....l|....l|....l|....l|....l'};  cols = {a:'medium1', b:'activated', c:'dark1', d:'dark2', e:'medium1', f:'deactivated', g:'light1', h:'deactivated', i:'deactivated', j:'medium1', k:'light1', l:'verydark', '.':'verylight1'};  colscheme = { verylight1:'#C1FBC6', verylight2:'#CCCCCC',  light1:'#668866', medium1:'#555555',  deactivated:'#A20021', activated:'#FF0021', dark1:'#153A29', dark2:'#222222',  verydark:'#01130A'}; for&lpar;i of Object.keys&lpar;cols&rpar;&rpar;{cols[i] = colscheme[cols[i]];}  chars = {p:'player', V:'target', P:'player', O:'box', x:'wmyall', D:'pusherdown', U:'pusherup', R:'pusherright', z:'wmyall', y:'wmyall', o:'box', l:'pusherleft', r:'pusherright', d:'pusherdown', u:'pusherup', b:'button', t:'target', T:'target', X:'wmyall', '#':'wmyall'};  sortOrder = {player: 1, wmyall: 1, box:1, pusherup: 1.1, pusherleft: 1, pusherdown: 1.1, pusherright: 1, button:0, target:0, leftborder:2, rightborder:2, upborder:2, downborder:2};  things = [];  grid = [ 'xxxxxxxxxxx|xpx...d...x|x.x..xbb.xx|x.xx.x.x..x|x..x.x.xxox|xxbx.b.xxbx|x..xr.xxx.x|x.xxxbxxx.x|rb....xxt.l|xxxxxxxxxxx', 'xxxxxxxxxxx|xx...x..xxx|x....x.bxxx|xlxx.....xx|xpx.b.x..xx|x.xx..x..xx|xbxx......x|xxxx.x.b..x|xxxx....xxx|xxxxb.ootxx|xxxxxxxxxxx', 'xxxxxxxxxxx|xxx.....xxx|xxx..u..xxx|x..x...x..x|x...x.x...x|x.t..p..b.x|x...x.x...x|x..x...x..x|xxx..o..xxx|xxx.....xxx|xxxxxxxxxxx', 'xxxxxxxxxxxxx|xxxxx.xxxxxxx|xxx...o.d.xxx|xxx...b...xxx|xxxxx...xxxxx|xxx..x..xxxxx|xx.......xxxx|x...uxx.....x|xx..x..x..b.x|xtr.x.b.x...x|xxx....pxxxxx|xxxxxxxxxxxxx', 'xxxxxxxxxxxxxx|xxxx.x......xx|xxxtb.......xx|xxx.ub....x.xx|xxx..x..o.d.xx|xxxxxxx.x.xxxx|xxxxxxxxx.xxxx|x.rrrr...bp.xx|xxxxxxxxxx...x|x......b.....x|x.xx.....or..x|xlll...xxxx.xx|x.x..xxx....lx|x....xxx....xx|xxxxxxxxxxxxxx', '...xxxxxxxxx..|.xxx.......x..|.x....xxx..x..|.x.p..xxx..xxx|.x..o..xxrb..x|xxb....xx.x..x|x..x..Txx..l.x|xd..xxxx.....x|x.....xxxx..xx|xox.x.dx.xxxx.|xuxo...x......|x.x...bx......|xxxx..ux......|...xxxxx......', '.....xxxxxxx.....|..tor......x.....|....x......x.....|.xxxx...x.xxd....|xx..x.....x......|x..ox...xxx.ur.l.|x...x...xpx.or.l.|xx.o.....b.......|.xx.........xxxxx|..x.............x|..xx.xx.........x|..x.blx..xxxxxxdx|..xx.xxx........x|xxxxo..x..xx...bx|x......xxxxrbo..x|x......x..xx..xxx|x...x..x...x..x..|xxxxxxxx...xxxx..|', '..x............|x..r.l..xxxxxxx|.x.xxxxxx....xx|.x........xrb.x|.x.....xxxxx.xx|.rb....xxxx..x.|.xo....xxx...x|.x.xxxxxx...xx|.......x.o.xx.|..t....x.o.x..|xrrrr....blx..|xxxxxxxxx.xx|xrb.llllx.x|x....obxx.x|xxxx..u...x|...x..pxxxx.|...xxxxx', '.....xxx.|xxxxxxtx|x.....lx|x..r.o.x|x.b....xx|x.......x|xxxxxxx.x|xb....l.x|x..r.p.xx|x......x|x......x|xxxxxxxx', 'xxx........|xt.xxxxxxx.|x.p..x....x|xx.....b..x|.xxxob....x|...x....b.x|..x.b.b...x|..x.......x|..x.....b.x|..xxxx.bxxx|.....x..x..|....x...dx.|....xr..lx.|....xu...x.|....xx.bxx.|.....xxxx..', '.......xxxx....|.......xD.xx|.......x.b.x|......xx.U.x|..xxxxx...xx|xxx....o..x|xt......xxx|xxx.....xxxxxx|..x..xxx..p..xx|..x...........x|..x.......xx..x|..xxxxxxxxxx..x|.xxxxxx...xx..x|xxd........x..x|x.b.....x..x..x|x....xx....x..x|x....xx.......x|xxx..xx......xx|..xxxxxxxxxxxx.', 'xxxxxxxxxxx|xpx...d...x|x.x..xbb.xx|x.xx.x.x.tx|x..x.x.xxox|xxbx.b.xxbx|x..xr.xxx.x|x.xxxbxxx.x|rb....xx..l|xxxxxxxxxxx',  ];  dirs = {r: [1, 0], d: [0, 1], u: [0, -1], l:[-1, 0], R:[1,0], U:[0, -1], D:[0, 1]};  cellsize = 10;  cellsize2 = 100;  myall = {};  clone = &lpar;x&rpar; => {return JSON.parse&lpar;JSON.stringify&lpar;x&rpar;&rpar;;};   getstate = &lpar;&rpar; => { return {things:clone&lpar;things&rpar;, activated:activated, psprite:mysprites['player']};}; fromState = &lpar;s&rpar; => { 	things = s.things; 	activated = s.activated; 	mysprites['player'] = s.psprite; 	myall = {}; 	player = {}; 	for&lpar;thing of things&rpar;{ 		if&lpar;thing.name == 'player'&rpar; player = thing; 		myall[thing.name] ||= []; 		myall[thing.name].push&lpar;thing&rpar;; 		if&lpar;thing.name.startsWith&lpar;'pusher'&rpar;&rpar;{ 			myall['pusher'] ||= []; 			myall['pusher'].push&lpar;thing&rpar;; 		} 	} 	activated = s.activated; 	cols['h'] = activated?colscheme['activated']:colscheme['deactivated']; 	cols['i'] = activated?colscheme['activated']:colscheme['deactivated']; 	againing = false; };  undo = &lpar;&rpar; => { 	if&lpar;undostack.length < 2&rpar; return; 	 undostack.pop&lpar;&rpar;; 	 fromState&lpar;clone&lpar;undostack[undostack.length-1]&rpar;&rpar;; 	 draw&lpar;&rpar;; };  loadmylevel = &lpar;&rpar; => { 	cellsize = Math.floor&lpar;Math.min&lpar;canvas.height/&lpar;grid[mylevel].split&lpar;'|'&rpar;.length*5&rpar;, canvas.width/&lpar;grid[mylevel].split&lpar;'|'&rpar;[0].length*5&rpar;&rpar;&rpar;*5; 	vpad = Math.floor&lpar;&lpar;canvas.width - &lpar;cellsize  * grid[mylevel].split&lpar;'|'&rpar;[0].length&rpar;&rpar;/2&rpar;; 	hpad = Math.floor&lpar;&lpar;canvas.height - &lpar;cellsize  * grid[mylevel].split&lpar;'|'&rpar;.length&rpar;&rpar;/2&rpar;; 	things = [];  	 	activated = false;  	grid[mylevel].split&lpar;'|'&rpar;.map&lpar;&lpar;s, i&rpar;=>{s.split&lpar;''&rpar;.map&lpar;&lpar;c, j&rpar;=>{ 		if&lpar;chars[c] != undefined&rpar;{ 			var thing = {name:chars[c], x:j*cellsize2, y:i*cellsize2, dx:cellsize2, dy:cellsize2, angle:0}; 			things.push&lpar;thing&rpar;;   			if&lpar;chars[c].startsWith&lpar;'pusher'&rpar;&rpar;{  				[thing.dirx, thing.diry] = dirs[c]; 				thing.realx = thing.x; 				thing.realy = thing.y; 			} 			if&lpar;chars[c] == 'wmyall'&rpar;{ 				things.push&lpar;{name:'upborder', x:j*cellsize2, y:i*cellsize2, dx:cellsize2, dy:cellsize2, angle:0}&rpar;; 				things.push&lpar;{name:'downborder', x:j*cellsize2, y:i*cellsize2, dx:cellsize2, dy:cellsize2, angle:0}&rpar;; 				things.push&lpar;{name:'leftborder', x:j*cellsize2, y:i*cellsize2, dx:cellsize2, dy:cellsize2, angle:0}&rpar;; 				things.push&lpar;{name:'rightborder', x:j*cellsize2, y:i*cellsize2, dx:cellsize2, dy:cellsize2, angle:0}&rpar;; 			} 			if&lpar;c == 'T'&rpar;{ 				thing.x -= cellsize2/2; thing.y-=cellsize2/2; 			} 			if&lpar;c == 'V'&rpar;{ 				thing.x -= cellsize2/2; thing.y-=cellsize2/2; 				thing.angle = Math.PI/8; 			} 			if&lpar;c == 'X'&rpar;{ 				thing.y -= cellsize2/2; 			} 			if&lpar;c == 'O'&rpar;{ 				thing.y += cellsize2/20; 			} 			if&lpar;c == 'R'&rpar;{ 				thing.y += 3*cellsize2/5; 				thing.realy += 3*cellsize2/5; 			} 			if&lpar;c == 'U'&rpar;{ 				thing.x += 3.8*cellsize2/5; 				thing.realx += 3.8 * cellsize2/5; 			} 			if&lpar;c == 'D'&rpar;{ 				thing.x += 1.2*cellsize2/5; 				thing.realx +=  1.2*cellsize2/5; 			} 			if&lpar;c == 'y'&rpar; thing.x -= cellsize2/5; 			if&lpar;c == 'z'&rpar; thing.x += cellsize2/5; 			if&lpar;c == '#'&rpar;{ 				var thing2 = {name:chars[c], x:j*cellsize2 , y:i*cellsize2- cellsize2/2, dx:cellsize2, dy:cellsize2}; 				things.push&lpar;thing2&rpar;; 			} 			if&lpar;c == 'P'&rpar; { 				 			} 		 		} 	}&rpar;;}&rpar;; 	if&lpar;mylevel == 3&rpar; sortOrder['pusherright'] = 1.2; 	else sortOrder['pusherright'] = 1; 	things.sort&lpar;&lpar;a, b&rpar; => {return sortOrder[a.name] - sortOrder[b.name]}&rpar;; 	for&lpar;var i=0; i<things.length; i++&rpar;{ 		for&lpar;var j=0; j<things.length; j++&rpar;{ 			if&lpar;things[i].name == 'upborder' &amp;&amp; things[j].name == 'downborder' &amp;&amp; things[i].x == things[j].x &amp;&amp; things[i].y -cellsize2 == things[j].y&rpar;{ 				things.splice&lpar;Math.max&lpar;i, j&rpar;, 1&rpar;; 				things.splice&lpar;Math.min&lpar;i, j&rpar;, 1&rpar;; 				i-=2; 				j-=2;  			} 			if&lpar;things[i].name == 'leftborder' &amp;&amp; things[j].name == 'rightborder' &amp;&amp; things[i].x-cellsize2 == things[j].x &amp;&amp; things[i].y  == things[j].y&rpar;{ 				things.splice&lpar;Math.max&lpar;i, j&rpar;, 1&rpar;; 				things.splice&lpar;Math.min&lpar;i, j&rpar;, 1&rpar;; 				i-=2; 				j-=2;  			} 		} 	} 	fromState&lpar;getstate&lpar;&rpar;&rpar;; 	undostack.push&lpar;getstate&lpar;&rpar;&rpar;; };  controls = [         {key:'ArrowUp', f:&lpar;&rpar;=>{moveDir&lpar;dirs['u']&rpar;}},         {key:'ArrowLeft', f:&lpar;&rpar;=>{moveDir&lpar;dirs['l']&rpar;}},         {key:'ArrowDown', f:&lpar;&rpar;=>{moveDir&lpar;dirs['d']&rpar;}},         {key:'ArrowRight', f:&lpar;&rpar;=>{moveDir&lpar;dirs['r']&rpar;}}, ];  moveDir = &lpar;d&rpar; => { moveTimes&lpar;cellsize2 * d[0], cellsize2 * d[1], player&rpar;;};  onTarget = &lpar;thing&rpar; => {  	for&lpar;other of myall['target']&rpar;{ 		if&lpar;other.x - cellsize2/2 <= roundish&lpar;thing.x&rpar; &amp;&amp; 			other.x + cellsize2/2 >= roundish&lpar;thing.x&rpar;  &amp;&amp; 			other.y - cellsize2/2<= roundish&lpar;thing.y&rpar;  &amp;&amp; 			other.y + cellsize2/2 >= roundish&lpar;thing.y&rpar; &rpar;{ 			return true; 		} 	} 	return false; };  tmpcanvas = document.createElement&lpar;'canvas'&rpar;; tmpmyctx = tmpcanvas.getContext&lpar;'2d'&rpar;;  drawSquare = &lpar;x, y&rpar; => {tmpmyctx.fillRect&lpar;x, y, cellsize/5, cellsize/5&rpar;;};  drawSquareold = &lpar;x, y&rpar; => { myctx.fillRect&lpar;Math.round&lpar;vpad + x&rpar;, Math.round&lpar;hpad + y&rpar;, Math.round&lpar;vpad + x + cellsize/5&rpar; - Math.round&lpar;vpad + x&rpar;, Math.round&lpar;hpad + y + cellsize/5&rpar; - Math.round&lpar;hpad + y&rpar;&rpar;;}; wincounter = 0; drawthing = &lpar;thing&rpar; => { 	if&lpar;thing.angle == 0&rpar;{ 		drawthingold&lpar;thing&rpar;; 		return; 	}  	if&lpar;!thing.name.startsWith&lpar;'pusher'&rpar;&rpar;{ 		tmpmyctx.translate&lpar;cellsize/2, cellsize/2&rpar;; 		tmpmyctx.rotate&lpar;-thing.angle&rpar;; 		tmpmyctx.translate&lpar;-cellsize/2, -cellsize/2&rpar;; 		tmpmyctx.drawImage&lpar;canvas, Math.floor&lpar;vpad + thing.x+cellsize/2&rpar;-Math.floor&lpar;cellsize/2&rpar;-cellsize,Math.floor&lpar;hpad + thing.y+cellsize/2&rpar;-Math.floor&lpar;cellsize/2&rpar;-cellsize, cellsize*3, cellsize*3,-cellsize,-cellsize,cellsize*3,cellsize*3&rpar;; 		tmpmyctx.translate&lpar;cellsize/2, cellsize/2&rpar;; 		tmpmyctx.rotate&lpar;thing.angle&rpar;; 		tmpmyctx.translate&lpar;-cellsize/2, -cellsize/2&rpar;; 		for&lpar;var i=0; i<5; i++&rpar;{ 			for&lpar;var j=0; j<5; j++&rpar;{ 			tmpmyctx.fillStyle = cols[mysprites[thing.name][i + 6*j]]; 			if&lpar;mysprites[thing.name][i + 6*j] == '.'&rpar; continue; 			if&lpar;mysprites[thing.name][i + 6*j] == 'f'&rpar;{ 				xamt = cellsize/5; 				yamt = cellsize/5; 				if&lpar;onTarget&lpar;{x:thing.x/ratio + &lpar;&lpar;i-2&rpar;*Math.cos&lpar;thing.angle&rpar; - &lpar;j-2&rpar;*Math.sin&lpar;thing.angle&rpar;&rpar; * cellsize2/5, y:thing.y/ratio + &lpar;&lpar;i-2&rpar;*Math.sin&lpar;thing.angle&rpar; + &lpar;j-2&rpar;*Math.cos&lpar;thing.angle&rpar;&rpar; * cellsize2/5}&rpar;&rpar; { 					tmpmyctx.fillStyle = colscheme['activated']; 					wincounter++; 				} 			}  			drawSquare&lpar;cellsize/5 * i,  cellsize/5 * j &rpar;; 			} 		} 		myctx.translate&lpar;Math.floor&lpar;vpad + thing.x+cellsize/2&rpar;, Math.floor&lpar;hpad + thing.y+cellsize/2&rpar;&rpar;; 		myctx.rotate&lpar;thing.angle&rpar;; 		myctx.drawImage&lpar;tmpcanvas,0,0,cellsize,cellsize,-Math.floor&lpar;cellsize/2&rpar;,-Math.floor&lpar;cellsize/2&rpar;, cellsize, cellsize&rpar;; 		myctx.rotate&lpar;-thing.angle&rpar;; 		myctx.translate&lpar;-Math.floor&lpar;vpad + thing.x+cellsize/2&rpar;, -Math.floor&lpar;hpad + thing.y+cellsize/2&rpar;&rpar;; 		  	}else{ 		tmpmyctx.translate&lpar;cellsize/2, cellsize/2&rpar;; 		tmpmyctx.rotate&lpar;-thing.angle&rpar;; 		tmpmyctx.translate&lpar;-cellsize/2, -cellsize/2&rpar;; 		tmpmyctx.drawImage&lpar;canvas, Math.floor&lpar;vpad + thing.realx+cellsize/2&rpar;-Math.floor&lpar;cellsize/2&rpar;- 2*&lpar;thing.realx - thing.x&rpar;-cellsize,Math.floor&lpar;hpad + thing.realy+cellsize/2&rpar;-Math.floor&lpar;cellsize/2&rpar;- 2*&lpar;thing.realy - thing.y&rpar;-cellsize, cellsize*3, cellsize*3,-cellsize,-cellsize,cellsize*3,cellsize*3&rpar;; 		tmpmyctx.translate&lpar;cellsize/2, cellsize/2&rpar;; 		tmpmyctx.rotate&lpar;thing.angle&rpar;; 		tmpmyctx.translate&lpar;-cellsize/2, -cellsize/2&rpar;;  		tmpmyctx.fillStyle = activated?colscheme['activated']:colscheme['deactivated']; 		for&lpar;var i=0; i<5; i++&rpar;{ 			for&lpar;var j=0; j<5; j++&rpar;{ 				if&lpar;&lpar;thing.dirx == 0 &amp;&amp; i == 2&rpar; || &lpar;thing.diry == 0 &amp;&amp; j == 2&rpar; || &lpar;thing.dirx == 1 &amp;&amp; i>2&rpar; || &lpar;thing.dirx == -1 &amp;&amp; i<2&rpar; || &lpar;thing.diry == 1 &amp;&amp; j > 2&rpar; || &lpar;thing.diry == -1 &amp;&amp; j < 2&rpar;&rpar; 					drawSquare&lpar; cellsize/5 * i,  cellsize/5 * j&rpar;; 			} 		} 		 		myctx.translate&lpar;Math.floor&lpar;vpad + thing.realx  + cellsize/2&rpar;, Math.floor&lpar;hpad + thing.realy  + cellsize/2&rpar; &rpar;; 		myctx.rotate&lpar;thing.angle&rpar;; 		myctx.drawImage&lpar;tmpcanvas,0,0,cellsize,cellsize,-Math.floor&lpar;cellsize/2&rpar;- 2*&lpar;thing.realx - thing.x&rpar;,-Math.floor&lpar;cellsize/2&rpar;- 2*&lpar;thing.realy - thing.y&rpar;, cellsize, cellsize&rpar;; 		myctx.rotate&lpar;-thing.angle&rpar;; 		myctx.translate&lpar;-Math.floor&lpar;vpad + thing.realx + cellsize/2&rpar;, -Math.floor&lpar;hpad + thing.realy + cellsize/2&rpar; &rpar;; 		  		for&lpar;var i=0; i<5; i++&rpar;{ 			for&lpar;var j=0; j<5; j++&rpar;{ 			tmpmyctx.fillStyle = cols[mysprites[thing.name][i + 6*j]]; 			 			drawSquare&lpar;cellsize/5 * i,cellsize/5 * j&rpar;; 			} 		} 		myctx.translate&lpar;Math.floor&lpar;vpad + thing.realx+cellsize/2&rpar;, Math.floor&lpar;hpad + thing.realy+cellsize/2&rpar;&rpar;; 		myctx.rotate&lpar;thing.angle&rpar;; 		myctx.drawImage&lpar;tmpcanvas,0,0,cellsize,cellsize,-Math.floor&lpar;cellsize/2&rpar;,-Math.floor&lpar;cellsize/2&rpar;, cellsize, cellsize&rpar;; 		myctx.rotate&lpar;-thing.angle&rpar;; 		myctx.translate&lpar;-Math.floor&lpar;vpad + thing.realx+cellsize/2&rpar;, -Math.floor&lpar;hpad + thing.realy+cellsize/2&rpar;&rpar;; 	} 	 };   drawthingold = &lpar;thing&rpar; => {  	 	if&lpar;!thing.name.startsWith&lpar;'pusher'&rpar;&rpar;{  		for&lpar;var i=0; i<5; i++&rpar;{ 			for&lpar;var j=0; j<5; j++&rpar;{ 			 			if&lpar;mysprites[thing.name][i + 6*j] == '.'&rpar; continue; 			myctx.fillStyle = cols[mysprites[thing.name][i + 6*j]]; 			if&lpar;mysprites[thing.name][i + 6*j] == 'f'&rpar;{ 				if&lpar;onTarget&lpar;{x:thing.x/ratio - cellsize2/2 + cellsize2/10 + cellsize2/5 * i, y:thing.y/ratio - cellsize2/2 + cellsize2/10 + cellsize2/5*j}&rpar;&rpar; { 					myctx.fillStyle = colscheme['activated']; 					wincounter++; 				} 			}  			drawSquareold&lpar;thing.x + cellsize/5 * i,  thing.y + cellsize/5 * j &rpar;; 			} 		} 		  	}else{   		myctx.fillStyle = activated?colscheme['activated']:colscheme['deactivated']; 		for&lpar;var i=0; i<5; i++&rpar;{ 			for&lpar;var j=0; j<5; j++&rpar;{ 				if&lpar;&lpar;thing.dirx == 0 &amp;&amp; i == 2&rpar; || &lpar;thing.diry == 0 &amp;&amp; j == 2&rpar; || &lpar;thing.dirx == 1 &amp;&amp; i>2&rpar; || &lpar;thing.dirx == -1 &amp;&amp; i<2&rpar; || &lpar;thing.diry == 1 &amp;&amp; j > 2&rpar; || &lpar;thing.diry == -1 &amp;&amp; j < 2&rpar;&rpar; 					drawSquareold&lpar;thing.realx +  cellsize/5 * i - 2*&lpar;thing.realx - thing.x&rpar;, thing.realy + cellsize/5 * j - 2*&lpar;thing.realy - thing.y&rpar;&rpar;; 			} 		} 		 		  		for&lpar;var i=0; i<5; i++&rpar;{ 			for&lpar;var j=0; j<5; j++&rpar;{ 			if&lpar;mysprites[thing.name][i + 6*j] == '.'&rpar; continue;	 			myctx.fillStyle = cols[mysprites[thing.name][i + 6*j]]; 			 			drawSquareold&lpar;cellsize/5 * i+ thing.realx,cellsize/5 * j + thing.realy&rpar;; 			} 		} 		 	} 	 };    draw= &lpar;&rpar; => {  	wincounter = 0; 	cellsize = Math.floor&lpar;Math.min&lpar;canvas.height/&lpar;grid[mylevel].split&lpar;'|'&rpar;.length*5&rpar;, canvas.width/&lpar;grid[mylevel].split&lpar;'|'&rpar;[0].length*5&rpar;&rpar;&rpar;*5; 	vpad = Math.floor&lpar;&lpar;canvas.width - &lpar;cellsize  * grid[mylevel].split&lpar;'|'&rpar;[0].length&rpar;&rpar;/2&rpar;; 	hpad = Math.floor&lpar;&lpar;canvas.height - &lpar;cellsize  * grid[mylevel].split&lpar;'|'&rpar;.length&rpar;&rpar;/2&rpar;; 	myctx.fillStyle = '#C1FBC6'; 	myctx.fillRect&lpar;0, 0, canvas.width, canvas.height&rpar;; 	for&lpar;var i=0; i<grid[mylevel].split&lpar;'|'&rpar;[0].length; i++&rpar;{ 		for&lpar;var j=0; j<grid[mylevel].split&lpar;'|'&rpar;.length; j++&rpar;{ 			myctx.fillStyle = &lpar;&lpar;i+j&rpar;%2&rpar;?colscheme['verylight1']:colscheme['verylight2']; 			myctx.fillRect&lpar;i*cellsize+vpad, j*cellsize+hpad, cellsize, cellsize&rpar;; 		} 	} 	ratio = cellsize/cellsize2; 	for&lpar;thing of things&rpar;{ 		thing2 = clone&lpar;thing&rpar;; 		thing2.x *=ratio; 		thing2.y *=ratio; 		thing2.dx *=ratio; 		thing2.dy *=ratio; 		thing2.realx *=ratio; 		thing2.realy *=ratio; 		drawthing&lpar;thing2&rpar;; 	} 	winCheck&lpar;&rpar;; };   clockwise = &lpar;p, q, r&rpar; => { 	z = &lpar;q.x - p.x&rpar; * &lpar;r.y - p.y&rpar; - &lpar;q.y - p.y&rpar; * &lpar;r.x - p.x&rpar;;if&lpar;z > 0&rpar; return 1;if&lpar;z < 0&rpar; return -1;return 0; };   getCorners = &lpar;a&rpar; => { 	tox = a.dx/2*Math.cos&lpar;a.angle&rpar; - a.dy/2 * Math.sin&lpar;a.angle&rpar;; 	toy = a.dy/2*Math.cos&lpar;a.angle&rpar; + a.dx/2 * Math.sin&lpar;a.angle&rpar;; 	return [{x:a.x - tox, y: a.y - toy}, 	{x:a.x - toy, y: a.y + tox}, 	{x:a.x + tox, y: a.y + toy}, 	{x:a.x + toy, y: a.y - tox}]; };     rectsIntersect = &lpar;a, b&rpar; => { 	if&lpar;a.angle == 0 &amp;&amp; b.angle == 0&rpar;{ 		return roundish&lpar;Math.abs&lpar;a.x - b.x&rpar;&rpar;  < roundish&lpar;&lpar;a.dx + b.dx &rpar;/2&rpar; &amp;&amp; roundish&lpar;Math.abs&lpar;a.y - b.y&rpar;&rpar;  < roundish&lpar;&lpar;a.dy + b.dy &rpar;/2&rpar;; 	} 	if&lpar;&lpar;a.x - b.x&rpar;*&lpar;a.x - b.x&rpar; + &lpar;a.y - b.y&rpar;*&lpar;a.y - b.y&rpar; < a.dx * a.dx&rpar; return true; 	if&lpar;Math.abs&lpar;a.x - b.x&rpar; > a.dx + b.dx || Math.abs&lpar;a.y - b.y&rpar; > a.dy + b.dy&rpar; return false; 	acorns = getCorners&lpar;a&rpar;; 	bcorns = getCorners&lpar;b&rpar;; 	for&lpar;ac of acorns&rpar; if&lpar;clockwise&lpar;ac, bcorns[0], bcorns[1]&rpar; * clockwise&lpar;ac, bcorns[2], bcorns[3]&rpar; == 1 &amp;&amp; clockwise&lpar;ac, bcorns[1], bcorns[2]&rpar; * clockwise&lpar;ac, bcorns[3], bcorns[0]&rpar; == 1&rpar; return true; 	for&lpar;bc of bcorns&rpar; if&lpar;clockwise&lpar;bc, acorns[0], acorns[1]&rpar; * clockwise&lpar;bc, acorns[2], acorns[3]&rpar; == 1 &amp;&amp; clockwise&lpar;bc, acorns[1], acorns[2]&rpar; * clockwise&lpar;bc, acorns[3], acorns[0]&rpar; == 1&rpar; return true; 	return false; };   wouldCollide= &lpar;obj, thing&rpar; => { 	if&lpar;&lpar;obj.name.startsWith&lpar;'pusher'&rpar;&rpar; &amp;&amp; &lpar;obj.dx > cellsize2 || obj.dy > cellsize2&rpar;&rpar;{ 		return wouldCollide&lpar;{x: obj.realx, y:obj.realy, dx:cellsize2, dy:cellsize2, name:obj.name, angle:obj.angle}, thing&rpar; || 		wouldCollide&lpar;{x: obj.x * 2 - obj.realx, y: obj.y * 2 - obj.realy, dx:cellsize2, dy:cellsize2, name:'A' + obj.name, angle:obj.angle}, thing&rpar;; 	} 	if&lpar;&lpar;thing.name.startsWith&lpar;'pusher'&rpar;&rpar; &amp;&amp; &lpar;thing.dx > cellsize2 || thing.dy > cellsize2&rpar;&rpar;{ 		return wouldCollide&lpar;obj, {x: thing.realx, y:thing.realy, dx:cellsize2, dy:cellsize2, name:thing.name, angle:thing.angle}&rpar; ||  		wouldCollide&lpar;obj, {x: thing.x * 2 - thing.realx, y:thing.y * 2 - thing.realy, dx:cellsize2, dy:cellsize2, name:'A' + thing.name, angle:thing.angle}&rpar;; 	}    	if&lpar;!rectsIntersect&lpar;obj, thing&rpar;&rpar;{ 		return false; 	} 	 	if&lpar;&lpar;obj.angle == 0 &amp;&amp; thing.angle == 0&rpar; &amp;&amp; &lpar;roundish&lpar;Math.abs&lpar;thing.x - obj.x&rpar;&rpar; <= cellsize2/5 || roundish&lpar;Math.abs&lpar;thing.y - obj.y&rpar;&rpar; <= cellsize2/5&rpar; &amp;&amp; !obj.name.startsWith&lpar;'A'&rpar; &amp;&amp; !thing.name.startsWith&lpar;'A'&rpar;&rpar; return true;  	var tox = obj.dx/2*Math.cos&lpar;obj.angle&rpar; - obj.dy/2 * Math.sin&lpar;obj.angle&rpar;; 	var toy = obj.dy/2*Math.cos&lpar;obj.angle&rpar; + obj.dx/2 * Math.sin&lpar;obj.angle&rpar;; 	var tox2 = thing.dx/2*Math.cos&lpar;thing.angle&rpar; - thing.dy/2 * Math.sin&lpar;thing.angle&rpar;; 	var toy2 = thing.dy/2*Math.cos&lpar;thing.angle&rpar; + thing.dx/2 * Math.sin&lpar;thing.angle&rpar;;  	for&lpar;var i=0; i<5; i++&rpar;{ 		for&lpar;var j=0; j<5; j++&rpar;{ 			if&lpar;mysprites[obj.name][i + 6*j] == '.' &rpar; continue; 			if&lpar;!rectsIntersect&lpar;{x:&lpar;obj.x - tox&rpar; + &lpar;tox+toy&rpar;/5 * &lpar;i + 0.5&rpar; + &lpar;tox - toy&rpar;/5 * &lpar;j + 0.5&rpar;, y:obj.y - toy + &lpar;toy - tox&rpar;/5 * &lpar;i + 0.5&rpar; + &lpar;toy + tox&rpar;/5 * &lpar;j + 0.5&rpar;, dx:cellsize2/5, dy:cellsize2/5, angle:obj.angle}, thing&rpar;&rpar; continue; 			for&lpar;var i2=0; i2<5; i2++&rpar;{ 				for&lpar;var j2=0; j2<5; j2++&rpar;{ 					 					if&lpar;mysprites[thing.name][i2 + 6*j2] == '.' &rpar; continue; 					if&lpar;rectsIntersect&lpar;{x:&lpar;obj.x - tox&rpar; + &lpar;tox+toy&rpar;/5 * &lpar;i + 0.5&rpar; + &lpar;tox - toy&rpar;/5 * &lpar;j + 0.5&rpar;, y:obj.y - toy + &lpar;toy - tox&rpar;/5 * &lpar;i + 0.5&rpar; + &lpar;toy + tox&rpar;/5 * &lpar;j + 0.5&rpar;, dx:cellsize2/5, dy:cellsize2/5, angle:obj.angle},  									  {x:&lpar;thing.x - tox2&rpar; + &lpar;tox2+toy2&rpar;/5 * &lpar;i2 + 0.5&rpar; + &lpar;tox2 - toy2&rpar;/5 * &lpar;j2 + 0.5&rpar;, y:thing.y - toy2 + &lpar;toy2 - tox2&rpar;/5 * &lpar;i2 + 0.5&rpar; + &lpar;toy2 + tox2&rpar;/5 * &lpar;j2 + 0.5&rpar;, dx:cellsize2/5, dy:cellsize2/5, angle:thing.angle}&rpar;&rpar; { 						return true; 					} 				} 			} 		} 	} 	return false; };   roundish = &lpar;a&rpar; => {return Math.floor&lpar;&lpar;a + 0.0000001&rpar; * 10000&rpar;/10000;};  powerpower = 10; pushcontents = [];   move = &lpar;dx, dy, obj, power=10, ang = 0, expandx=0, expandy=0, shrinkx=0, shrinky=0&rpar; => { 	if&lpar;pushcontents.length == 0&rpar; sh = &lpar;shrinkx == 0 &amp;&amp; shrinky == 0&rpar;; 	pushcontents.push&lpar;obj&rpar;; 	powerpower = power; 	var obj2 = clone&lpar;obj&rpar;; 	 	pushx = dx; 	pushy = dy; 	if&lpar;expandx != 0 || expandy != 0&rpar;{ 		obj2.dx += Math.abs&lpar;expandx&rpar;; 		obj2.dy += Math.abs&lpar;expandy&rpar;; 		obj2.realx += dx; 		obj2.realy += dy; 		obj2.x += dx + expandx/2; 		obj2.y += dy + expandy/2; 		pushx = 2*dx + expandx; 		pushy = 2*dy + expandy; 	} 	else if&lpar;shrinkx != 0 || shrinky != 0&rpar;{ 		obj2.dx += -Math.abs&lpar;shrinkx&rpar;; 		obj2.dy += -Math.abs&lpar;shrinky&rpar;; 		obj2.realx += dx; 		obj2.realy += dy; 		obj2.x += dx - shrinkx/2; 		obj2.y += dy - shrinky/2; 		pushx = 2*dx - shrinkx; 		pushy = 2*dy - shrinky; 	} 	else if&lpar;ang == 0&rpar;{ 		obj2.x += dx; 		obj2.y += dy; 		obj2.realx += dx; 		obj2.realy += dy;  	}else{ 		if&lpar;obj.name.startsWith&lpar;'pusher'&rpar;&rpar; { 			pushcontents.pop&lpar;&rpar;; 			return false; 		} 		obj2.x += dx; 		obj2.y += dy; 		obj2.realx += dx; 		obj2.realy += dy; 		obj2.angle += ang; 	} 	obj2.x = roundish&lpar;obj2.x&rpar;; 	obj2.y = roundish&lpar;obj2.y&rpar;; 	obj2.dx = roundish&lpar;obj2.dx&rpar;; 	obj2.dy = roundish&lpar;obj2.dy&rpar;; 	obj2.realx = roundish&lpar;obj2.realx&rpar;; 	obj2.realy = roundish&lpar;obj2.realy&rpar;; 	for&lpar;var thing of things&rpar;{ 		if&lpar;thing.name == 'wmyall' &amp;&amp; Math.abs&lpar;thing.x - obj2.x&rpar; < cellsize2 * 2 &amp;&amp; Math.abs&lpar;thing.y - obj2.y&rpar; < cellsize2 * 2&rpar;{	 			if&lpar;wouldCollide&lpar;obj2, thing&rpar;&rpar;{ 				pushcontents.pop&lpar;&rpar;; 				return false; 			} 		} 		if&lpar;&lpar;thing.name == 'box' || thing.name.startsWith&lpar;'pusher'&rpar; || thing.name == 'player'&rpar; &amp;&amp; Math.abs&lpar;thing.x - obj2.x&rpar; < 3*cellsize2 &amp;&amp; Math.abs&lpar;thing.y - obj2.y&rpar; < 3*cellsize2&rpar;{ 			if&lpar;thing == obj&rpar; continue; 			if&lpar;!wouldCollide&lpar;obj2, thing&rpar;&rpar;{ 				continue; 			} 			if&lpar; pushcontents.includes&lpar;thing&rpar; &amp;&amp; ang == 0&rpar;{ 				if &lpar;sh &rpar; continue; 				else{ 					pushcontents.pop&lpar;&rpar;; 					return false; 				} 			} 			if&lpar;power == 0&rpar; { 				pushcontents.pop&lpar;&rpar;; 				return false; 			}  			if&lpar;!move&lpar;pushx, pushy, thing, power-1&rpar;&rpar; { 				if&lpar;thing.x == obj.x || thing.y == obj.y&rpar; { 					pushcontents.pop&lpar;&rpar;; 					return false; 				} 				if&lpar;thing.name.startsWith&lpar;'pusher'&rpar;&rpar;{ 					pushcontents.pop&lpar;&rpar;; 					return false; 				} 				var ok = false; 				if&lpar;mylevel >= 9&rpar;{ 					obj3 = clone&lpar;obj&rpar;; 					obj.x = obj2.x; 					obj.y = obj2.y; 					obj.dx = obj2.dx; 					obj.dy = obj2.dy; 					obj.realx = obj2.realx; 					obj.realy = obj2.realy; 					obj.angle = obj2.angle; 						for&lpar;var i=1; i<=15; i++&rpar;{ 							if&lpar;move&lpar;pushx, pushy, thing, 0, i * Math.PI / 600&rpar;&rpar;{ 								ok = true; 								break; 							} 						} 						for&lpar;var i=-1; i>=-15; i--&rpar;{ 							if&lpar;move&lpar;pushx, pushy, thing, 0, i * Math.PI / 600&rpar;&rpar;{ 								ok = true; 								break; 							} 						}  				} 				if&lpar;!ok&rpar;{ 					if&lpar;mylevel >= 9&rpar;{ 						obj.x = obj3.x; 						obj.y = obj3.y; 						obj.dx = obj3.dx; 						obj.dy = obj3.dy; 						obj.realx = obj3.realx; 						obj.realy = obj3.realy; 						obj.angle = obj3.angle; 					} 					pushcontents.pop&lpar;&rpar;; 					return false; 				} 				 			} 		} 	} 	 	obj.x = obj2.x; 	obj.y = obj2.y; 	obj.dx = obj2.dx; 	obj.dy = obj2.dy; 	obj.realx = obj2.realx; 	obj.realy = obj2.realy; 	obj.angle = obj2.angle; 	if&lpar;Math.round&lpar;obj.angle/ &lpar;Math.PI/2&rpar;&rpar; == obj.angle/ &lpar;Math.PI/2&rpar;&rpar; obj.angle = 0; 	obj.done = false; 	pushcontents.pop&lpar;&rpar;; 	return true; };  activated = false;  activatePushers = &lpar;state&rpar; => { 	activated = state; 	cols['h'] = activated?colscheme['activated']:colscheme['deactivated']; 	cols['i'] = activated?colscheme['activated']:colscheme['deactivated']; 	if&lpar;state&rpar; return expandTimes&lpar;&rpar;; 	else return shrinkTimes&lpar;&rpar;; };  anim = 200;   buttonCheck = &lpar;&rpar; => { 	anyDid = false; 	for&lpar;button of myall['button']&rpar;{ 		for&lpar;thing of things&rpar;{ 			if&lpar;!&lpar;thing.name == 'box' || thing.name == 'player' || thing.name.startsWith&lpar;'pusher'&rpar;&rpar;&rpar; continue; 			if&lpar;thing.name.startsWith&lpar;'pusher'&rpar;&rpar;{ 				if&lpar;Math.abs&lpar;button.x - thing.realx&rpar; <= cellsize2/2 &amp;&amp; Math.abs&lpar;button.y - thing.realy&rpar; <= cellsize2/2&rpar;{ 					anyDid = true; 				} 			} 			else if&lpar;Math.abs&lpar;button.x - thing.x&rpar; <= cellsize2/2 &amp;&amp; Math.abs&lpar;button.y - thing.y&rpar; <= cellsize2/2&rpar;{ 				anyDid = true; 			} 		} 	} 	againing = true; 	if&lpar;activatePushers&lpar;anyDid&rpar;&rpar; {  		setTimeout&lpar;buttonCheck, anim&rpar;; 	} 	else { 		againing = false; 		undostack.push&lpar;getstate&lpar;&rpar;&rpar;; 		winCheck&lpar;&rpar;; 		for&lpar;thing of things&rpar;{ 			if&lpar;Math.abs&lpar;Math.round&lpar;&lpar;thing.angle&rpar;/&lpar;Math.PI/2&rpar;&rpar; * &lpar;Math.PI/2&rpar; - thing.angle&rpar;< Math.PI/199&rpar;{ 				if&lpar;Math.round&lpar;&lpar;thing.angle&rpar;/&lpar;Math.PI/2&rpar;&rpar; * &lpar;Math.PI/2&rpar; == thing.angle &amp;&amp; 				Math.round&lpar;thing.x / &lpar;cellsize2/20&rpar;&rpar; * &lpar;cellsize2/20&rpar; == thing.x &amp;&amp; 				Math.round&lpar;thing.y / &lpar;cellsize2/20&rpar;&rpar; * &lpar;cellsize2/20&rpar; == thing.y&rpar; continue; 				move&lpar;Math.round&lpar;thing.x / &lpar;cellsize2/20&rpar;&rpar; * &lpar;cellsize2/20&rpar;-thing.x, Math.round&lpar;thing.y / &lpar;cellsize2/20&rpar;&rpar; * &lpar;cellsize2/20&rpar;-thing.y, thing, 0, Math.round&lpar;&lpar;thing.angle&rpar;/&lpar;Math.PI/2&rpar;&rpar; * &lpar;Math.PI/2&rpar; - thing.angle&rpar;; 			} 		}   	} 	 };  mywinning = false;   winCheck = &lpar;&rpar; => { 	if&lpar;mywinning || wincounter < 5&rpar; return; 	mywinning = true; 	win&lpar;&rpar;; };   win = &lpar;&rpar; => {  	againing = true;  	setTimeout&lpar;&lpar;&rpar;=>{  		againing = false; 		mylevel++; 		playSound&lpar;90748503&rpar;; 		if &lpar;!!window.localStorage&rpar; { 			localStorage[document.URL]=mylevel; 		} 		mywinning = false; 		undostack = []; 		if&lpar;mylevel == 12&rpar;{ 			 			curlevel=0; 			curlevelTarget=null; 			titleScreen = true; 			titleSelected = false; 			curlevel=0; 			localStorage.removeItem&lpar;document.URL&rpar;; 			textMode=true; 			quittingMessageScreen = false; 			goToTitleScreen&lpar;&rpar;; 			titleImage = ['                                  ',  			'            Pushing It            ',  			'                                  ',  			'                     by Jack Lance',  			'                                  ',  			'                                  ',  			'         # start game #           ',  			'                                  ',  			'                                  ',  			' arrow keys to move               ',  			' X to action                      ',  			' Z to undo, R to restart          ',  			'                                  ']; 			redraw&lpar;&rpar;; 			canvasResize&lpar;&rpar;; 		}else{ 			loadmylevel&lpar;&rpar;; 			draw&lpar;&rpar;; 		} 	}, 400&rpar;; };   expand = &lpar;dx, dy, obj&rpar; => { 	if&lpar;Math.abs&lpar;dx&rpar; + obj.dx > cellsize2 * 2 || Math.abs&lpar;dy&rpar; + obj.dy > cellsize2 * 2&rpar; { 		obj.done = true; 		return false; 	} 	if&lpar;move&lpar;0, 0, obj, 10, 0, dx, dy&rpar;&rpar;{ 		return true; 	}else if&lpar;move&lpar;-dx, -dy, obj, 10, 0, dx, dy&rpar;&rpar;{ 		return true; 	}else{ 		obj.done = true; 		return false; 	} };   shrink = &lpar;dx, dy, obj&rpar; => {  		if&lpar;obj.dx == cellsize2 &amp;&amp; obj.dy == cellsize2&rpar; return false; 		if&lpar;dx != 0&rpar; dx = dx/Math.abs&lpar;dx&rpar; * Math.max&lpar;0, Math.min&lpar;Math.abs&lpar;dx&rpar;, obj.dx - cellsize2&rpar;&rpar;; 		if&lpar;dy != 0&rpar; dy = dy/Math.abs&lpar;dy&rpar; * Math.max&lpar;0, Math.min&lpar;Math.abs&lpar;dy&rpar;, obj.dy - cellsize2&rpar;&rpar;;  		if&lpar;move&lpar;0, 0, obj, 10, 0, 0, 0, dx, dy&rpar;&rpar;{ 			return true; 		}else if &lpar;move&lpar;dx, dy, obj, 10, 0, 0, 0, dx, dy&rpar;&rpar;{ 			return true; 		}else{ 			obj.done = true; 			return false; 		}  };   expandTimes = &lpar;t = 100&rpar;=> { 	for&lpar;pusher of myall['pusher']&rpar;{ 		pusher.done = false; 	} 	var returnval = false; 	for&lpar;var j=0; j<t/5; j++&rpar;{ 		if&lpar;mylevel != 8 || j%2 == 0&rpar; { 			for&lpar;pusher of myall['pusher']&rpar;{ 				var b = expand&lpar;cellsize2 * pusher.dirx/t, cellsize2*pusher.diry/t, pusher&rpar;; 				returnval = returnval || b; 			}	 		}	else{ 			for&lpar;pusher of myall['pusher'].reverse&lpar;&rpar;&rpar;{ 				var b = expand&lpar;cellsize2 * pusher.dirx/t, cellsize2*pusher.diry/t, pusher&rpar;; 				returnval = returnval || b; 			}	 		}	 	}	 	if&lpar;!returnval&rpar; return false; 	draw&lpar;&rpar;;	 	playSound&lpar;71682106&rpar;; 	 	for&lpar;var i=1; i<5; i++&rpar;{ 		setTimeout&lpar;&lpar;&rpar;=>{playSound&lpar;71682106&rpar;;}, i*anim/5&rpar;; 		setTimeout&lpar;&lpar;&rpar;=>{ 			for&lpar;var j=0; j<t/5; j++&rpar;{ 				for&lpar;pusher of myall['pusher']&rpar;{ 					if&lpar;pusher.done&rpar; continue; 					expand&lpar;cellsize2 * pusher.dirx/t, cellsize2*pusher.diry/t, pusher&rpar;; 				} 				 			}	 			draw&lpar;&rpar;;	 			 		}, i*anim/5&rpar;;	 	} 	setTimeout&lpar;draw, anim&rpar;; 	return true; };   shrinkTimes = &lpar;t = 100&rpar; => { 	for&lpar;pusher of myall['pusher']&rpar;{ 		pusher.done = false; 	} 	var returnval = false; 	for&lpar;var j=0; j<t/5; j++&rpar;{ 					 				for&lpar;pusher of myall['pusher']&rpar;{ 					if&lpar;pusher.done&rpar; continue; 					var b =  shrink&lpar;cellsize2 * pusher.dirx/t, cellsize2*pusher.diry/t, pusher&rpar;; 					returnval = returnval || b; 				} 			}	 			if&lpar;!returnval&rpar; return false; 			draw&lpar;&rpar;;	 			playSound&lpar;46796706&rpar;;  	for&lpar;var i=1; i<5; i++&rpar;{ 		setTimeout&lpar;&lpar;&rpar;=>{playSound&lpar;46796706&rpar;;}, i*anim/5&rpar;; 		setTimeout&lpar;&lpar;&rpar;=>{ 			for&lpar;var j=0; j<t/5; j++&rpar;{ 					 				for&lpar;pusher of myall['pusher']&rpar;{ 					if&lpar;pusher.done&rpar; continue; 					shrink&lpar;cellsize2 * pusher.dirx/t, cellsize2*pusher.diry/t, pusher&rpar;; 				} 			}	 			draw&lpar;&rpar;;	 		}, i*anim/5&rpar;;	 	} 	setTimeout&lpar;draw, anim&rpar;; 	return true; };    moveTimes = &lpar;dx, dy, obj, t = 100&rpar; => { 	newdx = dx * Math.cos&lpar;obj.angle&rpar; - dy * Math.sin&lpar;obj.angle&rpar;; 	newdy = dy * Math.cos&lpar;obj.angle&rpar; + dx * Math.sin&lpar;obj.angle&rpar;; 	dx = newdx; 	dy = newdy; 	for&lpar;var i = 0; i<t; i++&rpar;{ 		if&lpar;i/&lpar;t/5&rpar; == Math.floor&lpar;i/&lpar;t/5&rpar;&rpar;&rpar; sstate = getstate&lpar;&rpar;; 		b1 = move&lpar;dx/t, 0, obj, 1&rpar;; 		b2 =  move&lpar;0, dy/t, obj, 1&rpar;; 		if&lpar;&lpar;dy == 0 &amp;&amp; !b1&rpar; || &lpar;dx == 0 &amp;&amp; !b2&rpar;&rpar; { 			if&lpar;i/&lpar;t/5&rpar; == Math.floor&lpar;i/&lpar;t/5&rpar;&rpar;&rpar; fromState&lpar;sstate&rpar;; 			break; 		}; 	} 		 	buttonCheck&lpar;&rpar;; 	draw&lpar;&rpar;;    };    playersprites = ['.aaa.|ababa|aaaaa|aaaaa|.aaa.', '.aaa.|aaaaa|babaa|aaaaa|.aaa.', '.aaa.|aaaaa|aaaaa|ababa|.aaa.','.aaa.|aaaaa|aabab|aaaaa|.aaa.'];  	DoRestart = &lpar;&rpar; => { 		if&lpar;againing&rpar; return; 		loadmylevel&lpar;&rpar;;  		draw&lpar;&rpar;; 	}; 	DoUndo = &lpar;&rpar; => {	 		if&lpar;!againing&rpar; undo&lpar;&rpar;; 		againing = false; 		draw&lpar;&rpar;; 	}; 	processInput = &lpar;dir&rpar;=>{ 		ULBS&lpar;&rpar;; 		 		if&lpar;dir >= 0 &amp;&amp; dir <= 3&rpar; { 			againing = true; 			mysprites['player'] = playersprites[dir]; 			controls[dir].f&lpar;&rpar;; 		} 		draw&lpar;&rpar;; 	}; 	nextLevel=&lpar;&rpar;=>{ 		titleScreen = false; 		titleSelected = false; 		undostack = []; 		textMode=false; 		mylevel = 0; 		if &lpar;!!window.localStorage&rpar; { 			if&lpar;titleSelection == 1 &amp;&amp; localStorage[document.URL] != undefined&rpar; mylevel = localStorage[document.URL]; 			localStorage[document.URL]=mylevel; 		} 		loadmylevel&lpar;&rpar;; 		draw&lpar;&rpar;; 	}; 	update = &lpar;&rpar;=>{ 		timer+=deltatime; 	    input_throttle_timer+=deltatime; 	    if &lpar;quittingTitleScreen&rpar; { 	        if &lpar;timer/1000>0.3&rpar; { 	            quittingTitleScreen=false; 	            nextLevel&lpar;&rpar;; 	        } 	    } 	    if &lpar;againing&rpar; {         if &lpar;timer>againinterval&amp;&amp;messagetext.length==0&rpar; {             if &lpar;processInput&lpar;-1&rpar;&rpar; {                 redraw&lpar;&rpar;;                 keyRepeatTimer=0;                 autotick=0;             }         }     } 	    if &lpar;quittingMessageScreen&rpar; {         if &lpar;timer/1000>0.15&rpar; {             quittingMessageScreen=false;             if &lpar;messagetext===''&rpar; {             	nextLevel&lpar;&rpar;;             } else {             	messagetext='';             	textMode=false; 				titleScreen=false; 				titleMode=&lpar;curlevel>0||curlevelTarget!==null&rpar;?1:0; 				titleSelected=false; 				titleSelection=0;     			canvasResize&lpar;&rpar;;       			checkWin&lpar;&rpar;;          	             }         }     }     if &lpar;keybuffer.length>0&rpar; { 	    keyRepeatTimer+=deltatime; 	    var ticklength = throttle_movement ? repeatinterval : repeatinterval/&lpar;Math.sqrt&lpar;keybuffer.length&rpar;&rpar;; 	    if &lpar;keyRepeatTimer>ticklength&rpar; { 	    	keyRepeatTimer=0;	 	    	keyRepeatIndex = &lpar;keyRepeatIndex+1&rpar;%keybuffer.length; 	    	var key = keybuffer[keyRepeatIndex]; 	        checkKey&lpar;{keyCode:key},false&rpar;; 	    } 	} 	}; 	redraw = &lpar;&rpar;=>{ 		if &lpar;textMode&rpar; { 	        ctx.fillStyle = state.bgcolor; 	        ctx.fillRect&lpar;0, 0, canvas.width, canvas.height&rpar;;  	        for &lpar;var i = 0; i < titleWidth; i++&rpar; { 	            for &lpar;var j = 0; j < titleHeight; j++&rpar; { 	                var ch = titleImage[j].charAt&lpar;i&rpar;; 	                if &lpar;ch in textImages&rpar; { 	                    var sprite = textImages[ch]; 	                    ctx.drawImage&lpar;sprite, xoffset + i * cellwidth, yoffset + j * cellheight&rpar;;                    	                } 	            } 	        } 	        return; 	    }else{ 	    	draw&lpar;&rpar;; 	    } 	};   if&lpar;!titleScreen&rpar;{ 	messagetext = 'POWER: ON'; 	drawMessageScreen&lpar;&rpar;; 	drawMessageScreenOld = drawMessageScreen; 	drawMessageScreen = &lpar;&rpar;=>{drawMessageScreenOld&lpar;&rpar;; nextLevel&lpar;&rpar;;}; }    document.getElementById&lpar;'homepagelink'&rpar;.href = '//www.puzzlescript.net'; document.getElementById&lpar;'homepagelink'&rpar;.innerHTML = 'www.puzzlescript.net'; document.getElementById&lpar;'hacklink'&rpar;.href='editor.html?hack=76ce230398172e7b0cbb8719b8c4f302';  `;document.body.appendChild&lpar;a&rpar;; ">


========
OBJECTS
========
background
orange


Background1
#CCCCCC

Background2
#C1FBC6

PusherR
#A20021 #555555
..000
00010
01110
00010
..000

Pusherl
#A20021 #555555
000..
01000
01110
01000
000..

Pusherd
#A20021 #555555
.000.
.010.
00100
01110
00000


Target
#668866
00.00
0...0
.....
0...0
00.00

Button
#668866 #A20021
.....
.000.
.010.
.000.
.....

Wall
#153A29 #222222
00011
00110
01100
11000
10001

wallu
#01130A
00000
.....
.....
.....
.....

walld
#01130A
.....
.....
.....
.....
00000

wallr
#01130A
....0
....0
....0
....0
....0


walll
#01130A
0....
0....
0....
0....
0....

Player
#555555 #A20021
.000.
00000
01010
00000
.000.

box
#555555 #A20021
10.01
00100
.111.
00100
10.01


=======
LEGEND
=======

. = Background
x = Wall
p = Player
d = pusherd
r = PusherR
l = pusherl
b = button
o = box
t = target
y = Wall and background1

=======
SOUNDS
=======
SFX1 54822305

================
COLLISIONLAYERS
================

Background
background1, background2
wall
walll
wallr
walld
wallu
Target, button
Player, pusherl, pusherr, pusherd, box

======
RULES
======

[wall] -> [wall wallu walld wallr walll]
up [wallu | walld] -> [|]
right [wallr | walll] -> [|]
[background1 | ] -> [background1 | background2]
+[background2 | ] -> [background2 | background1]
[moving player] -> [stationary player]
[> player | pusherd ] -> [ | player] SFX1
==============
WINCONDITIONS
==============


=======
LEVELS
=======


yxxxxxxxxxx
xpx...d...x
x.x..xbb.xx
x.xx.x.x..x
x..x.x.xxox
xxbx.b.xxbx
x..xr.xxx.x
x.xxxbxxx.x
rb....xxt.l
xxxxxxxxxxx
