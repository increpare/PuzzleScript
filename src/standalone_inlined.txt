<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="description" content="__GAMETITLE__">
<title>__GAMETITLE__</title>
<style>

body {
	background-color:___BGCOLOR___;
	font-family:"Courier New", Courier, monospace;
    touch-action: none;
}
#gameCanvas {
  position:absolute;
  top: 0px;
  left: 0px;
  width: 100%;
  height: 100%;
  bottom: 0px;
  right:0px;
  border: 0px;
  background-color: ___BGCOLOR___; 
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  image-rendering: -moz-crisp-edges;
  image-rendering: -webkit-crisp-edges;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
} 

.homepagelink {
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 50%;
}

h1 {
	color:___TEXTCOLOR___;
	font-weight:normal;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    height:2em;
    margin-top:0.5em;
    margin-bottom: 0.5em;
}
a {
	color:___TEXTCOLOR___;
}
.title {	
	background-color:none;
	text-align:center;
	font-size:100%;
	float:center;
	color:gray;
	position:absolute;
	left:10%;
	right:10%;
	top:0%;
	height:3em;
}

.footer {	
	background-color:none;
	text-align:center;
	float:center;
	color:white;
	position:absolute;
	left:0%;
	right:0%;
	height:3em;
	bottom:0;
}
.gameContainer {
	background-color:none;
	position:absolute;
	left:0%;
	right:0%;
	top:3.5em;
	bottom:3em;
  touch-action: none;
}

  .mobile-menu {
      position: relative;
      top: 5em;
      left:0.7em;
      margin-left: auto;
      margin-right: auto;
      font-weight: bold;
      border-radius: 0.25em;
  }

  .mobile-menu.item-count-3 {
      width: 30em;
  }
  .mobile-menu.item-count-3 .button {
      width: 28.3333%;
      /* scale the height of the button relative to the width of .mobile-menu */
      padding: 7.5% 0%;
  }

  .mobile-menu.item-count-2 {
      width: 20em;
  }
  .mobile-menu.item-count-2 .button {
      width: 46%;
      /* scale the height of the button relative to the width of .mobile-menu */
      padding: 12.1765% 0%;
  }

  .mobile-menu.item-count-1 {
      width: 10em;
  }
  .mobile-menu.item-count-1 .button {
      width: 98%;
      /* scale the height of the button relative to the width of .mobile-menu */
      padding: 26.5% 0%;
  }

  .mobile-menu,
  .tab-icon,
  .mobile-menu .close {
      background: rgba(0,0,0,0.4);
      border: 2px solid rgba(255, 255, 255, 0.4);
      color: rgba(255, 255, 255, 1);
  }

  .mobile-menu .button {
      margin: 2%;
      border-radius: 0.25em;
      text-align: center;
      float: left;
  }
  .mobile-menu .clear {
      clear: both;
  }

  .tab-affordance,
  .close-affordance {
      width: 6em;
      height: 6em;
      position: absolute;
      z-index: 1000;
  }

  .tab-affordance {
      left: -2em;
      top: 5em;
  }

  .close-affordance {
      left: -4em;
      top: -1em;
  }

  .tab-icon,
  .mobile-menu .close {
      height: 48px;
      position: absolute;
      border-radius: 6px;
  }

  .tab-icon {
    left: 0;
      top: 70px;
      width: 18px;
      border-radius: 0 6px 6px 0;
      border-left: 0;
  }

  .mobile-menu .close {
      left: -18px;
      width: 18px;
      top: 0px;
      border-radius: 6px 0 0 6px;
      border-right: 0;
  }

  .tab-icon .slice,
  .mobile-menu .close .slice {
      margin: 4.5px 1px;
      width: 2px;
      height: 80%;
      background: rgba(255, 255, 255, 0.4);
  }

  .tab-icon .slice {
      float: right;
  }

  .tab-icon .slice:first-child {
       margin-right: 4.5px;
  }

  .mobile-menu .close .slice {
      float: left;
  }
  .mobile-menu .close .slice:first-child {
       margin-left: 4.5px;
  }

  @media screen and (max-width: 32em) {
      .mobile-menu {
          font-size: 0.8em;
          width: 90%;
      }
  }
  @media screen and (max-width: 24em) {
      .mobile-menu {
          font-size: 0.65em;
          width: 90%;
      }
  }

 .disable-select {
     -webkit-touch-callout: none;
     -webkit-user-select: none;
     -khtml-user-select: none;
     -moz-user-select: none;
     -ms-user-select: none;
     user-select: none;
 }

a {
    display:inline-block;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 80%;
}
</style>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
</head>
<body>
<div class="title"><h1 id="gametitle">__GAMETITLE__</h1></div>
<div class="gameContainer">
<canvas 
    id="gameCanvas" ></canvas>
</div> 
<div class="footer">
<span id="errormessage" style="color:red;"></span>
<a id="homepagelink" href="__HOMEPAGE__" target="_blank">__HOMEPAGE_STRIPPED_PROTOCOL__</a>
</div>

<!--___SCRIPTINSERT___-->
<script>
'use strict';

function storage_has(key) {
    return localStorage.getItem(key) !== null;
}

function storage_get(key) {
    return localStorage.getItem(key);
}

function storage_set(key, value) {
    return localStorage.setItem(key, value);
}

function storage_remove(key) {
    localStorage.removeItem(key);
}
</script>
<script>
'use strict';

function BitVec(init) {
	this.data = new Int32Array(init);
}

BitVec.prototype.cloneInto = function(target) {
	for (let i=0;i<this.data.length;++i) {
		target.data[i]=this.data[i];
	}
	return target;
}
BitVec.prototype.clone = function() {
	return new BitVec(this.data);
}

BitVec.prototype.iand = function(other) {
	for (let i = 0; i < this.data.length; ++i) {
		this.data[i] &= other.data[i];
	}
}


BitVec.prototype.inot = function() {
	for (let i = 0; i < this.data.length; ++i) {
		this.data[i] = ~this.data[i];
	}
}

BitVec.prototype.ior = function(other) {
	for (let i = 0; i < this.data.length; ++i) {
		this.data[i] |= other.data[i];
	}
}

BitVec.prototype.iclear = function(other) {
	for (let i = 0; i < this.data.length; ++i) {
		this.data[i] &= ~other.data[i];
	}
}

BitVec.prototype.ibitset = function(ind) {
	this.data[ind>>5] |= 1 << (ind & 31);
}



function IBITSET(tok, index) {
	return `${tok}.data[${index}>>5] |= 1 << (${index} & 31);`;
}


BitVec.prototype.ibitclear = function(ind) {
	this.data[ind>>5] &= ~(1 << (ind & 31));
}

BitVec.prototype.get = function(ind) {
	return (this.data[ind>>5] & 1 << (ind & 31)) !== 0;
}

function GET(tok, index) {
    const shift_5 = index >> 5;
    const bit_position = 1 << (index & 31);
    return `((${tok}.data[${shift_5}] & ${bit_position}) !== 0)`;
}


BitVec.prototype.getshiftor = function(mask, shift) {
	const toshift = shift & 31;
	let ret = this.data[shift>>5] >>> (toshift);
	if (toshift) {
		ret |= this.data[(shift>>5)+1] << (32 - toshift);
	}
	return ret & mask;
}

function GETSHIFTOR(tok, mask, shift) {
    const toshift = shift&31;
    const shift_5 = shift>>5;
    if (toshift) {
        return `${mask}&((${tok}.data[${shift_5}] >>> ${toshift}) | (${tok}.data[${shift_5}+1] << (32-${toshift})))`;
    } else {
        return `${mask}&(${tok}.data[${shift_5}] >>> ${toshift})`;
    }
}

BitVec.prototype.ishiftor = function(mask, shift) {
	const toshift = shift&31;
	const shift_5 = shift>>5;
	let low = mask << toshift;
	this.data[shift_5] |= low;
	if (toshift) {
		let high = mask >> (32 - toshift);
		this.data[shift_5+1] |= high;
	}
}

function ISHIFTOR(tok, mask, shift) {
	return `{
		let toshift = ${shift}&31;
		let low = ${mask} << toshift;
		${tok}.data[${shift}>>5] |= low;
		if (toshift) {
			let high = ${mask} >> (32 - toshift);
			${tok}.data[(${shift}>>5)+1] |= high;
		}
	}`;
}


BitVec.prototype.ishiftclear = function(mask, shift) {
	const toshift = shift & 31;
	const shift_5 = shift>>5;
	const low = mask << toshift;
	this.data[shift_5] &= ~low;
	if (toshift){
		let high = mask >> (32 - (shift & 31));
		this.data[shift_5+1] &= ~high;
	}
}


function ISHIFTCLEAR(tok, mask, shift) {
	const toshift = shift&31;
	const shift_5 = shift>>5;
	const low = mask +"<<"+toshift;
	let result = `${tok}.data[${shift_5}] &= ~(${low});\n`
	if (toshift) {
		const high = mask +">>>"+(32-toshift);
		result += `${tok}.data[${shift_5+1}] &= ~(${high});\n`;
	}
	return result;
}

BitVec.prototype.equals = function(other) {
	if (this.data.length !== other.data.length)
		return false;
	for (let i = 0; i < this.data.length; ++i) {
		if (this.data[i] !== other.data[i])
			return false;
	}
	return true;
}


function EQUALS(tok, other, array_size) {
	let result = "(true";
	for (let i = 0; i < array_size; i++) {
		result += `&&(${tok}.data[${i}] === ${other}.data[${i}])`;
	}
	return result + ")";
}

function EQUALS_TOK_REAL(tok, other) {
	let result = "(true";
	for (let i = 0; i < other.data.length; i++) {
		result += `&&(${tok}.data[o] === ${other.data[i]})`;
	}
	return result + ")";
}

function NOT_EQUALS(tok, other, array_size) {
	let result = "(false";
	for (let i = 0; i < array_size; i++) {
		result += `||(${tok}.data[${i}] !== ${other}.data[${i}])`;
	}
	return result + ")";
}


BitVec.prototype.setZero = function() {
	this.data.fill(0);
}

function ARRAY_SET_ZERO(tok) {
	return tok+".fill(0);\n";
}

function SET_ZERO(tok) {
	return tok+".data.fill(0);\n";
}

BitVec.prototype.iszero = function() {
	for (let i = 0; i < this.data.length; ++i) {
		if (this.data[i]!==0)
			return false;
	}
	return true;
}

function IS_ZERO(tok, array_size) {
	let result = "(true";
	for (let i = 0; i < array_size; i++) {
		result += `&&(${tok}.data[${i}]===0)`;
	}
	return result + ")";
}

function IS_NONZERO(tok, array_size) {
	let result = "(false";
	for (let i = 0; i < array_size; i++) {
		result += `||(${tok}.data[${i}]!==0)`;
	}
	return result + ")";
}

BitVec.prototype.bitsSetInArray = function(arr) {
	for (let i = 0; i < this.data.length; ++i) {
		if ((this.data[i] & arr[i]) !== this.data[i]) {
			return false;
		}
	}
	return true;
}

function BITS_SET_IN_ARRAY(tok, arr, array_size) {

	let result = "(true";
	for (let i = 0; i < array_size; i++) {
		result += `&&((${tok}.data[${i}] & ${arr}[${i}]) === ${tok}.data[${i}])`;
	}
	return result + ")";
}

function NOT_BITS_SET_IN_ARRAY(tok, arr, array_size) {
	let result = "(false";
	for (let i = 0; i < array_size; i++) {
		result += `||((${tok}.data[${i}] & ${arr}[${i}]) !== ${tok}.data[${i}])`;
	}
	return result + ")";
}

BitVec.prototype.bitsClearInArray = function(arr) {
	for (let i = 0; i < this.data.length; ++i) {
		if (this.data[i] & arr[i]) {
			return false;
		}
	}
	return true;
}

function BITS_CLEAR_IN_ARRAY(tok, arr, array_size) {
	if (array_size === 0)
		return "true";
	let result = "(true";
	for (let i = 0; i < array_size; i++) {
		result += `&&((${tok}.data[${i}] & ${arr}.data[${i}]) === 0)`;
	}
	return result + ")";
}

BitVec.prototype.anyBitsInCommon = function(other) {
	for (let i = 0; i < this.data.length; ++i) {
		if (this.data[i] & other.data[i]) {
			return true;
		}
	}
	return false;
}

BitVec.prototype.prettyPrint = function() {
	var result="";
	//print string as bit array, grouped into fives
	for (let i = 0; i < this.data.length; i++) {
		for (let j = 0; j < 32; j++) {
			result += (this.data[i] & (1 << j)) ? "1" : "0";
		}
		result += " ";
	}
	return result;
}

function ANY_BITS_IN_COMMON(tok, arr, array_size) {
	if (array_size === 0) {
		return "false";
	}
	let result = "(false";
	for (let i = 0; i < array_size; i++) {
		result += `||((${tok}.data[${i}] & ${arr}.data[${i}]) !== 0)`;
	}
	return result + ")";
}

function ANY_BITS_IN_COMMON_TOK_REAL(tok, arr) {
	if (arr.length === 0) {
		return "false";
	}
	let result = "(false";
	for (let i = 0; i < arr.length; i++) {
		result += `||((${tok}.data[${i}] & ${arr[i]}) !== 0)`;
	}
	return result + ")";
}

// this function is used to unroll loops in parallel from bitvec - it returns a string
// representation of the javascript unrolled code
function UNROLL(command, array_size) {
	const toks = command.split(" ");
	let result = "";
	for (let i = 0; i < array_size; i++) {
		result += `${toks[0]}.data[${i}] ${toks[1]} ${toks[2]}.data[${i}];\n`;
	}
	return result;
}

function UNROLL_TOK_REAL(tok, op, val, array_size) {
	let result = "";
	for (let i = 0; i < array_size; i++) {
		result += tok + ".data[" + i + "]" + op + val.data[i]+";\n";
	}
	return result;
}

function LEVEL_GET_CELL_INTO(level, index, targetarray, OBJECT_SIZE) {
	let result = "";
	for (let i = 0; i < OBJECT_SIZE; i++) {
		result += targetarray+`.data[${i}]=level.objects[${index}*${OBJECT_SIZE}+${i}];\n`;
	}
	return result;
}

function LEVEL_GET_MOVEMENTS_INTO( index, targetarray, MOVEMENT_SIZE) {
	let result = "";
	for (let i = 0; i < MOVEMENT_SIZE; i++) {
		result += targetarray+`.data[${i}]=level.movements[${index}*${MOVEMENT_SIZE}+${i}];\n`;
	}
	return result;
}


function LEVEL_SET_CELL(level, index, vec, array_size) {
	let result = "";
	for (let i = 0; i < array_size; i++) {
		result += `\t${level}.objects[${index}*${array_size}+${i}]=${vec}.data[${i}];\n`;
	}
	return result;
}


function IMPORT_COMPILE_TIME_ARRAY(runtime,compiletime,array_size){
	let result = "";
	for (let i = 0; i < array_size; i++) {
		result+=`${runtime}.data[${i}]=${compiletime.data[i]};\n`;
	}
	return result;
}


</script>
<script>
'use strict';

function Level(lineNumber, width, height, layerCount, objects) {
	this.lineNumber = lineNumber;
	this.width = width;
	this.height = height;
	this.n_tiles = width * height;
	this.objects = objects;
	this.layerCount = layerCount;
	this.commandQueue = [];
	this.commandQueueSourceRules = [];
}

Level.prototype.delta_index = function (direction) {
	const [dx, dy] = dirMasksDelta[direction]
	return dx * this.height + dy
}

Level.prototype.clone = function () {
	let clone = new Level(this.lineNumber, this.width, this.height, this.layerCount, null);
	clone.objects = new Int32Array(this.objects);
	return clone;
}

Level.prototype.getCell = function (index) {
	return new BitVec(this.objects.subarray(index * STRIDE_OBJ, index * STRIDE_OBJ + STRIDE_OBJ));
}

Level.prototype.getCellInto = function (index, targetarray) {
	for (let i = 0; i < STRIDE_OBJ; i++) {
		targetarray.data[i] = this.objects[index * STRIDE_OBJ + i];
	}
	return targetarray;
}

Level.prototype.setCell = function (index, vec) {
	for (let i = 0; i < vec.data.length; ++i) {
		this.objects[index * STRIDE_OBJ + i] = vec.data[i];
	}
}

let _movementVecs;
let _movementVecIndex = 0;
Level.prototype.getMovements = function (index) {
	let _movementsVec = _movementVecs[_movementVecIndex];
	_movementVecIndex = (_movementVecIndex + 1) % _movementVecs.length;

	for (let i = 0; i < STRIDE_MOV; i++) {
		_movementsVec.data[i] = this.movements[index * STRIDE_MOV + i];
	}
	return _movementsVec;
}

Level.prototype.getRigids = function (index) {
	return this.rigidMovementAppliedMask[index].clone();
}

Level.prototype.getMovementsInto = function (index, targetarray) {
	let _movementsVec = targetarray;

	for (let i = 0; i < STRIDE_MOV; i++) {
		_movementsVec.data[i] = this.movements[index * STRIDE_MOV + i];
	}
	return _movementsVec;
}

Level.prototype.setMovements = function (index, vec) {
	for (let i = 0; i < vec.data.length; ++i) {
		this.movements[index * STRIDE_MOV + i] = vec.data[i];
	}

	//corresponding object stuff in repositionEntitiesOnLayer
	let colIndex = (index / this.height) | 0;
	let rowIndex = (index % this.height);
	level.colCellContents_Movements[colIndex].ior(vec);
	level.rowCellContents_Movements[rowIndex].ior(vec);
	level.mapCellContents_Movements.ior(vec);
}


function LEVEL_SET_MOVEMENTS(index, vec, array_size) {
	var result = "{";
	for (let i = 0; i < array_size; i++) {
		result += `\tlevel.movements[${index}*${array_size}+${i}]=${vec}.data[${i}];\n`;
	}
	result += `
	const colIndex=(${index}/level.height)|0;
	const rowIndex=(${index}%level.height);

	${UNROLL(`level.colCellContents_Movements[colIndex] |= ${vec}`, array_size)}
	${UNROLL(`level.rowCellContents_Movements[rowIndex] |= ${vec}`, array_size)}
	${UNROLL(`level.mapCellContents_Movements |= ${vec}`, array_size)}
}`

	return result;
}

Level.prototype.calcBackgroundMask = function (state) {
	if (state.backgroundlayer === undefined) {
		logError("you have to have a background layer");
	}

	let backgroundMask = state.layerMasks[state.backgroundlayer];
	for (let i = 0; i < this.n_tiles; i++) {
		let cell = this.getCell(i);
		cell.iand(backgroundMask);
		if (!cell.iszero()) {
			return cell;
		}
	}
	const cell = new BitVec(STRIDE_OBJ);
	cell.ibitset(state.backgroundid);
	return cell;
}
</script>
<script>
'use strict';

const relativedirs = ['^', 'v', '<', '>', 'moving','stationary','parallel','perpendicular', 'no'];
const sectionNames = ['objects', 'legend', 'sounds', 'collisionlayers', 'rules', 'winconditions', 'levels'];
const commandwords = ["sfx0","sfx1","sfx2","sfx3","sfx4","sfx5","sfx6","sfx7","sfx8","sfx9","sfx10","cancel","checkpoint","restart","win","message","again"];
const commandwords_sfx = ["sfx0", "sfx1", "sfx2", "sfx3", "sfx4", "sfx5", "sfx6", "sfx7", "sfx8", "sfx9", "sfx10"];
const reg_name = /[\p{L}\p{N}_]+[\p{Z}\s]*/u;///\w*[a-uw-zA-UW-Z0-9_]/;
const reg_soundseed = /\d+\b/u;
const reg_sectionNames = /(objects|collisionlayers|legend|sounds|rules|winconditions|levels)(?![\p{L}\p{N}_])[\p{Z}\s]*/u;
const reg_equalsrow = /[\=]+/;
const reg_notcommentstart = /[^\(]+/;
const reg_match_until_commentstart_or_whitespace = /[^\p{Z}\s\()]+[\p{Z}\s]*/u;
const reg_csv_separators = /[ \,]*/;
const reg_soundverbs = /(move|action|create|destroy|cantmove)\b[\p{Z}\s]*/u;
const soundverbs_directional = ['move','cantmove'];
const reg_soundevents = /(undo|restart|titlescreen|startgame|cancel|endgame|startlevel|endlevel|showmessage|closemessage|sfx0|sfx1|sfx2|sfx3|sfx4|sfx5|sfx6|sfx7|sfx8|sfx9|sfx10)\b[\p{Z}\s]*/u;
const reg_directions = /^(action|up|down|left|right|\^|v|\<|\>|moving|stationary|parallel|perpendicular|horizontal|orthogonal|vertical|no|randomdir|random)$/;
const reg_loopmarker = /^(startloop|endloop)$/;
const reg_ruledirectionindicators = /^(up|down|left|right|horizontal|vertical|orthogonal|late|rigid)$/;
const reg_sounddirectionindicators = /[\p{Z}\s]*(up|down|left|right|horizontal|vertical|orthogonal)(?![\p{L}\p{N}_])[\p{Z}\s]*/u;
const reg_winconditionquantifiers = /^(all|any|no|some)$/;
const keyword_array = ['checkpoint','objects', 'collisionlayers', 'legend', 'sounds', 'rules', '...','winconditions', 'levels','|','[',']','up', 'down', 'left', 'right', 'late','rigid', '^','v','\>','\<','no','randomdir','random', 'horizontal', 'vertical','any', 'all', 'no', 'some', 'moving','stationary','parallel','perpendicular','action','message', "move", "action", "create", "destroy", "cantmove", "sfx0", "sfx1", "sfx2", "sfx3", "Sfx4", "sfx5", "sfx6", "sfx7", "sfx8", "sfx9", "sfx10", "cancel", "checkpoint", "restart", "win", "message", "again", "undo", "restart", "titlescreen", "startgame", "cancel", "endgame", "startlevel", "endlevel", "showmessage", "closemessage"];

const  directionaggregates = {
    'horizontal': ['left', 'right'],
    'horizontal_par': ['left', 'right'],
    'horizontal_perp': ['left', 'right'],
    'vertical': ['up', 'down'],
    'vertical_par': ['up', 'down'],
    'vertical_perp': ['up', 'down'],
    'moving': ['up', 'down', 'left', 'right', 'action'],
    'orthogonal': ['up', 'down', 'left', 'right'],
    'perpendicular': ['^', 'v'],
    'parallel': ['<', '>']
};

const relativeDirections = ['^', 'v', '<', '>', 'perpendicular', 'parallel'];
const simpleAbsoluteDirections = ['up', 'down', 'left', 'right'];
const simpleRelativeDirections = ['^', 'v', '<', '>'];
const reg_directions_only = /^(\>|\<|\^|v|up|down|left|right|moving|stationary|no|randomdir|random|horizontal|vertical|orthogonal|perpendicular|parallel|action)$/;//redeclaring here, i don't know wh

const REGEX_HEX = /^#([0-9A-F]{3}){1,2}$/i;

const reg_color = /(black|white|gray|darkgray|lightgray|grey|darkgrey|lightgrey|red|darkred|lightred|brown|darkbrown|lightbrown|orange|yellow|green|darkgreen|lightgreen|blue|lightblue|darkblue|purple|pink|transparent|#(?:[0-9a-f]{3}){1,2})\s*/;

// lots of hardcoded stuff for autocomplete in anyword-hint also, but 
// it's not including here because I don't want to bloat the standalone
// runtime unnecessarily.
</script>
<script>
'use strict';

let unitTesting = false;
let lazyFunctionGeneration = true;
let curlevel = 0;
let curlevelTarget = null;
let hasUsedCheckpoint = false;
let levelEditorOpened = false;
let muted = 0;
let runrulesonlevelstart_phase = false;
let ignoreNotJustPressedAction = true;
let textMode = true;

function doSetupTitleScreenLevelContinue() {
    try {
        if (storage_has(document.URL)) {
            if (storage_has(document.URL + '_checkpoint')) {
                let backupStr = storage_get(document.URL + '_checkpoint');
                curlevelTarget = JSON.parse(backupStr);

                let arr = [];
                for (let p in Object.keys(curlevelTarget.dat)) {
                    arr[p] = curlevelTarget.dat[p];
                }
                curlevelTarget.dat = new Int32Array(arr);

            }
            curlevel = storage_get(document.URL);
        }
    } catch (ex) {
    }
}

doSetupTitleScreenLevelContinue();


let verbose_logging = false;
let throttle_movement = false;
let suppress_all_console_output = false;
let cache_console_messages = false;
let quittingTitleScreen = false;
let quittingMessageScreen = false;
let deltatime = 17; // this gets updated every frame; see loop()
let timer = 0;
let repeatinterval = 150;
let autotick = 0;
let autotickinterval = 0;
let winning = false;
let againing = false;
let againinterval = 150;
let norepeat_action = false;
let oldflickscreendat = [];//used for buffering old flickscreen/scrollscreen positions, in case player vanishes
let keybuffer = [];

let restarting = false;

let messageselected = false;

let textImages = {};

let level = new Level(); //just give it some starting state


function get_title_animation_frame() {
    return Math.floor(((timer / 1000) / 0.3) * 10)
}

var WORKLIST_OBJECTS_TO_GENERATE_FUNCTIONS_FOR = [];
function tick_lazy_function_generation(iterative_generation = false) {
    if (WORKLIST_OBJECTS_TO_GENERATE_FUNCTIONS_FOR.length === 0) {
        return;
    }
    // spent a maximum of 10ms on lazy function generation
    let start = performance.now();
    var generated_count = 0;
    while (
        ((performance.now() - start < 20) || !iterative_generation)
        && WORKLIST_OBJECTS_TO_GENERATE_FUNCTIONS_FOR.length > 0) {
        const object = WORKLIST_OBJECTS_TO_GENERATE_FUNCTIONS_FOR.shift();
        //depending on type of object
        //if CellPattern, call generateMatchFunction
        //if Rule, call generate_all_MatchFunctions
        if (object instanceof CellPattern) {
            object.matches = object.generateMatchFunction();
        } else if (object instanceof Rule) {
            object.generate_all_MatchFunctions();
        } else {
            throw new Error("Unknown object type: " + object);
        }
        generated_count++;
    }
}

function lazy_function_generation_clear_backlog() {
    WORKLIST_OBJECTS_TO_GENERATE_FUNCTIONS_FOR = [];
}


</script>
<script>
'use strict';

let canSetHTMLColors=true;
let canDump=false;
let canOpenEditor=false;
let IDE=false;
const diffToVisualize=null;

function stripTags(str) {
	let div = document.createElement("div");
	div.innerHTML = str;
	let result = div.textContent || div.innerText || "";
	return result;
}

function consolePrint(linenumber,inspect_ID){
/*	let errorText = document.getElementById("errormessage");
	
	str=stripTags(str);
	errorText.innerHTML+=str+"<br>";*/
}

function consolePrintFromRule(str,rule,urgent){
/*	let errorText = document.getElementById("errormessage");
	
	str=stripTags(str);
	errorText.innerHTML+=str+"<br>";*/
}

function consoleCacheDump(str){
	
}

function UnitTestingThrow(error){}

function consoleError(str,lineNumber){
	let errorText = document.getElementById("errormessage");
	str=stripTags(str);
	errorText.innerHTML+=str+"<br>";
}

function logErrorNoLine(str){
	let errorText = document.getElementById("errormessage");
	str=stripTags(str);
	errorText.innerHTML+=str+"<br>";
}

function clearInputHistory() {}
function pushInput(inp) {}
function pushSoundToHistory(seed) {}

</script>
<script>
'use strict';

let font = {
	'0': `
00000
00000
00000
01110
10001
10011
10101
11001
10001
01110
00000
00000`,
	'1': `
00000
00000
00000
11100
00100
00100
00100
00100
00100
11111
00000
00000`,
	'2': `
00000
00000
00000
11110
00001
00001
01110
10000
10000
11111
00000
00000`,
	'3': `
00000
00000
00000
11110
00001
00110
00001
00001
00001
11110
00000
00000`,
	'4': `
00000
00000
00000
10000
10000
10000
10010
11111
00010
00010
00000
00000`,
	'5': `
00000
00000
00000
11111
10000
11110
00001
00001
00001
11110
00000
00000`,
	'6': `
00000
00000
00000
01110
10000
11110
10001
10001
10001
01110
00000
00000`,
	'7': `
00000
00000
00000
11111
00001
00010
00100
00100
00100
00100
00000
00000`,
	'8': `
00000
00000
00000
01110
10001
01110
10001
10001
10001
01110
00000
00000`,
	'9': `
00000
00000
00000
01110
10001
10001
10001
01111
00001
01110
00000
00000`,
	'a': `
00000
00000
00000
00000
00000
01111
10001
10001
10001
01111
00000
00000`,
	'b': `
00000
00000
00000
10000
10000
11110
10001
10001
10001
01110
00000
00000`,
	'c': `
00000
00000
00000
00000
00000
01111
10000
10000
10000
01111
00000
00000`,
	'd': `
00000
00000
00000
00001
00001
01111
10001
10001
10001
01111
00000
00000`,
	'e': `
00000
00000
00000
00000
00000
01110
10001
11111
10000
01110
00000
00000`,
	'f': `
00000
00000
00000
00011
00100
11111
00100
00100
00100
00100
00000
00000`,
	'g': `
00000
00000
00000
00000
00000
01111
10001
10001
10001
01111
00001
01110`,
	'h': `
00000
00000
00000
10000
10000
11110
10001
10001
10001
10001
00000
00000`,
	'i': `
00000
00000
00000
00100
00000
01100
00100
00100
00100
01110
00000
00000`,
	'j': `
00000
00000
00000
00100
00000
01100
00100
00100
00100
00100
10100
01000`,
	'k': `
00000
00000
00000
10000
10000
10001
10010
11100
10010
10001
00000
00000`,
	'l': `
00000
00000
00000
01100
00100
00100
00100
00100
00100
01110
00000
00000`,
	'm': `
00000
00000
00000
00000
00000
01010
10101
10101
10101
10101
00000
00000`,
	'n': `
00000
00000
00000
00000
00000
01110
10001
10001
10001
10001
00000
00000`,
	'o': `
00000
00000
00000
00000
00000
01110
10001
10001
10001
01110
00000
00000`,
	'p': `
00000
00000
00000
00000
00000
11110
10001
10001
10001
11110
10000
10000`,
	'q': `
00000
00000
00000
00000
00000
01111
10001
10001
10001
01111
00001
00001`,
	'r': `
00000
00000
00000
00000
00000
01111
10000
10000
10000
10000
00000
00000`,
	's': `
00000
00000
00000
00000
00000
01111
10000
01110
00001
11110
00000
00000`,
	't': `
00000
00000
00000
00100
00100
11111
00100
00100
00100
00011
00000
00000`,
	'u': `
00000
00000
00000
00000
00000
10001
10001
10001
10001
01111
00000
00000`,
	'v': `
00000
00000
00000
00000
00000
10001
10010
10100
11000
10000
00000
00000`,
	'w': `
00000
00000
00000
00000
00000
10101
10101
10101
10101
01010
00000
00000`,
	'x': `
00000
00000
00000
00000
00000
10001
01010
00100
01010
10001
00000
00000`,
	'×': `
00000
00000
00000
00000
00000
10001
01010
00100
01010
10001
00000
00000`,
	'y': `
00000
00000
00000
00000
00000
10001
10001
10001
10001
01111
00001
11110`,
	'z': `
00000
00000
00000
00000
00000
11111
00010
00100
01000
11111
00000
00000`,
	'A': `
00000
00000
00000
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'B': `
00000
00000
00000
11110
10001
11110
10001
10001
10001
11110
00000
00000`,
	'C': `
00000
00000
00000
01111
10000
10000
10000
10000
10000
01111
00000
00000`,
	'D': `
00000
00000
00000
11110
10001
10001
10001
10001
10001
11110
00000
00000`,
	'E': `
00000
00000
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'F': `
00000
00000
00000
11111
10000
11111
10000
10000
10000
10000
00000
00000`,
	'G': `
00000
00000
00000
01111
10000
10000
10000
10011
10001
01111
00000
00000`,
	'H': `
00000
00000
00000
10001
10001
11111
10001
10001
10001
10001
00000
00000`,
	'I': `
00000
00000
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'J': `
00000
00000
00000
01111
00001
00001
00001
00001
00001
01110
00000
00000`,
	'K': `
00000
00000
00000
10001
10010
10100
11000
10100
10010
10001
00000
00000`,
	'L': `
00000
00000
00000
10000
10000
10000
10000
10000
10000
11111
00000
00000`,
	'M': `
00000
00000
00000
11111
10101
10101
10101
10101
10101
10101
00000
00000`,
	'N': `
00000
00000
00000
10001
11001
10101
10011
10001
10001
10001
00000
00000`,
	'O': `
00000
00000
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'P': `
00000
00000
00000
11110
10001
10001
10001
11110
10000
10000
00000
00000`,
	'Q': `
00000
00000
00000
01110
10001
10001
10001
10001
10101
01110
00100
00000`,
	'R': `
00000
00000
00000
11110
10001
10001
11110
10001
10001
10001
00000
00000`,
	'S': `
00000
00000
00000
01111
10000
01110
00001
00001
00001
11110
00000
00000`,
	'T': `
00000
00000
00000
11111
00100
00100
00100
00100
00100
00100
00000
00000`,
	'U': `
00000
00000
00000
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'V': `
00000
00000
00000
10001
10001
10001
10001
10001
01010
00100
00000
00000`,
	'W': `
00000
00000
00000
10101
10101
10101
10101
10101
10101
01010
00000
00000`,
	'X': `
00000
00000
00000
10001
10001
01010
00100
01010
10001
10001
00000
00000`,
	'Y': `
00000
00000
00000
10001
10001
01010
00100
00100
00100
00100
00000
00000`,
	'Z': `
00000
00000
00000
11111
00001
00010
00100
01000
10000
11111
00000
00000`,
	'.': `
00000
00000
00000
00000
00000
00000
00000
00000
00000
00100
00000
00000`,
	'·': `
00000
00000
00000
00000
00000
00000
00100
00000
00000
00000
00000
00000`,
	'•': `
00000
00000
00000
00000
00000
01110
01110
01110
00000
00000
00000
00000`,
	'…': `
00000
00000
00000
00000
00000
00000
00000
00000
00000
10101
00000
00000`,
	'†': `
00000
00100
00100
01110
00100
00100
00100
00100
00100
00100
00000
00000`,
	'‡': `
00000
00100
00100
01110
00100
00100
00100
00100
01110
00100
00000
00000`,
	'ƒ': `
00000
00000
00000
00011
00100
11111
00100
00100
00100
00100
01000
00000`,
	'‚': `
00000
00000
00000
00000
00000
00000
00000
00000
00100
01100
00000
00000`,
	'„': `
00000
00000
00000
00000
00000
00000
00000
00000
01001
11011
00000
00000`,
	',': `
00000
00000
00000
00000
00000
00000
00000
00000
00100
01100
00000
00000`,
	';': `
00000
00000
00000
00000
00000
00100
00000
00000
00100
01100
00000
00000`,
	':': `
00000
00000
00000
00000
00000
00100
00000
00000
00000
00100
00000
00000`,
	'?': `
00000
00000
00000
01110
10001
00001
00001
00110
00000
00100
00000
00000`,
	'¿': `
00000
00000
00000
00100
00000
01100
10000
10000
10001
01110
00000
00000`,
	'!': `
00000
00000
00000
00100
00100
00100
00100
00100
00000
00100
00000
00000`,
	'¡': `
00000
00000
00000
00100
00000
00100
00100
00100
00100
00100
00000
00000`,
	'@': `
00000
00000
00000
00000
00000
01110
10001
10111
10000
01110
00000
00000`,
	'£': `
00000
00000
00000
00000
00000
01110
01001
11100
01000
11111
00000
00000`,
	'$': `
00000
00000
00000
00000
00100
01111
10100
01110
00101
11110
00100
00000`,
	'%': `
00000
00000
00000
00000
00000
11001
11010
00100
01011
10011
00000
00000`,
	'‰': `
00000
00000
00000
00000
11001
11010
00100
01011
10011
00000
00011
00011`,
	'^': `
00000
00000
00000
00100
01010
00000
00000
00000
00000
00000
00000
00000`,
	'&': `
00000
00000
00000
00000
00000
01100
10000
01011
10010
01100
00000
00000`,
	'*': `
00000
00000
00000
00000
00000
01010
00100
01010
00000
00000
00000
00000`,
	'(': `
00000
00000
00000
00010
00100
00100
00100
00100
00100
00010
00000
00000`,
	')': `
00000
00000
00000
01000
00100
00100
00100
00100
00100
01000
00000
00000`,
	'+': `
00000
00000
00000
00000
00000
00100
00100
11111
00100
00100
00000
00000`,
	'÷': `
00000
00000
00000
00000
00000
00100
00000
11111
00000
00100
00000
00000`,
	'±': `
00000
00000
00000
00000
00000
00100
00100
11111
00100
11111
00000
00000`,
	'-': `
00000
00000
00000
00000
00000
00000
00000
01110
00000
00000
00000
00000`,
	'–': `
00000
00000
00000
00000
00000
00000
00000
11110
00000
00000
00000
00000`,
	'—': `
00000
00000
00000
00000
00000
00000
00000
11111
00000
00000
00000
00000`,
	'_': `
00000
00000
00000
00000
00000
00000
00000
00000
00000
11111
00000
00000`,
	'=': `
00000
00000
00000
00000
00000
00000
11111
00000
11111
00000
00000
00000`,
	' ': `
00000
00000
00000
00000
00000
00000
00000
00000
00000
00000
00000
00000`,
	'{': `
00000
00000
00000
00110
00100
00100
01100
00100
00100
00110
00000
00000`,
	'}': `
00000
00000
00000
01100
00100
00100
00110
00100
00100
01100
00000
00000`,
	'[': `
00000
00000
00000
00110
00100
00100
00100
00100
00100
00110
00000
00000`,
	']': `
00000
00000
00000
01100
00100
00100
00100
00100
00100
01100
00000
00000`,
	'\'': `
00000
00000
00000
00100
00100
00100
00000
00000
00000
00000
00000
00000`,
	'‘': `
00000
00000
00000
00110
00100
00000
00000
00000
00000
00000
00000
00000`,
	'’': `
00000
00000
00000
00100
01100
00000
00000
00000
00000
00000
00000
00000`,
	'“': `
00000
00000
00000
11011
10010
00000
00000
00000
00000
00000
00000
00000`,
	'”': `
00000
00000
00000
01001
11011
00000
00000
00000
00000
00000
00000
00000`,
	'"': `
00000
00000
00000
01010
01010
01010
00000
00000
00000
00000
00000
00000`,
	'/': `
00000
00000
00000
00000
00000
00001
00010
00100
01000
10000
00000
00000`,
	'\\': `
00000
00000
00000
00000
00000
10000
01000
00100
00010
00001
00000
00000`,
	'|': `
00000
00000
00000
00000
00000
00100
00100
00100
00100
00100
00000
00000`,
	'¦': `
00000
00000
00000
00000
00100
00100
00000
00100
00100
00100
00000
00000`,
	'<': `
00000
00000
00000
00000
00000
00010
00100
01000
00100
00010
00000
00000`,
	'‹': `
00000
00000
00000
00000
00000
00000
00100
01000
00100
00000
00000
00000`,
	'«': `
00000
00000
00000
00000
00000
00000
01001
10010
01001
00000
00000
00000`,
	'>': `
00000
00000
00000
00000
00000
01000
00100
00010
00100
01000
00000
00000`,
	'›': `
00000
00000
00000
00000
00000
00000
00100
00010
00100
00000
00000
00000`,
	'»': `
00000
00000
00000
00000
00000
00000
10010
01001
10010
00000
00000
00000`,
	'~': `
00000
00000
00000
00000
00000
00000
01000
10101
00010
00000
00000
00000`,
	'˜': `
00000
00000
00000
00000
00000
01010
10100
00000
00000
00000
00000
00000`,
	'`': `
00000
00000
00000
00000
00000
01000
00100
00000
00000
00000
00000
00000`,
	'#': `
00000
00000
00000
00000
00000
01010
11111
01010
11111
01010
00000
00000`,
	'À': `
01000
00100
00000
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'Á': `
00010
00100
00000
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'Â': `
00100
01010
00000
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'Ã': `
01000
10101
00010
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'Ä': `
00000
01010
00000
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'Å': `
00100
01010
00100
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'Æ': `
00000
00000
00000
01111
10100
10100
10100
11111
10100
10111
00000
00000`,
	'Ç': `
00000
00000
00000
01111
10000
10000
10000
10000
10000
01111
00100
01000`,
	'È': `
01000
00100
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'É': `
00010
00100
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'Ê': `
00100
01010
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'Ë': `
00000
01010
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'Ì': `
01000
00100
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'Í': `
00010
00100
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'Î': `
00100
01010
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'Ï': `
00000
01010
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'Ð': `
00000
00000
00000
01110
01001
01001
11101
01001
01001
01110
00000
00000`,
	'Ñ': `
01001
10110
00000
10001
11001
10101
10011
10001
10001
10001
00000
00000`,
	'Ò': `
01000
00100
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Ó': `
00010
00100
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Ô': `
00100
01010
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Õ': `
01001
10110
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Ö': `
00000
01010
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Ø': `
00000
00010
00100
01110
10101
10101
10101
10101
10101
01110
00100
01000`,
	'Ù': `
00000
01000
00100
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Ú': `
00000
00010
00100
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Û': `
00100
01010
00000
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Ü': `
00000
01010
00000
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'Ý': `
00000
00000
00100
10001
10001
01010
00100
00100
00100
00100
00000
00000`,
	'Þ': `
00000
00000
10000
11110
10001
10001
10001
10001
10001
11110
10000
00000`,
	'ß': `
00000
00000
00000
01110
10001
10110
10001
10001
10001
10110
10000
00000`,
	'ẞ': `
00000
00000
00000
01110
10001
10110
10001
10001
10001
10110
00000
00000`,
	'à': `
00000
00000
01000
00100
00000
01111
10001
10001
10001
01111
00000
00000`,
	'á': `
00000
00000
00010
00100
00000
01111
10001
10001
10001
01111
00000
00000`,
	'â': `
00000
00000
00100
01010
00000
01111
10001
10001
10001
01111
00000
00000`,
	'ã': `
00000
00000
01001
10110
00000
01111
10001
10001
10001
01111
00000
00000`,
	'ä': `
00000
00000
00000
01010
00000
01111
10001
10001
10001
01111
00000
00000`,
	'å': `
00000
00100
01010
00100
00000
01111
10001
10001
10001
01111
00000
00000`,
	'æ': `
00000
00000
00000
00000
00000
01110
10101
10110
10100
01111
00000
00000`,
	'ç': `
00000
00000
00000
00000
00000
01111
10000
10000
10000
01111
00100
01000`,
	'è': `
00000
00000
01000
00100
00000
01110
10001
11111
10000
01110
00000
00000`,
	'é': `
00000
00000
00010
00100
00000
01110
10001
11111
10000
01110
00000
00000`,
	'ê': `
00000
00000
00100
01010
00000
01110
10001
11111
10000
01110
00000
00000`,
	'ë': `
00000
00000
00000
01010
00000
01110
10001
11111
10000
01110
00000
00000`,
	'ì': `
00000
00000
01000
00100
00000
01100
00100
00100
00100
01110
00000
00000`,
	'í': `
00000
00000
00010
00100
00000
01100
00100
00100
00100
01110
00000
00000`,
	'î': `
00000
00000
00100
01010
00000
01100
00100
00100
00100
01110
00000
00000`,
	'ï': `
00000
00000
00000
01010
00000
01100
00100
00100
00100
01110
00000
00000`,
	'ð': `
00000
00000
00010
00111
00010
01110
10010
10010
10010
01110
00000
00000`,
	'ñ': `
00000
00000
01001
10110
00000
01110
10001
10001
10001
10001
00000
00000`,
	'ò': `
00000
00000
01000
00100
00000
01110
10001
10001
10001
01110
00000
00000`,
	'ó': `
00000
00000
00010
00100
00000
01110
10001
10001
10001
01110
00000
00000`,
	'ô': `
00000
00000
00100
01010
00000
01110
10001
10001
10001
01110
00000
00000`,
	'õ': `
00000
00000
01001
10110
00000
01110
10001
10001
10001
01110
00000
00000`,
	'ö': `
00000
00000
00000
01010
00000
01110
10001
10001
10001
01110
00000
00000`,
	'ø': `
00000
00000
00000
00010
00100
01110
10101
10101
10101
01110
00100
01000`,
	'ù': `
00000
00000
00000
01000
00100
10001
10001
10001
10001
01111
00000
00000`,
	'ú': `
00000
00000
00000
00010
00100
10001
10001
10001
10001
01111
00000
00000`,
	'û': `
00000
00000
00100
01010
00000
10001
10001
10001
10001
01111
00000
00000`,
	'ü': `
00000
00000
00000
01010
00000
10001
10001
10001
10001
01111
00000
00000`,
	'ý': `
00000
00000
00000
00010
00100
10001
10001
10001
10001
01111
00001
11110`,
	'þ': `
00000
00000
00000
10000
10000
11110
10001
10001
10001
11110
10000
10000`,
	'ÿ': `
00000
00000
00000
01010
00000
10001
10001
10001
10001
01111
00001
11110`,
	'Ā': `
00000
01110
00000
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'ā': `
00000
00000
00000
01110
00000
01111
10001
10001
10001
01111
00000
00000`,
	'Ă': `
01010
00100
00000
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'ă': `
00000
00000
01010
00100
00000
01111
10001
10001
10001
01111
00000
00000`,
	'Ą': `
00000
00000
00000
01110
10001
10001
10001
11111
10001
10001
00010
00001`,
	'ą': `
00000
00000
00000
00000
00000
01111
10001
10001
10001
01111
00010
00001`,
	'Ć': `
00010
00100
00000
01111
10000
10000
10000
10000
10000
01111
00000
00000`,
	'ć': `
00000
00000
00010
00100
00000
01111
10000
10000
10000
01111
00000
00000`,
	'Ĉ': `
00100
01010
00000
01111
10000
10000
10000
10000
10000
01111
00000
00000`,
	'ĉ': `
00000
00000
00100
01010
00000
01111
10000
10000
10000
01111
00000
00000`,
	'Ċ': `
00000
00100
00000
01111
10000
10000
10000
10000
10000
01111
00000
00000`,
	'ċ': `
00000
00000
00000
00100
00000
01111
10000
10000
10000
01111
00000
00000`,
	'Č': `
01010
00100
00000
01111
10000
10000
10000
10000
10000
01111
00000
00000`,
	'č': `
00000
00000
01010
00100
00000
01111
10000
10000
10000
01111
00000
00000`,
	'Ď': `
01010
00100
00000
11110
10001
10001
10001
10001
10001
11110
00000
00000`,
	'ď': `
00000
00000
00000
00101
00101
01100
10100
10100
10100
01100
00000
00000`,
	'Đ': `
00000
00000
00000
01110
01001
01001
11101
01001
01001
01110
00000
00000`,
	'đ': `
00000
00000
00010
00111
00010
01110
10010
10010
10010
01110
00000
00000`,
	'Ē': `
00000
01110
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'ē': `
00000
00000
00000
01110
00000
01110
10001
11111
10000
01110
00000
00000`,
	'Ĕ': `
01010
00100
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'ĕ': `
00000
00000
01010
00100
00000
01110
10001
11111
10000
01110
00000
00000`,
	'Ė': `
00000
00100
00000
11111
10000
11111
10000
10000
10000
11111
00000
00000`,
	'ė': `
00000
00000
00000
00100
00000
01110
10001
11111
10000
01110
00000
00000`,
	'Ę': `
00000
00000
00000
11111
10000
11111
10000
10000
10000
11111
00010
00001`,
	'ę': `
00000
00000
00000
00000
00000
01110
10001
11111
10000
01110
00010
00001`,
	'Ě': `
01010
00100
00000
11111
10000
11111
10000
10000
10000
11110
00000
00000`,
	'ě': `
00000
00000
01010
00100
00000
01110
10001
11111
10000
01110
00000
00000`,
	'Ĝ': `
00100
01010
00000
01111
10000
10000
10000
10011
10001
01111
00000
00000`,
	'ĝ': `
00000
00000
00100
01010
00000
01111
10001
10001
10001
01111
00001
01110`,
	'Ğ': `
01010
00100
00000
01111
10000
10000
10000
10011
10001
01111
00000
00000`,
	'ğ': `
00000
00000
01010
00100
00000
01111
10001
10001
10001
01111
00001
01110`,
	'Ġ': `
00000
00100
00000
01111
10000
10000
10000
10011
10001
01111
00000
00000`,
	'ġ': `
00000
00000
00000
00100
00000
01111
10001
10001
10001
01111
00001
01110`,
	'Ģ': `
00000
00000
00000
01111
10000
10000
10000
10011
10001
01111
00000
01100`,
	'ģ': `
00010
00100
00000
01111
10000
10000
10000
10011
10001
01111
00000
00000`,
	'Ĥ': `
00100
01010
00000
10001
10001
11111
10001
10001
10001
10001
00000
00000`,
	'ĥ': `
00100
01010
00000
10000
10000
11110
10001
10001
10001
10001
00000
00000`,
	'Ħ': `
00000
00000
01010
11111
01010
01110
01010
01010
01010
01010
00000
00000`,
	'ħ': `
00000
00000
01000
11100
01000
01110
01001
01001
01001
01001
00000
00000`,
	'Ĩ': `
01001
10110
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'ĩ': `
01010
10100
00000
00100
00000
01100
00100
00100
00100
01110
00000
00000`,
	'Ī': `
00000
01110
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'ī': `
00000
00000
00000
01110
00000
01100
00100
00100
00100
01110
00000
00000`,
	'Ĭ': `
01010
00100
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'ĭ': `
00000
00000
01010
00100
00000
01100
00100
00100
00100
01110
00000
00000`,
	'Į': `
00000
00000
00000
11111
00100
00100
00100
00100
00100
11111
00010
00001`,
	'į': `
00000
00000
00000
00100
00000
01100
00100
00100
00100
01110
00010
00001`,
	'İ': `
00000
00100
00000
11111
00100
00100
00100
00100
00100
11111
00000
00000`,
	'ı': `
00000
00000
00000
00000
00000
01100
00100
00100
00100
01110
00000
00000`,
	'Ĳ': `
00000
00000
00000
10010
10010
10010
10010
10010
10010
10110
00000
00000`,
	'ĳ': `
00000
00000
00000
01001
00000
11001
01001
01001
01001
11101
00001
00010`,
	'Ĵ': `
00010
00101
00000
01111
00001
00001
00001
00001
00001
01110
00000
00000`,
	'ĵ': `
00000
00000
00100
01010
00000
01100
00100
00100
00100
00100
10100
01000`,
	'Ķ': `
00000
00000
00000
10001
10010
10100
11000
10100
10010
10001
00100
01000`,
	'ķ': `
00000
00000
00000
10000
10000
10001
10010
11100
10010
10001
00100
01000`,
	'ĸ': `
00000
00000
00000
00000
00000
10001
10010
11100
10010
10001
00000
00000`,
	'Ĺ': `
00000
00010
00100
10000
10000
10000
10000
10000
10000
11111
00000
00000`,
	'ĺ': `
00010
00100
00000
01100
00100
00100
00100
00100
00100
01110
00000
00000`,
	'Ļ': `
00000
00000
00000
10000
10000
10000
10000
10000
10000
11111
00000
00100`,
	'ļ': `
00000
00000
00000
01100
00100
00100
00100
00100
00100
01110
00000
00100`,
	'Ľ': `
00000
00000
00000
10010
10010
10000
10000
10000
10000
11111
00000
00000`,
	'ľ': `
00000
00000
00000
01101
00101
00100
00100
00100
00100
01110
00000
00000`,
	'Ŀ': `
00000
00000
00000
10000
10000
10100
10000
10000
10000
11111
00000
00000`,
	'ŀ': `
00000
00000
00000
01100
00100
00100
00101
00100
00100
01110
00000
00000`,
	'Ł': `
00000
00000
00000
01000
01010
01100
11000
01000
01000
01111
00000
00000`,
	'ł': `
00000
00000
00000
01100
00100
00100
00110
01100
00100
01110
00000
00000`,
	'Ń': `
00000
00010
00100
10001
11001
10101
10011
10001
10001
10001
00000
00000`,
	'ń': `
00000
00000
00010
00100
00000
01110
10001
10001
10001
10001
00000
00000`,
	'Ņ': `
00000
00000
00000
10001
11001
10101
10011
10001
10001
10001
00100
01000`,
	'ņ': `
00000
00000
00000
00000
00000
01110
10001
10001
10001
10001
00100
01000`,
	'Ň': `
00000
01010
00100
10001
11001
10101
10011
10001
10001
10001
00000
00000`,
	'ň': `
00000
00000
01010
00100
00000
01110
10001
10001
10001
10001
00000
00000`,
	'ŉ': `
00000
00000
00000
10000
10000
00110
01001
01001
01001
01001
00000
00000`,
	'Ŋ': `
00000
00000
00000
10001
11001
10101
10011
10001
10001
10001
00001
00010`,
	'ŋ': `
00000
00000
00000
00000
00000
01110
10001
10001
10001
10001
00001
00010`,
	'Ō': `
00000
01110
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ō': `
00000
00000
00000
01110
00000
01110
10001
10001
10001
01110
00000
00000`,
	'Ŏ': `
01010
00100
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ŏ': `
00000
00000
01010
00100
00000
01110
10001
10001
10001
01110
00000
00000`,
	'Ő': `
01001
10010
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ő': `
00000
00000
01001
10010
00000
01110
10001
10001
10001
01110
00000
00000`,
	'Œ': `
00000
00000
00000
01111
10100
10100
10111
10100
10100
01111
00000
00000`,
	'œ': `
00000
00000
00000
00000
00000
01110
10101
10110
10100
01111
00000
00000`,
	'Ŕ': `
00010
00100
00000
11110
10001
10001
11110
10001
10001
10001
00000
00000`,
	'ŕ': `
00000
00000
00010
00100
00000
01111
10000
10000
10000
10000
00000
00000`,
	'Ŗ': `
00000
00000
00000
11110
10001
10001
11110
10001
10001
10001
00100
01000`,
	'ŗ': `
00000
00000
00000
00000
00000
01111
10000
10000
10000
10000
00100
01000`,
	'Ř': `
01010
00100
00000
11110
10001
10001
11110
10001
10001
10001
00000
00000`,
	'ř': `
00000
00000
01010
00100
00000
01111
10000
10000
10000
10000
00000
00000`,
	'Ś': `
00010
00100
00000
01111
10000
01110
00001
00001
00001
11110
00000
00000`,
	'ś': `
00000
00000
00010
00100
00000
01111
10000
01110
00001
11110
00000
00000`,
	'Ŝ': `
00100
01010
00000
01111
10000
01110
00001
00001
00001
11110
00000
00000`,
	'ŝ': `
00000
00000
00100
01010
00000
01111
10000
01110
00001
11110
00000
00000`,
	'Ş': `
00000
00000
00000
01111
10000
01110
00001
00001
00001
11110
00100
00000`,
	'ş': `
00000
00000
00000
00000
00000
01111
10000
01110
00001
11110
00100
01000`,
	'Š': `
01010
00100
00000
01111
10000
01110
00001
00001
00001
11110
00000
00000`,
	'š': `
00000
00000
01010
00100
00000
01111
10000
01110
00001
11110
00000
00000`,
	'Ţ': `
00000
00000
00000
11111
00100
00100
00100
00100
00100
00100
00010
00100`,
	'ţ': `
00000
00000
00000
00100
00100
11111
00100
00100
00100
00011
00000
01100`,
	'Ť': `
01010
00100
00000
11111
00100
00100
00100
00100
00100
00100
00000
00000`,
	'ť': `
00000
00000
00001
00101
00100
11111
00100
00100
00100
00011
00000
00000`,
	'Ŧ': `
00000
00000
00000
11111
00100
00100
01110
00100
00100
00100
00000
00000`,
	'ŧ': `
00000
00000
00000
00100
00100
11111
00100
01110
00100
00011
00000
00000`,
	'Ũ': `
01001
10110
00000
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ũ': `
00000
00000
01001
10110
00000
10001
10001
10001
10001
01111
00000
00000`,
	'Ū': `
00000
01110
00000
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ū': `
00000
00000
00000
01110
00000
10001
10001
10001
10001
01111
00000
00000`,
	'Ŭ': `
01010
00100
00000
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ŭ': `
00000
00000
01010
00100
00000
10001
10001
10001
10001
01111
00000
00000`,
	'Ů': `
00100
01010
00100
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ů': `
00000
00000
00100
01010
00100
10001
10001
10001
10001
01111
00000
00000`,
	'Ű': `
01001
10010
00000
10001
10001
10001
10001
10001
10001
01110
00000
00000`,
	'ű': `
00000
00000
01001
10010
00000
10001
10001
10001
10001
01111
00000
00000`,
	'Ų': `
00000
00000
00000
10001
10001
10001
10001
10001
10001
01110
00100
00010`,
	'ų': `
00000
00000
00000
00000
00000
10001
10001
10001
10001
01111
00010
00001`,
	'Ŵ': `
00100
01010
00000
10101
10101
10101
10101
10101
10101
01010
00000
00000`,
	'ŵ': `
00000
00000
00100
01010
00000
10101
10101
10101
10101
01010
00000
00000`,
	'Ŷ': `
00100
01010
00000
10001
10001
01010
00100
00100
00100
00100
00000
00000`,
	'ŷ': `
00000
00000
00100
01010
00000
10001
10001
10001
10001
01111
00001
11110`,
	'Ÿ': `
00000
01010
00000
10001
10001
01010
00100
00100
00100
00100
00000
00000`,
	'Ź': `
00010
00100
00000
11111
00001
00010
00100
01000
10000
11111
00000
00000`,
	'ź': `
00000
00000
00010
00100
00000
11111
00010
00100
01000
11111
00000
00000`,
	'Ż': `
00000
00100
00000
11111
00001
00010
00100
01000
10000
11111
00000
00000`,
	'ż': `
00000
00000
00000
00100
00000
11111
00010
00100
01000
11111
00000
00000`,
	'Ž': `
01010
00100
00000
11111
00001
00010
00100
01000
10000
11111
00000
00000`,
	'ž': `
00000
00000
01010
00100
00000
11111
00010
00100
01000
11111
00000
00000`,

	'€': `
00000
00000
00000
00111
01000
11110
01000
11110
01000
00111
00000
00000`,

	'™': `
00000
11111
00100
00100
00100
00000
01010
10101
10101
10101
00000
00000`,
	'¢': `
00000
00000
00000
00010
00100
01111
10100
10100
10100
01111
00100
01000`,

	'¤': `
00000
00000
00000
00000
10001
01110
10001
10001
01110
10001
00000
00000`,
	'¥': `
00000
00000
10001
01010
00100
01110
00100
01110
00100
00000
00000`,

	'§': `
00000
00000
00000
01110
10000
01110
10001
01110
00001
01110
00000
00000`,
	'¨': `
00000
00000
00000
01010
00000
00000
00000
00000
00000
00000
00000
00000`,
	'©': `
00000
00000
00000
01110
10001
10111
10101
10111
10001
01110
00000
00000`,
	'®': `
00000
00000
00000
01110
10001
10111
10101
10101
10001
01110
00000
00000`,
	'ª': `
00000
01110
00010
01110
01010
01110
00000
00000
00000
00000
00000
00000`,
	'º': `
00000
00100
01010
01010
01010
00100
00000
00000
00000
00000
00000
00000`,

	'¬': `
00000
00000
00000
00000
00000
00000
00000
01110
00010
00000
00000
00000`,
	'¯': `
00000
00000
00000
01110
00000
00000
00000
00000
00000
00000
00000
00000`,
	'°': `
00000
00000
00100
01010
00100
00000
00000
00000
00000
00000
00000
00000`,
	'А': `
00000
00000
00000
01110
10001
10001
10001
11111
10001
10001
00000
00000`,
	'Б': `
00000
00000
00000
11111
10000
11110
10001
10001
10001
11110
00000
00000`,
	'В': `
00000
00000
00000
11110
10001
11110
10001
10001
10001
11110
00000
00000`,
	'Г': `
00000
00000
00000
11111
10000
10000
10000
10000
10000
10000
00000
00000`,
	'Д': `
00000
00000
00000
00011
00101
01001
01001
01001
01001
11111
10001
00000`,
	'Е': `
00000
00000
00000
11111
10000
11110
10000
10000
10000
11111
00000
00000`,
	'Ё': `
00000
01010
00000
11111
10000
11110
10000
10000
10000
11111
00000
00000`,

	'Ж': `
00000
00000
00000
10101
10101
01110
10101
10101
10101
10101
00000
00000`,
	'З': `
00000
00000
00000
11110
00001
01110
00001
00001
00001
11110
00000
00000`,
	'И': `
00000
00000
00000
10001
10011
10101
11001
10001
10001
10001
00000
00000`,
	'Й': `
00010
00100
00000
10001
10011
10101
11001
10001
10001
10001
00000
00000`,
	'К': `
00000
00000
00000
10001
10010
10100
11000
10100
10010
10001
00000
00000`,
	'Л': `
00000
00000
00000
00001
00001
00011
00101
01001
10001
10001
00000
00000`,
	'М': `
00000
00000
00000
10001
11011
10101
10101
10001
10001
10001
00000
00000`,
	'Н': `
00000
00000
00000
10001
10001
11111
10001
10001
10001
10001
00000
00000`,
	'О': `
00000
00000
00000
01110
10001
10001
10001
10001
10001
01110
00000
00000`,
	'П': `
00000
00000
00000
11111
10001
10001
10001
10001
10001
10001
00000
00000`,
	'Р': `
00000
00000
00000
11110
10001
10001
11110
10000
10000
10000
00000
00000`,
	'С': `
00000
00000
00000
01111
10000
10000
10000
10000
10000
01111
00000
00000`,
	'Т': `
00000
00000
00000
11111
00100
00100
00100
00100
00100
00100
00000
00000`,
	'У': `
00000
00000
00000
10001
10001
10001
01111
00001
00001
11110
00000
00000`,
	'Ф': `
00000
00000
00000
01110
10101
10101
10101
01110
00100
00100
00000
00000`,
	'Х': `
00000
00000
00000
10001
10001
01010
00100
01010
10001
10001
00000
00000`,
	'Ц': `
00000
00000
00000
10010
10010
10010
10010
10010
10010
11111
00001
00000`,
	'Ч': `
00000
00000
00000
10001
10001
10001
01111
00001
00001
00001
00000
00000`,
	'Ш': `
00000
00000
00000
10001
10001
10001
10001
10101
10101
11111
00000
00000`,
	'Щ': `
00000
00000
00000
10001
10001
10001
10001
10101
10101
11111
00001
00010`,
	'Ъ': `
00000
00000
00000
11000
01000
01110
01001
01001
01001
01110
00000
00000`,
	'Ы': `
00000
00000
00000
10001
10001
11001
10101
10101
10101
11001
00000
00000`,
	'Ь': `
00000
00000
00000
10000
10000
11110
10001
10001
10001
11110
00000
00000`,
	'Э': `
00000
00000
00000
11110
00001
00001
11111
00001
00001
11110
00000
00000`,
	'Ю': `
00000
00000
00000
10010
10101
10101
11101
10101
10101
10010
00000
00000`,
	'Я': `
00000
00000
00000
01111
10001
10001
01111
00101
01001
10001
00000
00000`,
	'а': `
00000
00000
00000
00000
00000
01110
00001
01111
10011
01101
00000
00000`,
	'б': `
00000
00000
00000
00001
01110
10000
11110
10001
10001
01110
00000
00000`,
	'в': `
00000
00000
00000
00000
00000
11110
10001
11110
10001
11110
00000
00000`,
	'г': `
00000
00000
00000
00000
00000
11111
10000
10000
10000
10000
00000
00000`,
	'д': `
00000
00000
00000
00000
00000
00111
00101
00101
01001
11111
10001
00000`,
	'е': `
00000
00000
00000
00000
00000
01110
10001
11111
10000
01110
00000
00000`,
	'ё': `
00000
00000
00000
01010
00000
01110
10001
11111
10000
01110
00000
00000`,
	'ж': `
00000
00000
00000
00000
00000
10101
10101
01110
10101
10101
00000
00000`,
	'з': `
00000
00000
00000
00000
00000
11110
00001
01110
00001
11110
00000
00000`,
	'и': `
00000
00000
00000
00000
00000
10001
10011
10101
11001
10001
00000
00000`,
	'й': `
00000
00000
00010
00100
00000
10001
10011
10101
11001
10001
00000
00000`,
	'к': `
00000
00000
00000
00000
00000
10001
10010
11100
10010
10001
00000
00000`,
	'л': `
00000
00000
00000
00000
00000
00001
00011
00101
01001
10001
00000
00000`,
	'м': `
00000
00000
00000
00000
00000
10001
11011
10101
10001
10001
00000
00000`,
	'н': `
00000
00000
00000
00000
00000
10001
10001
11111
10001
10001
00000
00000`,
	'о': `
00000
00000
00000
00000
00000
01110
10001
10001
10001
01110
00000
00000`,
	'п': `
00000
00000
00000
00000
00000
11111
10001
10001
10001
10001
00000
00000`,
	'р': `
00000
00000
00000
00000
00000
11110
10001
10001
10001
11110
10000
10000`,
	'с': `
00000
00000
00000
00000
00000
01111
10000
10000
10000
01111
00000
00000`,
	'т': `
00000
00000
00000
00000
00000
11111
00100
00100
00100
00100
00000
00000`,
	'у': `
00000
00000
00000
00000
00000
10001
10001
10001
01111
00001
00001
11110`,
	'ф': `
00000
00000
00000
00000
00000
01110
10101
10101
10101
01110
00100
00100`,
	'х': `
00000
00000
00000
00000
00000
10001
01010
00100
01010
10001
00000
00000`,
	'ц': `
00000
00000
00000
00000
00000
10010
10010
10010
10010
11111
00001
00000`,
	'ч': `
00000
00000
00000
00000
00000
10001
10001
01111
00001
00001
00000
00000`,
	'ш': `
00000
00000
00000
00000
00000
10001
10001
10101
10101
11111
00000
00000`,
	'щ': `
00000
00000
00000
00000
00000
10001
10001
10101
10101
11111
00001
00000`,
	'ъ': `
00000
00000
00000
00000
00000
11000
01000
01110
01001
01110
00000
00000`,
	'ы': `
00000
00000
00000
00000
00000
10001
10001
11001
10101
11001
00000
00000`,
	'ь': `
00000
00000
00000
00000
00000
10000
10000
11110
10001
11110
00000
00000`,
	'э': `
00000
00000
00000
00000
00000
11110
00001
11111
00001
11110
00000
00000`,
	'ю': `
00000
00000
00000
00000
00000
10010
10101
11101
10101
10010
00000
00000`,
	'я': `
00000
00000
00000
00000
00000
01111
10001
01111
01001
10001
00000
00000`,
	'☺': `
00000
00000
00000
00000
00000
01110
10101
11111
10001
01110
00000
00000`
}

</script>
<script>
'use strict';

/**
 * Seedable random number generator functions.
 * @version 1.0.0
 * @license Public Domain
 *
 * @example
 * let rng = new RNG('Example');
 * rng.random(40, 50);  // =>  42
 * rng.uniform();       // =>  0.7972798995050903
 * rng.normal();        // => -0.6698504543216376
 * rng.exponential();   // =>  1.0547367609131555
 * rng.poisson(4);      // =>  2
 * rng.gamma(4);        // =>  2.781724687386858
 */

/**
 * Get the underlying bytes of this string.
 * @return {Array} An array of bytes
 */
String.prototype.getBytes = function() {
    let output = [];
    for (let i = 0; i < this.length; i++) {
        let c = this.charCodeAt(i);
        let bytes = [];
        do {
            bytes.push(c & 0xFF);
            c = c >> 8;
        } while (c > 0);
        output = output.concat(bytes.reverse());
    }
    return output;
};

/**
 * @param {String} seed A string to seed the generator.
 * @constructor
 */
function RC4(seed) {
    this.s = new Array(256);
    this.i = 0;
    this.j = 0;
    for (let i = 0; i < 256; i++) {
        this.s[i] = i;
    }
    if (seed) {
        this.mix(seed);
    }
}

RC4.prototype._swap = function(i, j) {
    let tmp = this.s[i];
    this.s[i] = this.s[j];
    this.s[j] = tmp;
};

/**
 * Mix additional entropy into this generator.
 * @param {String} seed
 */
RC4.prototype.mix = function(seed) {
    let input = seed.getBytes();
    let j = 0;
    for (let i = 0; i < this.s.length; i++) {
        j += this.s[i] + input[i % input.length];
        j %= 256;
        this._swap(i, j);
    }
};

/**
 * @return {number} The next byte of output from the generator.
 */
RC4.prototype.next = function() {
    this.i = (this.i + 1) % 256;
    this.j = (this.j + this.s[this.i]) % 256;
    this._swap(this.i, this.j);
    return this.s[(this.s[this.i] + this.s[this.j]) % 256];
};

function print_call_stack() {
  let e = new Error();
  let stack = e.stack;
  console.log( stack );
}
/**
 * Create a new random number generator with optional seed. If the
 * provided seed is a function (i.e. Math.random) it will be used as
 * the uniform number generator.
 * @param seed An arbitrary object used to seed the generator.
 * @constructor
 */
function RNG(seed) {
    this.seed = seed;
    if (seed == null) {
        seed = (Math.random() + Date.now()).toString();
        //window.console.log("setting random seed "+seed); 
        //print_call_stack();  

    } else if (typeof seed === 'function') {
        // Use it as a uniform number generator
        this.uniform = seed;
        this.nextByte = function() {
            return ~~(this.uniform() * 256);
        };
        seed = null;
    } else if (Object.prototype.toString.call(seed) !== '[object String]') {
        seed = JSON.stringify(seed);
    } else {
        //window.console.log("setting seed "+seed);
        //print_call_stack();
    }
    this._normal = null;
    if (seed) {
        this._state = new RC4(seed);
    } else {
        this._state = null;
    }
}

/**
 * @return {number} Uniform random number between 0 and 255.
 */
RNG.prototype.nextByte = function() {
    return this._state.next();
};

/**
 * @return {number} Uniform random number between 0 and 1.
 */
RNG.prototype.uniform = function() {
    let BYTES = 7; // 56 bits to make a 53-bit double
    let output = 0;
    for (let i = 0; i < BYTES; i++) {
        output *= 256;
        output += this.nextByte();
    }
    return output / (Math.pow(2, BYTES * 8) - 1);
};

/**
 * Produce a random integer within [n, m).
 * @param {number} [n=0]
 * @param {number} m
 *
 */
RNG.prototype.random = function(n, m) {
    if (n == null) {
        return this.uniform();
    } else if (m == null) {
        m = n;
        n = 0;
    }
    return n + Math.floor(this.uniform() * (m - n));
};

/**
 * Generates numbers using this.uniform() with the Box-Muller transform.
 * @return {number} Normally-distributed random number of mean 0, variance 1.
 */
RNG.prototype.normal = function() {
    if (this._normal !== null) {
        let n = this._normal;
        this._normal = null;
        return n;
    } else {
        let x = this.uniform() || Math.pow(2, -53); // can't be exactly 0
        let y = this.uniform();
        this._normal = Math.sqrt(-2 * Math.log(x)) * Math.sin(2 * Math.PI * y);
        return Math.sqrt(-2 * Math.log(x)) * Math.cos(2 * Math.PI * y);
    }
};

/**
 * Generates numbers using this.uniform().
 * @return {number} Number from the exponential distribution, lambda = 1.
 */
RNG.prototype.exponential = function() {
    return -Math.log(this.uniform() || Math.pow(2, -53));
};

/**
 * Generates numbers using this.uniform() and Knuth's method.
 * @param {number} [mean=1]
 * @return {number} Number from the Poisson distribution.
 */
RNG.prototype.poisson = function(mean) {
    let L = Math.exp(-(mean || 1));
    let k = 0, p = 1;
    do {
        k++;
        p *= this.uniform();
    } while (p > L);
    return k - 1;
};

/**
 * Generates numbers using this.uniform(), this.normal(),
 * this.exponential(), and the Marsaglia-Tsang method.
 * @param {number} a
 * @return {number} Number from the gamma distribution.
 */
RNG.prototype.gamma = function(a) {
    let d = (a < 1 ? 1 + a : a) - 1 / 3;
    let c = 1 / Math.sqrt(9 * d);
    do {
        do {
            let x = this.normal();
            let v = Math.pow(c * x + 1, 3);
        } while (v <= 0);
        let u = this.uniform();
        let x2 = Math.pow(x, 2);
    } while (u >= 1 - 0.0331 * x2 * x2 &&
             Math.log(u) >= 0.5 * x2 + d * (1 - v + Math.log(v)));
    if (a < 1) {
        return d * v * Math.exp(this.exponential() / -a);
    } else {
        return d * v;
    }
};

/**
 * Accepts a dice rolling notation string and returns a generator
 * function for that distribution. The parser is quite flexible.
 * @param {string} expr A dice-rolling, expression i.e. '2d6+10'.
 * @param {RNG} rng An optional RNG object.
 * @return {Function}
 */
RNG.roller = function(expr, rng) {
    let parts = expr.split(/(\d+)?d(\d+)([+-]\d+)?/).slice(1);
    let dice = parseFloat(parts[0]) || 1;
    let sides = parseFloat(parts[1]);
    let mod = parseFloat(parts[2]) || 0;
    rng = rng || new RNG();
    return function() {
        let total = dice + mod;
        for (let i = 0; i < dice; i++) {
            total += rng.random(sides);
        }
        return total;
    };
};
</script>
<script>
/*
 * RIFFWAVE.js v0.02 - Audio encoder for HTML5 <audio> elements.
 * Copyright (C) 2011 Pedro Ladaria <pedro.ladaria at Gmail dot com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 * The full license is available at http://www.gnu.org/licenses/gpl.html
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 *
 * Changelog:
 *
 * 0.01 - First release
 * 0.02 - New faster base64 encoding
 *
 */

var FastBase64_chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
var FastBase64_encLookup = [];

function FastBase64_Init() {
  for (var i = 0; i < 4096; i++) {
    FastBase64_encLookup[i] = FastBase64_chars[i >> 6] + FastBase64_chars[i & 0x3F];
  }
}

function FastBase64_Encode(src) {
  var len = src.length;
  var dst = '';
  var i = 0;
  while (len > 2) {
    n = (src[i] << 16) | (src[i + 1] << 8) | src[i + 2];
    dst += FastBase64_encLookup[n >> 12] + FastBase64_encLookup[n & 0xFFF];
    len -= 3;
    i += 3;
  }
  if (len > 0) {
    var n1 = (src[i] & 0xFC) >> 2;
    var n2 = (src[i] & 0x03) << 4;
    if (len > 1) n2 |= (src[++i] & 0xF0) >> 4;
    dst += FastBase64_chars[n1];
    dst += FastBase64_chars[n2];
    if (len == 2) {
      var n3 = (src[i++] & 0x0F) << 2;
      n3 |= (src[i] & 0xC0) >> 6;
      dst += FastBase64_chars[n3];
    }
    if (len == 1) dst += '=';
    dst += '=';
  }
  return dst;
} // end Encode

FastBase64_Init();

function u32ToArray(i) { return [i & 0xFF, (i >> 8) & 0xFF, (i >> 16) & 0xFF, (i >> 24) & 0xFF]; }

function u16ToArray(i) { return [i & 0xFF, (i >> 8) & 0xFF]; }

function MakeRiff ( sampleRate, bitsPerSample,data) {
  var dat = [];
  var wav=[];
  var dataURI=[];

  var header = {                         // OFFS SIZE NOTES
    chunkId: [0x52, 0x49, 0x46, 0x46], // 0    4    "RIFF" = 0x52494646
    chunkSize: 0,                     // 4    4    36+SubChunk2Size = 4+(8+SubChunk1Size)+(8+SubChunk2Size)
    format: [0x57, 0x41, 0x56, 0x45], // 8    4    "WAVE" = 0x57415645
    subChunk1Id: [0x66, 0x6d, 0x74, 0x20], // 12   4    "fmt " = 0x666d7420
    subChunk1Size: 16,                    // 16   4    16 for PCM
    audioFormat: 1,                     // 20   2    PCM = 1
    numChannels: 1,                     // 22   2    Mono = 1, Stereo = 2, etc.
    sampleRate: sampleRate,                  // 24   4    8000, 44100, etc
    byteRate: 0,                     // 28   4    SampleRate*NumChannels*BitsPerSample/8
    blockAlign: 0,                     // 32   2    NumChannels*BitsPerSample/8
    bitsPerSample: bitsPerSample,                     // 34   2    8 bits = 8, 16 bits = 16, etc...
    subChunk2Id: [0x64, 0x61, 0x74, 0x61], // 36   4    "data" = 0x64617461
    subChunk2Size: 0                      // 40   4    data size = NumSamples*NumChannels*BitsPerSample/8
  };

  header.byteRate = (header.sampleRate * header.numChannels * header.bitsPerSample) >> 3;
  header.blockAlign = (header.numChannels * header.bitsPerSample) >> 3;
  header.subChunk2Size = data.length;
  header.chunkSize = 36 + header.subChunk2Size;

  wav = header.chunkId.concat(
      u32ToArray(header.chunkSize),
      header.format,
      header.subChunk1Id,
      u32ToArray(header.subChunk1Size),
      u16ToArray(header.audioFormat),
      u16ToArray(header.numChannels),
      u32ToArray(header.sampleRate),
      u32ToArray(header.byteRate),
      u16ToArray(header.blockAlign),
      u16ToArray(header.bitsPerSample),
      header.subChunk2Id,
      u32ToArray(header.subChunk2Size),
      data
    );
    
    dataURI = 'data:audio/wav;base64,' + FastBase64_Encode(wav);

    var result = {
      dat:dat,
      wav:wav,
      header:header,
      dataURI:dataURI
    };

    return result;
}


if (typeof exports != 'undefined')  // For node.js
  exports.RIFFWAVE = RIFFWAVE;

</script>
<script>
'use strict';

const SOUND_VOL = 0.25;
const SAMPLE_RATE = 5512;
const BIT_DEPTH = 8;

const SQUARE = 0;
const SAWTOOTH = 1;
const SINE = 2;
const NOISE = 3;
const TRIANGLE = 4;
const BREAKER = 5;

const SHAPES = [
  'square', 'sawtooth', 'sine', 'noise', 'triangle', 'breaker'
];

let AUDIO_CONTEXT;

function checkAudioContextExists(){
  try{
    if (AUDIO_CONTEXT==null){
      if (typeof AudioContext != 'undefined') {
        AUDIO_CONTEXT = new AudioContext();
      } else if (typeof webkitAudioContext != 'undefined') {
        AUDIO_CONTEXT = new webkitAudioContext();
      }
    }
  }
  catch (ex){
    window.console.log(ex)
  }
}

checkAudioContextExists();

// Playback volume
let masterVolume = 1.0;

// Sound generation parameters are on [0,1] unless noted SIGNED, & thus [-1,1]
function Params() {
  const result={};
  // Wave shape
  result.wave_type = SQUARE;

  // Envelope
  result.p_env_attack = 0.0;   // Attack time
  result.p_env_sustain = 0.3;  // Sustain time
  result.p_env_punch = 0.0;    // Sustain punch
  result.p_env_decay = 0.4;    // Decay time

  // Tone
  result.p_base_freq = 0.3;    // Start frequency
  result.p_freq_limit = 0.0;   // Min frequency cutoff
  result.p_freq_ramp = 0.0;    // Slide (SIGNED)
  result.p_freq_dramp = 0.0;   // Delta slide (SIGNED)
  // Vibrato
  result.p_vib_strength = 0.0; // Vibrato depth
  result.p_vib_speed = 0.0;    // Vibrato speed

  // Tonal change
  result.p_arp_mod = 0.0;      // Change amount (SIGNED)
  result.p_arp_speed = 0.0;    // Change speed

  // Duty (wat's that?)
  result.p_duty = 0.0;         // Square duty
  result.p_duty_ramp = 0.0;    // Duty sweep (SIGNED)

  // Repeat
  result.p_repeat_speed = 0.0; // Repeat speed

  // Phaser
  result.p_pha_offset = 0.0;   // Phaser offset (SIGNED)
  result.p_pha_ramp = 0.0;     // Phaser sweep (SIGNED)

  // Low-pass filter
  result.p_lpf_freq = 1.0;     // Low-pass filter cutoff
  result.p_lpf_ramp = 0.0;     // Low-pass filter cutoff sweep (SIGNED)
  result.p_lpf_resonance = 0.0;// Low-pass filter resonance
  // High-pass filter
  result.p_hpf_freq = 0.0;     // High-pass filter cutoff
  result.p_hpf_ramp = 0.0;     // High-pass filter cutoff sweep (SIGNED)

  // Sample parameters
  result.sound_vol = 0.5;
  result.sample_rate = 44100;
  result.bit_depth = 8;
  return result;
}

let rng;
let seeded = false;
function frnd(range) {
  if (seeded) {
    return rng.uniform() * range;
  } else {
    return Math.random() * range;
  }
}


function rnd(max) {
  if (seeded) {
  return Math.floor(rng.uniform() * (max + 1));
  } else {
    return Math.floor(Math.random() * (max + 1));
  }
}


function pickupCoin() {
  const result=Params();
  result.wave_type = Math.floor(frnd(SHAPES.length));
  if (result.wave_type === 3) {
    result.wave_type = 0;
  }
  result.p_base_freq = 0.4 + frnd(0.5);
  result.p_env_attack = 0.0;
  result.p_env_sustain = frnd(0.1);
  result.p_env_decay = 0.1 + frnd(0.4);
  result.p_env_punch = 0.3 + frnd(0.3);
  if (rnd(1)) {
    result.p_arp_speed = 0.5 + frnd(0.2);
    let num = (frnd(7) | 1) + 1;
    let den = num + (frnd(7) | 1) + 2;
    result.p_arp_mod = (+num) / (+den); //0.2 + frnd(0.4);
  }
  return result;
};


function laserShoot() {
  const result=Params();
  result.wave_type = rnd(2);
  if (result.wave_type === SINE && rnd(1))
    result.wave_type = rnd(1);
  result.wave_type = Math.floor(frnd(SHAPES.length));

  if (result.wave_type === 3) {
    result.wave_type = SQUARE;
  }

  result.p_base_freq = 0.5 + frnd(0.5);
  result.p_freq_limit = result.p_base_freq - 0.2 - frnd(0.6);
  if (result.p_freq_limit < 0.2) result.p_freq_limit = 0.2;
  result.p_freq_ramp = -0.15 - frnd(0.2);
  if (rnd(2) === 0)
  {
    result.p_base_freq = 0.3 + frnd(0.6);
    result.p_freq_limit = frnd(0.1);
    result.p_freq_ramp = -0.35 - frnd(0.3);
  }
  if (rnd(1))
  {
    result.p_duty = frnd(0.5);
    result.p_duty_ramp = frnd(0.2);
  }
  else
  {
    result.p_duty = 0.4 + frnd(0.5);
    result.p_duty_ramp = -frnd(0.7);
  }
  result.p_env_attack = 0.0;
  result.p_env_sustain = 0.1 + frnd(0.2);
  result.p_env_decay = frnd(0.4);
  if (rnd(1))
    result.p_env_punch = frnd(0.3);
  if (rnd(2) === 0)
  {
    result.p_pha_offset = frnd(0.2);
    result.p_pha_ramp = -frnd(0.2);
  }
  if (rnd(1))
    result.p_hpf_freq = frnd(0.3);

  return result;
};

function explosion() {
  const result=Params();

  if (rnd(1)) {
    result.p_base_freq = 0.1 + frnd(0.4);
    result.p_freq_ramp = -0.1 + frnd(0.4);
  } else {
    result.p_base_freq = 0.2 + frnd(0.7);
    result.p_freq_ramp = -0.2 - frnd(0.2);
  }
  result.p_base_freq *= result.p_base_freq;
  if (rnd(4) === 0)
    result.p_freq_ramp = 0.0;
  if (rnd(2) === 0)
    result.p_repeat_speed = 0.3 + frnd(0.5);
  result.p_env_attack = 0.0;
  result.p_env_sustain = 0.1 + frnd(0.3);
  result.p_env_decay = frnd(0.5);
  if (rnd(1) === 0) {
    result.p_pha_offset = -0.3 + frnd(0.9);
    result.p_pha_ramp = -frnd(0.3);
  }
  result.p_env_punch = 0.2 + frnd(0.6);
  if (rnd(1)) {
    result.p_vib_strength = frnd(0.7);
    result.p_vib_speed = frnd(0.6);
  }
  if (rnd(2) === 0) {
    result.p_arp_speed = 0.6 + frnd(0.3);
    result.p_arp_mod = 0.8 - frnd(1.6);
  }

  return result;
};
//9675111
function birdSound() {
  const result=Params();

if (frnd(10) < 1) {
    result.wave_type = Math.floor(frnd(SHAPES.length));
    if (result.wave_type === 3) {
      result.wave_type = SQUARE;
    }
result.p_env_attack = 0.4304400932967592 + frnd(0.2) - 0.1;
result.p_env_sustain = 0.15739346034252394 + frnd(0.2) - 0.1;
result.p_env_punch = 0.004488201744871758 + frnd(0.2) - 0.1;
result.p_env_decay = 0.07478075528212291 + frnd(0.2) - 0.1;
result.p_base_freq = 0.9865265720147687 + frnd(0.2) - 0.1;
result.p_freq_limit = 0 + frnd(0.2) - 0.1;
result.p_freq_ramp = -0.2995018224359539 + frnd(0.2) - 0.1;
if (frnd(1.0) < 0.5) {
  result.p_freq_ramp = 0.1 + frnd(0.15);
}
result.p_freq_dramp = 0.004598608156964473 + frnd(0.1) - 0.05;
result.p_vib_strength = -0.2202799497929496 + frnd(0.2) - 0.1;
result.p_vib_speed = 0.8084998703158364 + frnd(0.2) - 0.1;
result.p_arp_mod = 0;//-0.46410459213693644+frnd(0.2)-0.1;
result.p_arp_speed = 0;//-0.10955361249587248+frnd(0.2)-0.1;
result.p_duty = -0.9031808754347107 + frnd(0.2) - 0.1;
result.p_duty_ramp = -0.8128699999808343 + frnd(0.2) - 0.1;
result.p_repeat_speed = 0.6014860189319991 + frnd(0.2) - 0.1;
result.p_pha_offset = -0.9424902314367765 + frnd(0.2) - 0.1;
result.p_pha_ramp = -0.1055482222272056 + frnd(0.2) - 0.1;
result.p_lpf_freq = 0.9989765717851521 + frnd(0.2) - 0.1;
result.p_lpf_ramp = -0.25051720626043017 + frnd(0.2) - 0.1;
result.p_lpf_resonance = 0.32777871505494693 + frnd(0.2) - 0.1;
result.p_hpf_freq = 0.0023548750981756753 + frnd(0.2) - 0.1;
result.p_hpf_ramp = -0.002375673204842568 + frnd(0.2) - 0.1;
return result;
}

if (frnd(10) < 1) {
    result.wave_type = Math.floor(frnd(SHAPES.length));
    if (result.wave_type === 3) {
      result.wave_type = SQUARE;
    }
result.p_env_attack = 0.5277795946672003 + frnd(0.2) - 0.1;
result.p_env_sustain = 0.18243733568468432 + frnd(0.2) - 0.1;
result.p_env_punch = -0.020159754546840117 + frnd(0.2) - 0.1;
result.p_env_decay = 0.1561353422051903 + frnd(0.2) - 0.1;
result.p_base_freq = 0.9028855606533718 + frnd(0.2) - 0.1;
result.p_freq_limit = -0.008842787837148716;
result.p_freq_ramp = -0.1;
result.p_freq_dramp = -0.012891241489551925;
result.p_vib_strength = -0.17923136138403065 + frnd(0.2) - 0.1;
result.p_vib_speed = 0.908263385610142 + frnd(0.2) - 0.1;
result.p_arp_mod = 0.41690153355414894 + frnd(0.2) - 0.1;
result.p_arp_speed = 0.0010766233195860703 + frnd(0.2) - 0.1;
result.p_duty = -0.8735363011184684 + frnd(0.2) - 0.1;
result.p_duty_ramp = -0.7397985366747507 + frnd(0.2) - 0.1;
result.p_repeat_speed = 0.0591789344172107 + frnd(0.2) - 0.1;
result.p_pha_offset = -0.9961184222777699 + frnd(0.2) - 0.1;
result.p_pha_ramp = -0.08234769395850523 + frnd(0.2) - 0.1;
result.p_lpf_freq = 0.9412475115697335 + frnd(0.2) - 0.1;
result.p_lpf_ramp = -0.18261358925834958 + frnd(0.2) - 0.1;
result.p_lpf_resonance = 0.24541438107389477 + frnd(0.2) - 0.1;
result.p_hpf_freq = -0.01831940280978611 + frnd(0.2) - 0.1;
result.p_hpf_ramp = -0.03857383633171346 + frnd(0.2) - 0.1;
return result;

}
  if (frnd(10) < 1) {
//result.wave_type = 4;
    result.wave_type = Math.floor(frnd(SHAPES.length));

    if (result.wave_type === 3) {
      result.wave_type = SQUARE;
    }
result.p_env_attack = 0.4304400932967592 + frnd(0.2) - 0.1;
result.p_env_sustain = 0.15739346034252394 + frnd(0.2) - 0.1;
result.p_env_punch = 0.004488201744871758 + frnd(0.2) - 0.1;
result.p_env_decay = 0.07478075528212291 + frnd(0.2) - 0.1;
result.p_base_freq = 0.9865265720147687 + frnd(0.2) - 0.1;
result.p_freq_limit = 0 + frnd(0.2) - 0.1;
result.p_freq_ramp = -0.2995018224359539 + frnd(0.2) - 0.1;
result.p_freq_dramp = 0.004598608156964473 + frnd(0.2) - 0.1;
result.p_vib_strength = -0.2202799497929496 + frnd(0.2) - 0.1;
result.p_vib_speed = 0.8084998703158364 + frnd(0.2) - 0.1;
result.p_arp_mod = -0.46410459213693644 + frnd(0.2) - 0.1;
result.p_arp_speed = -0.10955361249587248 + frnd(0.2) - 0.1;
result.p_duty = -0.9031808754347107 + frnd(0.2) - 0.1;
result.p_duty_ramp = -0.8128699999808343 + frnd(0.2) - 0.1;
result.p_repeat_speed = 0.7014860189319991 + frnd(0.2) - 0.1;
result.p_pha_offset = -0.9424902314367765 + frnd(0.2) - 0.1;
result.p_pha_ramp = -0.1055482222272056 + frnd(0.2) - 0.1;
result.p_lpf_freq = 0.9989765717851521 + frnd(0.2) - 0.1;
result.p_lpf_ramp = -0.25051720626043017 + frnd(0.2) - 0.1;
result.p_lpf_resonance = 0.32777871505494693 + frnd(0.2) - 0.1;
result.p_hpf_freq = 0.0023548750981756753 + frnd(0.2) - 0.1;
result.p_hpf_ramp = -0.002375673204842568 + frnd(0.2) - 0.1;
return result;
}
  if (frnd(5) > 1) {
    result.wave_type = Math.floor(frnd(SHAPES.length));

    if (result.wave_type === 3) {
      result.wave_type = SQUARE;
    }
    if (rnd(1)) {
      result.p_arp_mod = 0.2697849293151393 + frnd(0.2) - 0.1;
      result.p_arp_speed = -0.3131172257760948 + frnd(0.2) - 0.1;
      result.p_base_freq = 0.8090588299313949 + frnd(0.2) - 0.1;
      result.p_duty = -0.6210022920964955 + frnd(0.2) - 0.1;
      result.p_duty_ramp = -0.00043441813553182567 + frnd(0.2) - 0.1;
      result.p_env_attack = 0.004321877246874195 + frnd(0.2) - 0.1;
      result.p_env_decay = 0.1 + frnd(0.2) - 0.1;
      result.p_env_punch = 0.061737781504416146 + frnd(0.2) - 0.1;
      result.p_env_sustain = 0.4987252564798832 + frnd(0.2) - 0.1;
      result.p_freq_dramp = 0.31700340314222614 + frnd(0.2) - 0.1;
      result.p_freq_limit = 0 + frnd(0.2) - 0.1;
      result.p_freq_ramp = -0.163380391341416 + frnd(0.2) - 0.1;
      result.p_hpf_freq = 0.4709005021145149 + frnd(0.2) - 0.1;
      result.p_hpf_ramp = 0.6924667290539194 + frnd(0.2) - 0.1;
      result.p_lpf_freq = 0.8351398631384511 + frnd(0.2) - 0.1;
      result.p_lpf_ramp = 0.36616557192873134 + frnd(0.2) - 0.1;
      result.p_lpf_resonance = -0.08685777111664439 + frnd(0.2) - 0.1;
      result.p_pha_offset = -0.036084571580025544 + frnd(0.2) - 0.1;
      result.p_pha_ramp = -0.014806445085568108 + frnd(0.2) - 0.1;
      result.p_repeat_speed = -0.8094368475518489 + frnd(0.2) - 0.1;
      result.p_vib_speed = 0.4496665457171294 + frnd(0.2) - 0.1;
      result.p_vib_strength = 0.23413762515532424 + frnd(0.2) - 0.1;
    } else {
      result.p_arp_mod = -0.35697118026766184 + frnd(0.2) - 0.1;
      result.p_arp_speed = 0.3581140690559588 + frnd(0.2) - 0.1;
      result.p_base_freq = 1.3260897696157528 + frnd(0.2) - 0.1;
      result.p_duty = -0.30984900436710694 + frnd(0.2) - 0.1;
      result.p_duty_ramp = -0.0014374759133411626 + frnd(0.2) - 0.1;
      result.p_env_attack = 0.3160357835682254 + frnd(0.2) - 0.1;
      result.p_env_decay = 0.1 + frnd(0.2) - 0.1;
      result.p_env_punch = 0.24323114016870148 + frnd(0.2) - 0.1;
      result.p_env_sustain = 0.4 + frnd(0.2) - 0.1;
      result.p_freq_dramp = 0.2866475886237244 + frnd(0.2) - 0.1;
      result.p_freq_limit = 0 + frnd(0.2) - 0.1;
      result.p_freq_ramp = -0.10956352368742976 + frnd(0.2) - 0.1;
      result.p_hpf_freq = 0.20772718017889846 + frnd(0.2) - 0.1;
      result.p_hpf_ramp = 0.1564090637378835 + frnd(0.2) - 0.1;
      result.p_lpf_freq = 0.6021372770637031 + frnd(0.2) - 0.1;
      result.p_lpf_ramp = 0.24016227139979027 + frnd(0.2) - 0.1;
      result.p_lpf_resonance = -0.08787383821160144 + frnd(0.2) - 0.1;
      result.p_pha_offset = -0.381597686151701 + frnd(0.2) - 0.1;
      result.p_pha_ramp = -0.0002481687661373495 + frnd(0.2) - 0.1;
      result.p_repeat_speed = 0.07812112809425686 + frnd(0.2) - 0.1;
      result.p_vib_speed = -0.13648848579133943 + frnd(0.2) - 0.1;
      result.p_vib_strength = 0.0018874158972302657 + frnd(0.2) - 0.1;
    }
    return result;

  }

  result.wave_type = Math.floor(frnd(SHAPES.length));//TRIANGLE;
  if (result.wave_type === 1 || result.wave_type === 3) {
    result.wave_type = 2;
  }
  //new
  result.p_base_freq = 0.85 + frnd(0.15);
  result.p_freq_ramp = 0.3 + frnd(0.15);
//  result.p_freq_dramp = 0.3+frnd(2.0);

  result.p_env_attack = 0 + frnd(0.09);
  result.p_env_sustain = 0.2 + frnd(0.3);
  result.p_env_decay = 0 + frnd(0.1);

  result.p_duty = frnd(2.0) - 1.0;
  result.p_duty_ramp = Math.pow(frnd(2.0) - 1.0, 3.0);


  result.p_repeat_speed = 0.5 + frnd(0.1);

  result.p_pha_offset = -0.3 + frnd(0.9);
  result.p_pha_ramp = -frnd(0.3);

  result.p_arp_speed = 0.4 + frnd(0.6);
  result.p_arp_mod = 0.8 + frnd(0.1);


  result.p_lpf_resonance = frnd(2.0) - 1.0;
  result.p_lpf_freq = 1.0 - Math.pow(frnd(1.0), 3.0);
  result.p_lpf_ramp = Math.pow(frnd(2.0) - 1.0, 3.0);
  if (result.p_lpf_freq < 0.1 && result.p_lpf_ramp < -0.05)
    result.p_lpf_ramp = -result.p_lpf_ramp;
  result.p_hpf_freq = Math.pow(frnd(1.0), 5.0);
  result.p_hpf_ramp = Math.pow(frnd(2.0) - 1.0, 5.0);

  return result;
};


function pushSound() {
  const result=Params();
  result.wave_type = Math.floor(frnd(SHAPES.length));//TRIANGLE;
  if (result.wave_type === 2) {
    result.wave_type++;
  }
  if (result.wave_type === 0) {
    result.wave_type = NOISE;
  }
  //new
  result.p_base_freq = 0.1 + frnd(0.4);
  result.p_freq_ramp = 0.05 + frnd(0.2);

  result.p_env_attack = 0.01 + frnd(0.09);
  result.p_env_sustain = 0.01 + frnd(0.09);
  result.p_env_decay = 0.01 + frnd(0.09);

  result.p_repeat_speed = 0.3 + frnd(0.5);
  result.p_pha_offset = -0.3 + frnd(0.9);
  result.p_pha_ramp = -frnd(0.3);
  result.p_arp_speed = 0.6 + frnd(0.3);
  result.p_arp_mod = 0.8 - frnd(1.6);

  return result;
};



function powerUp() {
  const result=Params();
  if (rnd(1))
    result.wave_type = SAWTOOTH;
  else
    result.p_duty = frnd(0.6);
  result.wave_type = Math.floor(frnd(SHAPES.length));
  if (result.wave_type === 3) {
    result.wave_type = SQUARE;
  }
  if (rnd(1))
  {
    result.p_base_freq = 0.2 + frnd(0.3);
    result.p_freq_ramp = 0.1 + frnd(0.4);
    result.p_repeat_speed = 0.4 + frnd(0.4);
  }
  else
  {
    result.p_base_freq = 0.2 + frnd(0.3);
    result.p_freq_ramp = 0.05 + frnd(0.2);
    if (rnd(1))
    {
      result.p_vib_strength = frnd(0.7);
      result.p_vib_speed = frnd(0.6);
    }
  }
  result.p_env_attack = 0.0;
  result.p_env_sustain = frnd(0.4);
  result.p_env_decay = 0.1 + frnd(0.4);

  return result;
};

function hitHurt() {
  const result = Params();
  result.wave_type = rnd(2);
  if (result.wave_type === SINE)
    result.wave_type = NOISE;
  if (result.wave_type === SQUARE)
    result.p_duty = frnd(0.6);
  result.wave_type = Math.floor(frnd(SHAPES.length));
  result.p_base_freq = 0.2 + frnd(0.6);
  result.p_freq_ramp = -0.3 - frnd(0.4);
  result.p_env_attack = 0.0;
  result.p_env_sustain = frnd(0.1);
  result.p_env_decay = 0.1 + frnd(0.2);
  if (rnd(1))
    result.p_hpf_freq = frnd(0.3);
  return result;
};


function jump() {
  const result = Params();
  result.wave_type = SQUARE;
  result.wave_type = Math.floor(frnd(SHAPES.length));
  if (result.wave_type === 3) {
    result.wave_type = SQUARE;
  }
  result.p_duty = frnd(0.6);
  result.p_base_freq = 0.3 + frnd(0.3);
  result.p_freq_ramp = 0.1 + frnd(0.2);
  result.p_env_attack = 0.0;
  result.p_env_sustain = 0.1 + frnd(0.3);
  result.p_env_decay = 0.1 + frnd(0.2);
  if (rnd(1))
    result.p_hpf_freq = frnd(0.3);
  if (rnd(1))
    result.p_lpf_freq = 1.0 - frnd(0.6);
  return result;
};

function blipSelect() {
  const result = Params();
  result.wave_type = rnd(1);
  result.wave_type = Math.floor(frnd(SHAPES.length));
  if (result.wave_type === 3) {
    result.wave_type = rnd(1);
  }
  if (result.wave_type === SQUARE)
    result.p_duty = frnd(0.6);
  result.p_base_freq = 0.2 + frnd(0.4);
  result.p_env_attack = 0.0;
  result.p_env_sustain = 0.1 + frnd(0.1);
  result.p_env_decay = frnd(0.2);
  result.p_hpf_freq = 0.1;
  return result;
};

function random() {
  const result = Params();
  result.wave_type = Math.floor(frnd(SHAPES.length));
  result.p_base_freq = Math.pow(frnd(2.0) - 1.0, 2.0);
  if (rnd(1))
    result.p_base_freq = Math.pow(frnd(2.0) - 1.0, 3.0) + 0.5;
  result.p_freq_limit = 0.0;
  result.p_freq_ramp = Math.pow(frnd(2.0) - 1.0, 5.0);
  if (result.p_base_freq > 0.7 && result.p_freq_ramp > 0.2)
    result.p_freq_ramp = -result.p_freq_ramp;
  if (result.p_base_freq < 0.2 && result.p_freq_ramp < -0.05)
    result.p_freq_ramp = -result.p_freq_ramp;
  result.p_freq_dramp = Math.pow(frnd(2.0) - 1.0, 3.0);
  result.p_duty = frnd(2.0) - 1.0;
  result.p_duty_ramp = Math.pow(frnd(2.0) - 1.0, 3.0);
  result.p_vib_strength = Math.pow(frnd(2.0) - 1.0, 3.0);
  result.p_vib_speed = frnd(2.0) - 1.0;
  result.p_env_attack = Math.pow(frnd(2.0) - 1.0, 3.0);
  result.p_env_sustain = Math.pow(frnd(2.0) - 1.0, 2.0);
  result.p_env_decay = frnd(2.0) - 1.0;
  result.p_env_punch = Math.pow(frnd(0.8), 2.0);
  if (result.p_env_attack + result.p_env_sustain + result.p_env_decay < 0.2) {
    result.p_env_sustain += 0.2 + frnd(0.3);
    result.p_env_decay += 0.2 + frnd(0.3);
  }
  result.p_lpf_resonance = frnd(2.0) - 1.0;
  result.p_lpf_freq = 1.0 - Math.pow(frnd(1.0), 3.0);
  result.p_lpf_ramp = Math.pow(frnd(2.0) - 1.0, 3.0);
  if (result.p_lpf_freq < 0.1 && result.p_lpf_ramp < -0.05)
    result.p_lpf_ramp = -result.p_lpf_ramp;
  result.p_hpf_freq = Math.pow(frnd(1.0), 5.0);
  result.p_hpf_ramp = Math.pow(frnd(2.0) - 1.0, 5.0);
  result.p_pha_offset = Math.pow(frnd(2.0) - 1.0, 3.0);
  result.p_pha_ramp = Math.pow(frnd(2.0) - 1.0, 3.0);
  result.p_repeat_speed = frnd(2.0) - 1.0;
  result.p_arp_speed = frnd(2.0) - 1.0;
  result.p_arp_mod = frnd(2.0) - 1.0;
  return result;
};

const generators = [
pickupCoin,
laserShoot,
explosion,
powerUp,
hitHurt,
jump,
blipSelect,
pushSound,
random,
birdSound
];

const generatorNames = [
'pickupCoin',
'laserShoot',
'explosion',
'powerUp',
'hitHurt',
'jump',
'blipSelect',
'pushSound',
'random',
'birdSound'
];

/*
i like 9675111
*/
function generateFromSeed(seed) {
  rng = new RNG((seed / 100) | 0);
  const generatorindex = seed % 100;
  const soundGenerator = generators[generatorindex % generators.length];
  seeded = true;
  const result = soundGenerator();
  result.seed = seed;
  seeded = false;
  return result;
};

function SoundEffect(length, sample_rate) {
  this._buffer = AUDIO_CONTEXT.createBuffer(1, length, sample_rate);
}

SoundEffect.prototype.getBuffer = function() {
  return this._buffer.getChannelData(0);
};


//unlock bullshit
function ULBS(){   
  if (AUDIO_CONTEXT.state === 'suspended')
  {
      const unlock = function()
      {
        AUDIO_CONTEXT.resume().then(function()
          {
            document.body.removeEventListener('touchstart', unlock);
            document.body.removeEventListener('touchend', unlock);
            document.body.removeEventListener('mousedown', unlock);
            document.body.removeEventListener('mouseup', unlock);
            document.body.removeEventListener('keydown', unlock);
            document.body.removeEventListener('keyup', unlock);
          });
      };

      document.body.addEventListener('touchstart', unlock, false);
      document.body.addEventListener('touchend', unlock, false);
      document.body.addEventListener('mousedown', unlock, false);
      document.body.addEventListener('mouseup', unlock, false);
      document.body.addEventListener('keydown', unlock, false);
      document.body.addEventListener('keyup', unlock, false);
  }
}

SoundEffect.prototype.play = function() {
  ULBS();

  const source = AUDIO_CONTEXT.createBufferSource();
  const filter1 = AUDIO_CONTEXT.createBiquadFilter();
  const filter2 = AUDIO_CONTEXT.createBiquadFilter();
  const filter3 = AUDIO_CONTEXT.createBiquadFilter();

  source.buffer = this._buffer;
  source.connect(filter1);

  filter1.frequency.value = 1600;
  filter2.frequency.value = 1600;
  filter3.frequency.value = 1600;

  filter1.connect(filter2);
  filter2.connect(filter3);
  filter3.connect(AUDIO_CONTEXT.destination);
  const t = AUDIO_CONTEXT.currentTime;
  if (typeof source.start != 'undefined') {
    source.start(t);
  } else {
    source.noteOn(t);
  }
  source.onended = function() {
    filter3.disconnect()
  }
};

SoundEffect.MIN_SAMPLE_RATE = 22050;

if (typeof AUDIO_CONTEXT == 'undefined') {
  SoundEffect = function SoundEffect(length, sample_rate) {
    this._sample_rate = sample_rate;
    this._buffer = new Array(length);
    this._audioElement = null;
  };

  SoundEffect.prototype.getBuffer = function() {
    this._audioElement = null;
    return this._buffer;
  };

  SoundEffect.prototype.play = function() {
    if (this._audioElement) {
      this._audioElement.cloneNode(false).play();
    } else {
      for (let i = 0; i < this._buffer.length; i++) {
        // bit_depth is always 8, rescale [-1.0, 1.0) to [0, 256)
        this._buffer[i] = 255 & Math.floor(128 * Math.max(0, Math.min(this._buffer[i] + 1, 2)));
      }
      let wav = MakeRiff(this._sample_rate, BIT_DEPTH, this._buffer);
      this._audioElement = new Audio();
      this._audioElement.src = wav.dataURI;
      this._audioElement.play();
    }
  };

  SoundEffect.MIN_SAMPLE_RATE = 1;
}

SoundEffect.generate = function(ps) {
/*  window.console.log(ps.wave_type + "\t" + ps.seed);

  let psstring="";
  for (let n in ps) {
    if (ps.hasOwnProperty(n)) {
      psstring = psstring +"result." + n+" = " + ps[n] + ";\n";
    }
  }
window.console.log(ps);
window.console.log(psstring);*/
  function repeat() {
    rep_time = 0;

    fperiod = 100.0 / (ps.p_base_freq * ps.p_base_freq + 0.001);
    period = Math.floor(fperiod);
    fmaxperiod = 100.0 / (ps.p_freq_limit * ps.p_freq_limit + 0.001);

    fslide = 1.0 - Math.pow(ps.p_freq_ramp, 3.0) * 0.01;
    fdslide = -Math.pow(ps.p_freq_dramp, 3.0) * 0.000001;

    square_duty = 0.5 - ps.p_duty * 0.5;
    square_slide = -ps.p_duty_ramp * 0.00005;

    if (ps.p_arp_mod >= 0.0)
      arp_mod = 1.0 - Math.pow(ps.p_arp_mod, 2.0) * 0.9;
    else
      arp_mod = 1.0 + Math.pow(ps.p_arp_mod, 2.0) * 10.0;
    arp_time = 0;
    arp_limit = Math.floor(Math.pow(1.0 - ps.p_arp_speed, 2.0) * 20000 + 32);
    if (ps.p_arp_speed == 1.0)
      arp_limit = 0;
  };

  let rep_time;
  let fperiod, period, fmaxperiod;
  let fslide, fdslide;
  let square_duty, square_slide;
  let arp_mod, arp_time, arp_limit;
  repeat();  // First time through, this is a bit of a misnomer

  // Filter
  let fltp = 0.0;
  let fltdp = 0.0;
  let fltw = Math.pow(ps.p_lpf_freq, 3.0) * 0.1;
  let fltw_d = 1.0 + ps.p_lpf_ramp * 0.0001;
  let fltdmp = 5.0 / (1.0 + Math.pow(ps.p_lpf_resonance, 2.0) * 20.0) *
    (0.01 + fltw);
  if (fltdmp > 0.8) fltdmp = 0.8;
  let fltphp = 0.0;
  let flthp = Math.pow(ps.p_hpf_freq, 2.0) * 0.1;
  let flthp_d = 1.0 + ps.p_hpf_ramp * 0.0003;

  // Vibrato
  let vib_phase = 0.0;
  let vib_speed = Math.pow(ps.p_vib_speed, 2.0) * 0.01;
  let vib_amp = ps.p_vib_strength * 0.5;

  // Envelope
  let env_vol = 0.0;
  let env_stage = 0;
  let env_time = 0;
  let env_length = [
    Math.floor(ps.p_env_attack * ps.p_env_attack * 100000.0),
    Math.floor(ps.p_env_sustain * ps.p_env_sustain * 100000.0),
    Math.floor(ps.p_env_decay * ps.p_env_decay * 100000.0)
  ];
  let env_total_length = env_length[0] + env_length[1] + env_length[2];

  // Phaser
  let phase = 0;
  let fphase = Math.pow(ps.p_pha_offset, 2.0) * 1020.0;
  if (ps.p_pha_offset < 0.0) fphase = -fphase;
  let fdphase = Math.pow(ps.p_pha_ramp, 2.0) * 1.0;
  if (ps.p_pha_ramp < 0.0) fdphase = -fdphase;
  let iphase = Math.abs(Math.floor(fphase));
  let ipp = 0;
  let phaser_buffer = [];
  for (let i = 0; i < 1024; ++i)
    phaser_buffer[i] = 0.0;

  // Noise
  let noise_buffer = [];
  for (let i = 0; i < 32; ++i)
    noise_buffer[i] = Math.random() * 2.0 - 1.0;

  // Repeat
  let rep_limit = Math.floor(Math.pow(1.0 - ps.p_repeat_speed, 2.0) * 20000
                             + 32);
  if (ps.p_repeat_speed == 0.0)
    rep_limit = 0;

  //let gain = 2.0 * Math.log(1 + (Math.E - 1) * ps.sound_vol);
  // let gain = 2.0 * ps.sound_vol;
  let gain = Math.exp(ps.sound_vol) - 1;

  let num_clipped = 0;

  // ...end of initialization. Generate samples.

  let sample_sum = 0;
  let num_summed = 0;
  let summands = Math.floor(44100 / ps.sample_rate);

  let buffer_i = 0;
  let buffer_length = Math.ceil(env_total_length / summands);
  let buffer_complete = false;

  let sound;
  if (ps.sample_rate < SoundEffect.MIN_SAMPLE_RATE) {
    // Assume 4x gets close enough to MIN_SAMPLE_RATE
    sound = new SoundEffect(4 * buffer_length, SoundEffect.MIN_SAMPLE_RATE);
  } else {
    sound = new SoundEffect(buffer_length, ps.sample_rate)
  }
  let buffer = sound.getBuffer();

  let sample=0;
  for (let t = 0;; ++t) {

    // Repeats
    if (rep_limit != 0 && ++rep_time >= rep_limit)
      repeat();

    // Arpeggio (single)
    if (arp_limit != 0 && t >= arp_limit) {
      arp_limit = 0;
      fperiod *= arp_mod;
    }

    // Frequency slide, and frequency slide slide!
    fslide += fdslide;
    fperiod *= fslide;
    if (fperiod > fmaxperiod) {
      fperiod = fmaxperiod;
      if (ps.p_freq_limit > 0.0)
        buffer_complete = true;
    }

    // Vibrato
    let rfperiod = fperiod;
    if (vib_amp > 0.0) {
      vib_phase += vib_speed;
      rfperiod = fperiod * (1.0 + Math.sin(vib_phase) * vib_amp);
    }
    period = Math.floor(rfperiod);
    if (period < 8) period = 8;

    square_duty += square_slide;
    if (square_duty < 0.0) square_duty = 0.0;
    if (square_duty > 0.5) square_duty = 0.5;

    // Volume envelope
    env_time++;
    if (env_time > env_length[env_stage]) {
      env_time = 1;
      env_stage++;
      while (env_stage < 3 && env_length[env_stage] === 0)
	env_stage++;
      if (env_stage === 3)
        break;
    }
    if (env_stage === 0)
      env_vol = env_time / env_length[0];
    else if (env_stage === 1)
      env_vol = 1.0 + Math.pow(1.0 - env_time / env_length[1],
                               1.0) * 2.0 * ps.p_env_punch;
    else  // env_stage == 2
      env_vol = 1.0 - env_time / env_length[2];

    // Phaser step
    fphase += fdphase;
    iphase = Math.abs(Math.floor(fphase));
    if (iphase > 1023) iphase = 1023;

    if (flthp_d != 0.0) {
      flthp *= flthp_d;
      if (flthp < 0.00001)
        flthp = 0.00001;
      if (flthp > 0.1)
        flthp = 0.1;
    }

    // 8x supersampling
    sample = 0.0;
    for (let si = 0; si < 8; ++si) {
      let sub_sample = 0.0;
      phase++;
      if (phase >= period) {
        phase %= period;
        if (ps.wave_type === NOISE)
          for (let i = 0; i < 32; ++i)
            noise_buffer[i] = Math.random() * 2.0 - 1.0;
      }

      // Base waveform
      let fp = phase / period;
      if (ps.wave_type === SQUARE) {
        if (fp < square_duty)
          sub_sample = 0.5;
        else
          sub_sample = -0.5;
      } else if (ps.wave_type === SAWTOOTH) {
        sub_sample = 1.0 - fp * 2;
      } else if (ps.wave_type === SINE) {
        sub_sample = Math.sin(fp * 2 * Math.PI);
      } else if (ps.wave_type === NOISE) {
        sub_sample = noise_buffer[Math.floor(phase * 32 / period)];
      } else if (ps.wave_type === TRIANGLE) {
        sub_sample = Math.abs(1 - fp * 2) - 1;
      } else if (ps.wave_type === BREAKER) {
        sub_sample = Math.abs(1 - fp * fp * 2) - 1;
      } else {
        throw new Exception('bad wave type! ' + ps.wave_type);
      }

      // Low-pass filter
      let pp = fltp;
      fltw *= fltw_d;
      if (fltw < 0.0) fltw = 0.0;
      if (fltw > 0.1) fltw = 0.1;
      if (ps.p_lpf_freq != 1.0) {
        fltdp += (sub_sample - fltp) * fltw;
        fltdp -= fltdp * fltdmp;
      } else {
        fltp = sub_sample;
        fltdp = 0.0;
      }
      fltp += fltdp;

      // High-pass filter
      fltphp += fltp - pp;
      fltphp -= fltphp * flthp;
      sub_sample = fltphp;

      // Phaser
      phaser_buffer[ipp & 1023] = sub_sample;
      sub_sample += phaser_buffer[(ipp - iphase + 1024) & 1023];
      ipp = (ipp + 1) & 1023;

      // final accumulation and envelope application
      sample += sub_sample * env_vol;
    }

    // Accumulate samples appropriately for sample rate
    sample_sum += sample;
    if (++num_summed >= summands) {
      num_summed = 0;
      sample = sample_sum / summands;
      sample_sum = 0;
    } else {
      continue;
    }

    sample = sample / 8 * masterVolume;
    sample *= gain;

    buffer[buffer_i++] = sample;

    if (ps.sample_rate < SoundEffect.MIN_SAMPLE_RATE) {
      buffer[buffer_i++] = sample;
      buffer[buffer_i++] = sample;
      buffer[buffer_i++] = sample;
    }
  }

  if (summands > 0) {
    sample = sample_sum / summands;

    sample = sample / 8 * masterVolume;
    sample *= gain;

    buffer[buffer_i++] = sample;

    if (ps.sample_rate < SoundEffect.MIN_SAMPLE_RATE) {
      buffer[buffer_i++] = sample;
      buffer[buffer_i++] = sample;
      buffer[buffer_i++] = sample;
    }
  }

  return sound;
};

if (typeof exports != 'undefined') {
  // For node.js
  let RIFFWAVE = require('./riffwave').RIFFWAVE;
  exports.Params = Params;
  exports.generate = generate;
}

const sfxCache = {};
let cachedSeeds = [];
const CACHE_MAX = 50;

function cacheSeed(seed){
  if (seed in sfxCache) {
    return sfxCache[seed];
  }

  const params = generateFromSeed(seed);
  params.sound_vol = SOUND_VOL;
  params.sample_rate = SAMPLE_RATE;
  params.bit_depth = BIT_DEPTH;

  const sound = SoundEffect.generate(params);
  sfxCache[seed] = sound;
  cachedSeeds.push(seed);

  while (cachedSeeds.length>CACHE_MAX) {
    const toRemove=cachedSeeds[0];
    cachedSeeds = cachedSeeds.slice(1);
    delete sfxCache[toRemove];
  }

  return sound;
}


function playSound(seed,ignore) {
  if (ignore!==true){
    pushSoundToHistory(seed);
  }
  if (muted){
    return;
  }
  checkAudioContextExists();
  if (unitTesting) return;
  const sound = cacheSeed(seed);
  sound.play();
}



function killAudioButton(){
  const mb = document.getElementById("muteButton");
  const umb = document.getElementById("unMuteButton");
  if (mb){
    mb.remove();
    umb.remove();
  }
}

function showAudioButton(){
  const mb = document.getElementById("muteButton");
  const umb = document.getElementById("unMuteButton");
  if (mb){
    mb.style.display="block"; 
    umb.style.display="none";
  }
}


function toggleMute() {
  if (muted===0){
    muteAudio();
  } else {
    unMuteAudio();
  }
}

function muteAudio() {
  muted=1; 
  const mb = document.getElementById("muteButton");
  const umb = document.getElementById("unMuteButton");
  if (mb){
    mb.style.display="none"; 
    umb.style.display="block";
  }
}
function unMuteAudio() {
  muted=0; 
  const mb = document.getElementById("muteButton");
  const umb = document.getElementById("unMuteButton");
  if (mb){
    mb.style.display="block"; 
    umb.style.display="none";
  }
}
</script>
<script>
//This script has just the CodeMirror bits to make shared & exported games work, without loading the entire thing
//from https://github.com/Auroriax/PuzzleScript/commit/463e8069218dbde0901627e8dac124d2856eb394
function CodeMirror(place, options) {};

CodeMirror.defineMode = function(name, mode) {};

var StringStream = CodeMirror.StringStream = function(string, tabSize) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
  };

  StringStream.prototype = {
    eol: function() {return this.pos >= this.string.length;},
    sol: function() {return this.pos == this.lineStart;},
    peek: function() {return this.string.charAt(this.pos) || undefined;},
    next: function() {
      if (this.pos < this.string.length)
        return this.string.charAt(this.pos++);
    },
    eat: function(match) {
      var ch = this.string.charAt(this.pos);
      if (typeof match == "string") var ok = ch == match;
      else var ok = ch && (match.test ? match.test(ch) : match(ch));
      if (ok) {++this.pos; return ch;}
    },
    eatWhile: function(match) {
      var start = this.pos;
      while (this.eat(match)){}
      return this.pos > start;
    },
    eatSpace: function() {
      var start = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
      return this.pos > start;
    },
    skipToEnd: function() {this.pos = this.string.length;},
    skipTo: function(ch) {
      var found = this.string.indexOf(ch, this.pos);
      if (found > -1) {this.pos = found; return true;}
    },
    backUp: function(n) {this.pos -= n;},
    column: function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    indentation: function() {
      return countColumn(this.string, null, this.tabSize) -
        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    },
    match: function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) this.pos += pattern.length;
          return true;
        }
      } else {
        var match = this.string.slice(this.pos).match(pattern);
        if (match && match.index > 0) return null;
        if (match && consume !== false) this.pos += match[0].length;
        return match;
      }
    },
    current: function(){return this.string.slice(this.start, this.pos);},
    hideFirstChars: function(n, inner) {
      this.lineStart += n;
      try { return inner(); }
      finally { this.lineStart -= n; }
    }
  };
</script>
<script>
'use strict';

const colorPalettesAliases = {
	1 : "mastersystem",
	2 : "gameboycolour",
	3 : "amiga",
	4 : "arnecolors",
	5 : "famicom",
	6 : "atari",
	7 : "pastel",
	8 : "ega",
	9 : "amstrad",
	10 : "proteus_mellow",
	11 : "proteus_rich",
	12 : "proteus_night",
	13 : "c64",
	14 : "whitingjp"
};

const colorPalettes = {
	mastersystem : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#555555",
	darkgrey		: "#555500",
	lightgrey		: "#AAAAAA",
	gray			: "#555555",
	darkgray		: "#555500",
	lightgray		: "#AAAAAA",
	red				: "#FF0000",
	darkred			: "#AA0000",
	lightred		: "#FF5555",
	brown			: "#AA5500",
	darkbrown		: "#550000",
	lightbrown		: "#FFAA00",
	orange			: "#FF5500",
	yellow 			: "#FFFF55",
	green			: "#55AA00",
	darkgreen		: "#005500",
	lightgreen		: "#AAFF00",
	blue			: "#5555AA",
	lightblue		: "#AAFFFF",
	darkblue		: "#000055",
	purple			: "#550055",
	pink			: "#FFAAFF"
	},

	gameboycolour : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#7F7F7C",
	darkgrey		: "#3E3E44",
	lightgrey		: "#BAA7A7",
	gray			: "#7F7F7C",
	darkgray		: "#3E3E44",
	lightgray		: "#BAA7A7",
	red				: "#A7120C",
	darkred			: "#880606",
	lightred		: "#BA381F",
	brown			: "#57381F",
	darkbrown		: "#3E2519",
	lightbrown		: "#8E634B",
	orange			: "#BA4B32",
	yellow 			: "#C0BA6F",
	green			: "#517525",
	darkgreen		: "#385D12",
	lightgreen		: "#6F8E44",
	blue			: "#5D6FA7",
	lightblue		: "#8EA7A7",
	darkblue		: "#4B575D",
	purple			: "#3E3E44",
	pink			: "#BA381F"
	},

	amiga : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#BBBBBB",
	darkgrey		: "#333333",
	lightgrey		: "#FFEEDD",
	gray			: "#BBBBBB",
	darkgray		: "#333333",
	lightgray		: "#FFEEDD",
	red				: "#DD1111",
	darkred			: "#990000",
	lightred		: "#FF4422",
	brown			: "#663311",
	darkbrown		: "#331100",
	lightbrown		: "#AA6644",
	orange			: "#FF6644",
	yellow 			: "#FFDD66",
	green			: "#448811",
	darkgreen		: "#335500",
	lightgreen		: "#88BB77",
	blue			: "#8899DD",
	lightblue		: "#BBDDEE",
	darkblue		: "#666688",
	purple			: "#665555",
	pink			: "#997788"
	},

	arnecolors : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#9d9d9d",
	darkgrey		: "#697175",
	lightgrey		: "#cccccc",
	gray			: "#9d9d9d",
	darkgray		: "#697175",
	lightgray		: "#cccccc",
	red				: "#be2633",
	darkred			: "#732930",
	lightred		: "#e06f8b",
	brown			: "#a46422",
	darkbrown		: "#493c2b",
	lightbrown		: "#eeb62f",
	orange			: "#eb8931",
	yellow 			: "#f7e26b",
	green			: "#44891a",
	darkgreen		: "#2f484e",
	lightgreen		: "#a3ce27",
	blue			: "#1d57f7",
	lightblue		: "#B2DCEF",
	darkblue		: "#1B2632",
	purple			: "#342a97",
	pink			: "#de65e2"
	},
	famicom : {
	black   		: "#000000",
	white			: "#ffffff",
	grey			: "#7c7c7c",
	darkgrey		: "#080808",
	lightgrey		: "#bcbcbc",
	gray			: "#7c7c7c",
	darkgray		: "#080808",
	lightgray		: "#bcbcbc",
	red				: "#f83800",
	darkred			: "#881400",
	lightred		: "#f87858",
	brown			: "#AC7C00",
	darkbrown		: "#503000",
	lightbrown		: "#FCE0A8",
	orange			: "#FCA044",
	yellow 			: "#F8B800",
	green			: "#00B800",
	darkgreen		: "#005800",
	lightgreen		: "#B8F8B8",
	blue			: "#0058F8",
	lightblue		: "#3CBCFC",
	darkblue		: "#0000BC",
	purple			: "#6644FC",
	pink			: "#F878F8"
	},

	atari : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#909090",
	darkgrey		: "#404040",
	lightgrey		: "#b0b0b0",
	gray			: "#909090",
	darkgray		: "#404040",
	lightgray		: "#b0b0b0",
	red				: "#A03C50",
	darkred			: "#700014",
	lightred		: "#DC849C",
	brown			: "#805020",
	darkbrown		: "#703400",
	lightbrown		: "#CB9870",
	orange			: "#CCAC70",
	yellow 			: "#ECD09C",
	green			: "#58B06C",
	darkgreen		: "#006414",
	lightgreen		: "#70C484",
	blue			: "#1C3C88",
	lightblue		: "#6888C8",
	darkblue		: "#000088",
	purple			: "#3C0080",
	pink			: "#B484DC"
	},
	pastel : {
	black   		: "#000000",
	white			: "#FFFFFF",
	grey			: "#3e3e3e",
	darkgrey		: "#313131",
	lightgrey		: "#9cbcbc",
	gray			: "#3e3e3e",
	darkgray		: "#313131",
	lightgray		: "#9cbcbc",
	red				: "#f56ca2",
	darkred			: "#a63577",
	lightred		: "#ffa9cf",
	brown			: "#b58c53",
	darkbrown		: "#787562",
	lightbrown		: "#B58C53",
	orange			: "#EB792D",
	yellow 			: "#FFe15F",
	green			: "#00FF4F",
	darkgreen		: "#2b732c",
	lightgreen		: "#97c04f",
	blue			: "#0f88d3",
	lightblue		: "#00fffe",
	darkblue		: "#293a7b",
	purple			: "#ff6554",
	pink			: "#eb792d"
	},
	ega : {
	black   		: "#000000",
	white			: "#ffffff",
	grey			: "#555555",
	darkgrey		: "#555555",
	lightgrey		: "#aaaaaa",
	gray			: "#555555",
	darkgray		: "#555555",
	lightgray		: "#aaaaaa",
	red				: "#ff5555",
	darkred			: "#aa0000",
	lightred		: "#ff55ff",
	brown			: "#aa5500",
	darkbrown		: "#aa5500",
	lightbrown		: "#ffff55",
	orange			: "#ff5555",
	yellow 			: "#ffff55",
	green			: "#00aa00",
	darkgreen		: "#00aaaa",
	lightgreen		: "#55ff55",
	blue			: "#5555ff",
	lightblue		: "#55ffff",
	darkblue		: "#0000aa",
	purple			: "#aa00aa",
	pink			: "#ff55ff"
	},


	proteus_mellow : {
	black   		: "#3d2d2e",
	white			: "#ddf1fc",
	grey			: "#9fb2d4",
	darkgrey		: "#7b8272",
	lightgrey		: "#a4bfda",
	gray			: "#9fb2d4",
	darkgray		: "#7b8272",
	lightgray		: "#a4bfda",
	red				: "#9d5443",
	darkred			: "#8c5b4a",
	lightred		: "#94614c",
	brown			: "#89a78d",
	darkbrown		: "#829e88",
	lightbrown		: "#aaae97",
	orange			: "#d1ba86",
	yellow 			: "#d6cda2",
	green			: "#75ac8d",
	darkgreen		: "#8fa67f",
	lightgreen		: "#8eb682",
	blue			: "#88a3ce",
	lightblue		: "#a5adb0",
	darkblue		: "#5c6b8c",
	purple			: "#d39fac",
	pink			: "#c8ac9e"
	},
	

	proteus_night : {
	black   		: "#010912",
	white			: "#fdeeec",
	grey			: "#051d40",
	darkgrey		: "#091842",
	lightgrey		: "#062151",
	gray			: "#051d40",
	darkgray		: "#091842",
	lightgray		: "#062151",
	red				: "#ad4576",
	darkred			: "#934765",
	lightred		: "#ab6290",
	brown			: "#61646b",
	darkbrown		: "#3d2d2d",
	lightbrown		: "#8393a0",
	orange			: "#0a2227",
	yellow 			: "#0a2541",
	green			: "#75ac8d",
	darkgreen		: "#0a2434",
	lightgreen		: "#061f2e",
	blue			: "#0b2c79",
	lightblue		: "#809ccb",
	darkblue		: "#08153b",
	purple			: "#666a87",
	pink			: "#754b4d"
	},
	


	proteus_rich: {
	black   		: "#6f686f",
	white			: "#d1b1e2",
	grey			: "#b9aac1",
	darkgrey		: "#8e8b84",
	lightgrey		: "#c7b5cd",
	gray			: "#b9aac1",
	darkgray		: "#8e8b84",
	lightgray		: "#c7b5cd",
	red				: "#a11f4f",
	darkred			: "#934765",
	lightred		: "#c998ad",
	brown			: "#89867d",
	darkbrown		: "#797f75",
	lightbrown		: "#ab9997",
	orange			: "#ce8c5c",
	yellow 			: "#f0d959",
	green			: "#75bc54",
	darkgreen		: "#599d79",
	lightgreen		: "#90cf5c",
	blue			: "#8fd0ec",
	lightblue		: "#bcdce7",
	darkblue		: "#0b2c70",
	purple			: "#9b377f",
	pink			: "#cd88e5"
	},
	

	
amstrad : {
	black   		: "#000000",
	white			: "#ffffff",
	grey			: "#7f7f7f",
	darkgrey		: "#636363",
	lightgrey		: "#afafaf",
	gray			: "#7f7f7f",
	darkgray		: "#636363",
	lightgray		: "#afafaf",
	red				: "#ff0000",
	darkred			: "#7f0000",
	lightred		: "#ff7f7f",
	brown			: "#ff7f00",
	darkbrown		: "#7f7f00",
	lightbrown		: "#ffff00",
	orange			: "#ff007f",
	yellow 			: "#ffff7f",
	green			: "#01ff00",
	darkgreen		: "#007f00",
	lightgreen		: "#7fff7f",
	blue			: "#0000ff",
	lightblue		: "#7f7fff",
	darkblue		: "#00007f",
	purple			: "#7f007f",
	pink			: "#ff7fff"
	},
c64 : {
	black   		: "#000000",
	white			: "#ffffff",
	grey			: "#6C6C6C",
	darkgrey		: "#444444",
	lightgrey		: "#959595",
	gray			: "#6C6C6C",
	darkgray		: "#444444",
	lightgray		: "#959595",
	red				: "#68372B",
	darkred			: "#3f1e17",
	lightred		: "#9A6759",
	brown			: "#433900",
	darkbrown		: "#221c02",
	lightbrown		: "#6d5c0d",
	orange			: "#6F4F25",
	yellow 			: "#B8C76F",
	green			: "#588D43",
	darkgreen		: "#345129",
	lightgreen		: "#9AD284",
	blue			: "#6C5EB5",
	lightblue		: "#70A4B2",
	darkblue		: "#352879",
	purple			: "#6F3D86",
	pink			: "#b044ac"
},
whitingjp : {
  black       : "#202527",
  white       : "#eff8fd",
  grey        : "#7b7680",
  darkgrey    : "#3c3b44",
  lightgrey   : "#bed0d7",
  gray        : "#7b7680",
  darkgray    : "#3c3b44",
  lightgray   : "#bed0d7",
  red         : "#bd194b",
  darkred     : "#6b1334",
  lightred    : "#ef2358",
  brown       : "#b52e1c",
  darkbrown   : "#681c12",
  lightbrown  : "#e87b45",
  orange      : "#ff8c10",
  yellow      : "#fbd524",
  green       : "#36bc3c",
  darkgreen   : "#317610",
  lightgreen  : "#8ce062",
  blue        : "#3f62c6",
  lightblue   : "#57bbe0",
  darkblue    : "#2c2fa0",
  purple      : "#7037d9",
  pink        : "#ec2b8f"
}
};







</script>
<script>
'use strict';

function createSprite(name, spritegrid, colors, padding) {
    if (colors === undefined) {
        colors = [state.bgcolor, state.fgcolor];
    }

    var sprite = makeSpriteCanvas(name);
    var spritectx = sprite.getContext('2d');

    spritectx.clearRect(0, 0, cellwidth, cellheight);

    var w = spritegrid[0].length;
    var h = spritegrid.length;
    var cw = ~~(cellwidth / (w + (padding | 0)));
    var ch = ~~(cellheight / (h + (padding | 0)));
    var pixh = ch;
    if ("scanline" in state.metadata) {
        pixh = Math.ceil(ch / 2);
    }
    spritectx.fillStyle = state.fgcolor;
    for (var j = 0; j < h; j++) {
        for (var k = 0; k < w; k++) {
            var val = spritegrid[j][k];
            if (val >= 0) {
                var cy = (j * ch) | 0;
                var cx = (k * cw) | 0;
                const color = colors[val];
                spritectx.fillStyle = color;
                spritectx.fillRect(cx, cy, cw, pixh);
            }
        }
    }

    return sprite;
}

function renderCJKCharacter(char, padding) {
    //character not present in pixel font, so we need to render it from scratc
    const colors = [state.bgcolor, state.fgcolor];

    var sprite = makeSpriteCanvas("specialchar_" + char);
    sprite.width = 2 * cellwidth;

    var spritectx = sprite.getContext('2d');

    spritectx.clearRect(0, 0, 2 * cellwidth, cellheight);
    // spritectx.fillStyle = "red";
    // spritectx.fillRect(0, 0, 2*cellwidth, cellheight);

    //render the character using a font
    //filltext
    spritectx.fillStyle = state.fgcolor;
    //we need the size of the character to fit the box
    const font_height = cellheight - 4 * padding;
    spritectx.font = font_height + 'px Arial';
    spritectx.textAlign = 'center';
    spritectx.fillText(char, cellwidth, font_height + padding);

    return sprite;
}

function regenText(spritecanvas, spritectx) {
    textImages = {};

    for (var rowidx in titleImage) {
        var row = titleImage[rowidx];
        for (var nidx in row) {
            var n = row[nidx];
            if (!textImages.hasOwnProperty(n)) {
                if (font.hasOwnProperty(n)) {
                    const fontstr = font[n].split('\n').map(a => a.trim().split('').map(t => parseInt(t)));
                    fontstr.shift();
                    textImages[n] = createSprite('char' + n, fontstr, ["#00000000", state.fgcolor], 1);
                } else {
                    //the character was not found, so
                    textImages[n] = renderCJKCharacter(n, 1)
                }
            }
        }
    }
}

var editor_s_grille = [[0, 1, 1, 1, 0], [1, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 1], [0, 1, 1, 1, 0]];

var spriteimages;
function regenSpriteImages() {
    if (textMode) {
        spriteimages = [];
        regenText();
        return;
    }

    if (IDE === true) {
        textImages['editor_s'] = createSprite('chars', editor_s_grille, undefined);
    }

    if (state.levels.length === 0) {
        return;
    }
    spriteimages = [];

    for (var i = 0; i < sprites.length; i++) {
        if (sprites[i] == undefined) {
            continue;
        }
        spriteimages[i] = createSprite(i.toString(), sprites[i].dat, sprites[i].colors);
    }

    if (canOpenEditor) {
        generateGlyphImages();
    }
}

var glyphImagesCorrespondance;
var glyphImages;
var glyphHighlight;
var glyphHighlightDiff;
var glyphHighlightResize;
var glyphPrintButton;
var glyphMouseOver;
var glyphSelectedIndex = 0;
var editorRowCount = 1;
var editorGlyphMovements = [];

var canvasdict = {};
function makeSpriteCanvas(name) {
    var canvas;
    if (name in canvasdict) {
        canvas = canvasdict[name];
    } else {
        canvas = document.createElement('canvas');
        canvasdict[name] = canvas;
    }
    canvas.width = cellwidth;
    canvas.height = cellheight;
    return canvas;
}


function generateGlyphImages() {
    if (cellwidth === 0 || cellheight === 0) {
        return;
    }
    glyphImagesCorrespondance = [];
    glyphImages = [];

    const seenobjects = {};
    for (var n of state.glyphOrder) {
        if (n.length == 1 && state.glyphDict.hasOwnProperty(n)) {
            var g = state.glyphDict[n];

            /* hide duplicate entries from editor palette*/
            var trace = g.join(",");
            if (seenobjects.hasOwnProperty(trace)) {
                continue;
            }

            var sprite = makeSpriteCanvas("C" + n)
            var spritectx = sprite.getContext('2d');
            glyphImagesCorrespondance.push(n);
            seenobjects[trace] = true;

            for (var i = 0; i < g.length; i++) {
                var id = g[i];
                if (id === -1) {
                    continue;
                }
                spritectx.drawImage(spriteimages[id], 0, 0);
            }
            glyphImages.push(sprite);
        }
    }

    if (IDE) {
        //make highlight thingy
        glyphHighlight = makeSpriteCanvas("highlight");
        var spritectx = glyphHighlight.getContext('2d');
        spritectx.fillStyle = '#FFFFFF';

        spritectx.fillRect(0, 0, cellwidth, 1);
        spritectx.fillRect(0, 0, 1, cellheight);

        spritectx.fillRect(0, cellheight - 1, cellwidth, 1);
        spritectx.fillRect(cellwidth - 1, 0, 1, cellheight);

        glyphPrintButton = textImages['editor_s'];

        //make diff highlighter thingy
        glyphHighlightDiff = makeSpriteCanvas("glyphHighlightDiff");
        var spritectx = glyphHighlightDiff.getContext('2d');

        spritectx.fillStyle = state.bgcolor;

        spritectx.fillRect(0, 0, cellwidth, 2);
        spritectx.fillRect(0, 0, 2, cellheight);

        spritectx.fillRect(0, cellheight - 2, cellwidth, 2);
        spritectx.fillRect(cellwidth - 2, 0, 2, cellheight);

        spritectx.fillStyle = state.fgcolor;

        spritectx.fillRect(0, 0, cellwidth, 1);
        spritectx.fillRect(0, 0, 1, cellheight);

        spritectx.fillRect(0, cellheight - 1, cellwidth, 1);
        spritectx.fillRect(cellwidth - 1, 0, 1, cellheight);



        glyphPrintButton = textImages['editor_s'];


        //make highlight thingy
        glyphHighlightResize = makeSpriteCanvas("highlightresize");
        var spritectx = glyphHighlightResize.getContext('2d');
        spritectx.fillStyle = '#FFFFFF';

        var minx = ((cellwidth / 2) - 1) | 0;
        var xsize = cellwidth - minx - 1 - minx;
        var miny = ((cellheight / 2) - 1) | 0;
        var ysize = cellheight - miny - 1 - minx;

        spritectx.fillRect(minx, 0, xsize, cellheight);
        spritectx.fillRect(0, miny, cellwidth, ysize);

        //make highlight thingy
        glyphMouseOver = makeSpriteCanvas("glyphMouseOver");
        var spritectx = glyphMouseOver.getContext('2d');
        spritectx.fillStyle = 'yellow';

        spritectx.fillRect(0, 0, cellwidth, 2);
        spritectx.fillRect(0, 0, 2, cellheight);

        spritectx.fillRect(0, cellheight - 2, cellwidth, 2);
        spritectx.fillRect(cellwidth - 2, 0, 2, cellheight);

        //make movement glyphs

        /* 
        up:1
        down:2
        left:4
        right:8
        action:16
        rigid:32
        */
        const coords = [
            //0 up
            [[3, 2], [5, 0], [7, 2]],
            //1 down
            [[3, 8], [5, 10], [7, 8]],
            //2 left
            [[2, 3], [0, 5], [2, 7]],
            //3 right
            [[7, 3], [10, 5], [7, 7]],
            //4 action
            [[3, 5], [5, 7], [7, 5], [5, 3]],
            //5 rigid
            [[3, 3], [5, 3], [5, 4], [4, 4], [4, 5], [3, 5]],
        ];

        for (var i = 0; i < coords.length; i++) {
            editorGlyphMovements[i] = makeSpriteCanvas("editorGlyphMovements" + i);
            var path = coords[i];

            var spritectx = editorGlyphMovements[i].getContext('2d');
            spritectx.lineWidth = 1;


            spritectx.fillStyle = state.bgcolor;
            spritectx.strokeStyle = state.fgcolor;


            spritectx.beginPath();       // Start a new path
            spritectx.moveTo(path[0][0] * cellwidth / 10.0, path[0][1] * cellheight / 10.0);
            for (var j = 1; j < path.length; j++) {
                spritectx.lineTo(path[j][0] * cellwidth / 10.0, path[j][1] * cellheight / 10.0);
            }
            spritectx.closePath();
            spritectx.fill();
            spritectx.stroke();          // Render the path        
        }
    }
}

var canvas;
var ctx;


var x;
var y;
var cellwidth;
var cellheight;
var xoffset;
var yoffset;

window.addEventListener('resize', function () { canvasResize(); }, false);
canvas = document.getElementById('gameCanvas');
ctx = canvas.getContext('2d');
x = 0;
y = 0;

function glyphCount() {
    //could also just return glyphImages.length
    var count = 0;
    for (var n of state.glyphOrder) {
        if (n.length == 1 && state.glyphDict.hasOwnProperty(n)) {
            count++;
        }
    }
    return count;
}

function redraw() {
    if (cellwidth === 0 || cellheight === 0) {
        return;
    }
    if (spriteimages === undefined) {
        regenSpriteImages();
    }

    if (textMode) {
        ctx.fillStyle = state.bgcolor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (var i = 0; i < TERMINAL_WIDTH; i++) {
            for (var j = 0; j < TERMINAL_HEIGHT; j++) {
                var ch = titleImage[j].charAt(i);
                if (ch in textImages) {
                    var sprite = textImages[ch];
                    ctx.drawImage(sprite, xoffset + i * cellwidth, yoffset + j * cellheight);
                }
            }
        }
        return;
    } else {
        var curlevel = level;
        if (diffToVisualize !== null) {
            curlevel = new Level(-1, diffToVisualize.width, diffToVisualize.height, diffToVisualize.layerCount, diffToVisualize.objects);
            curlevel.movements = diffToVisualize.movements;
            curlevel.rigidMovementAppliedMask = diffToVisualize.rigidMovementAppliedMask;
        }
        ctx.fillStyle = state.bgcolor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        var mini = 0;
        var maxi = screenwidth;
        var minj = 0;
        var maxj = screenheight;

        if (levelEditorOpened) {
            var glyphcount = glyphCount();
            editorRowCount = Math.ceil(glyphcount / (screenwidth - 1));
            maxi -= 2;
            maxj -= 2 + editorRowCount;
        } else if (flickscreen) {
            var playerPositions = getPlayerPositions();
            if (playerPositions.length > 0) {
                var playerPosition = playerPositions[0];
                var px = (playerPosition / (curlevel.height)) | 0;
                var py = (playerPosition % curlevel.height) | 0;

                var screenx = (px / screenwidth) | 0;
                var screeny = (py / screenheight) | 0;
                mini = screenx * screenwidth;
                minj = screeny * screenheight;
                maxi = Math.min(mini + screenwidth, curlevel.width);
                maxj = Math.min(minj + screenheight, curlevel.height);

                oldflickscreendat = [mini, minj, maxi, maxj];
            } else if (oldflickscreendat.length > 0) {
                mini = oldflickscreendat[0];
                minj = oldflickscreendat[1];
                maxi = oldflickscreendat[2];
                maxj = oldflickscreendat[3];
            }
        } else if (zoomscreen) {
            var playerPositions = getPlayerPositions();
            if (playerPositions.length > 0) {
                var playerPosition = playerPositions[0];
                var px = (playerPosition / (curlevel.height)) | 0;
                var py = (playerPosition % curlevel.height) | 0;
                mini = Math.max(Math.min(px - ((screenwidth / 2) | 0), curlevel.width - screenwidth), 0);
                minj = Math.max(Math.min(py - ((screenheight / 2) | 0), curlevel.height - screenheight), 0);
                maxi = Math.min(mini + screenwidth, curlevel.width);
                maxj = Math.min(minj + screenheight, curlevel.height);
                oldflickscreendat = [mini, minj, maxi, maxj];
            } else if (oldflickscreendat.length > 0) {
                mini = oldflickscreendat[0];
                minj = oldflickscreendat[1];
                maxi = oldflickscreendat[2];
                maxj = oldflickscreendat[3];
            }
        }



        for (var i = mini; i < maxi; i++) {
            for (var j = minj; j < maxj; j++) {
                var posIndex = j + i * curlevel.height;
                var posMask = curlevel.getCellInto(posIndex, _o12);
                for (var k = 0; k < state.objectCount; k++) {
                    if (posMask.get(k) != 0) {
                        var sprite = spriteimages[k];
                        ctx.drawImage(sprite, xoffset + (i - mini) * cellwidth, yoffset + (j - minj) * cellheight);
                    }
                }
            }
        }

        if (diffToVisualize !== null) {
            //find previous state (this is never called on the very first state, the one before player inputs are applied, so there is always a previous state)
            var prevstate_lineNumberIndex = diffToVisualize.lineNumber - 1;
            for (; prevstate_lineNumberIndex >= -1; prevstate_lineNumberIndex--) {
                if (debug_visualisation_array[diffToVisualize.turnIndex].hasOwnProperty(prevstate_lineNumberIndex)) {
                    break;
                }
            }

            var prev_state = debug_visualisation_array[diffToVisualize.turnIndex][prevstate_lineNumberIndex];
            var prevlevel = new Level(-1, prev_state.width, prev_state.height, prev_state.layerCount, prev_state.objects);
            prevlevel.movements = prev_state.movements;
            prevlevel.rigidMovementAppliedMask = prev_state.rigidMovementAppliedMask;

            for (var i = mini; i < maxi; i++) {
                for (var j = minj; j < maxj; j++) {
                    var posIndex = j + i * curlevel.height;
                    var movementbitvec_PREV = prevlevel.getMovements(posIndex);
                    var movementbitvec = curlevel.getMovements(posIndex);

                    var posMask_PREV = prevlevel.getCellInto(posIndex, _o11);
                    var posMask = curlevel.getCellInto(posIndex, _o12);
                    if (!movementbitvec.equals(movementbitvec_PREV) || !posMask.equals(posMask_PREV)) {
                        ctx.drawImage(glyphHighlightDiff, xoffset + (i - mini) * cellwidth, yoffset + (j - minj) * cellheight);

                    }
                }
            }

            //draw movements!
            for (var i = mini; i < maxi; i++) {
                for (var j = minj; j < maxj; j++) {
                    var posIndex = j + i * curlevel.height;
                    var movementbitvec = curlevel.getMovements(posIndex);
                    for (var layer = 0; layer < curlevel.layerCount; layer++) {
                        var layerMovement = movementbitvec.getshiftor(0x1f, 5 * layer);
                        for (var k = 0; k < 5; k++) {
                            if ((layerMovement & Math.pow(2, k)) !== 0) {
                                ctx.drawImage(editorGlyphMovements[k], xoffset + (i - mini) * cellwidth, yoffset + (j - minj) * cellheight);
                            }
                        }
                    }
                }
            }

            //draw rigid applciations!
            if (state.rigid){
                for (var i = mini; i < maxi; i++) {
                    for (var j = minj; j < maxj; j++) {
                        var posIndex = j + i * curlevel.height;
                        var rigidbitvec = curlevel.getRigids(posIndex);
                        for (var layer = 0; layer < curlevel.layerCount; layer++) {
                            var layerRigid = rigidbitvec.getshiftor(0x1f, 5 * layer);
                            if (layerRigid !== 0) {
                                ctx.drawImage(editorGlyphMovements[5], xoffset + (i - mini) * cellwidth, yoffset + (j - minj) * cellheight);
                            }
                        }
                    }
                }
            }
        }

        if (levelEditorOpened) {
            drawEditorIcons(mini, minj);
        }
    }
}

function drawEditorIcons(mini, minj) {
    var glyphCount = glyphImages.length;
    var glyphStartIndex = 0;
    var glyphEndIndex = glyphImages.length;/*Math.min(
							glyphStartIndex+10,
							screenwidth-2,
							glyphStartIndex+Math.max(glyphCount-glyphStartIndex,0)
							);*/
    var glyphsToDisplay = glyphEndIndex - glyphStartIndex;

    ctx.drawImage(glyphPrintButton, xoffset - cellwidth, yoffset - cellheight * (1 + editorRowCount));
    if (mouseCoordY === (-1 - editorRowCount) && mouseCoordX === -1) {
        ctx.drawImage(glyphMouseOver, xoffset - cellwidth, yoffset - cellheight * (1 + editorRowCount));
    }

    var ypos = editorRowCount - (-mouseCoordY - 2) - 1;
    var mouseIndex = mouseCoordX + (screenwidth - 1) * ypos;

    for (var i = 0; i < glyphsToDisplay; i++) {
        var glyphIndex = glyphStartIndex + i;
        var sprite = glyphImages[glyphIndex];
        var xpos = i % (screenwidth - 1);
        var ypos = (i / (screenwidth - 1)) | 0;
        ctx.drawImage(sprite, xoffset + (xpos) * cellwidth, yoffset + ypos * cellheight - cellheight * (1 + editorRowCount));
        if (mouseCoordX >= 0 && mouseCoordX < (screenwidth - 1) && mouseIndex === i) {
            ctx.drawImage(glyphMouseOver, xoffset + xpos * cellwidth, yoffset + ypos * cellheight - cellheight * (1 + editorRowCount));
        }
        if (i === glyphSelectedIndex) {
            ctx.drawImage(glyphHighlight, xoffset + xpos * cellwidth, yoffset + ypos * cellheight - cellheight * (1 + editorRowCount));
        }
    }

    //filched from https://raw.githubusercontent.com/ClementSparrow/Pattern-Script/master/src/js/graphics.js
    var tooltip_string = ''
    var tooltip_objects = null
    // prepare tooltip: legend for highlighted editor icon
    if ((mouseCoordX >= 0) && (mouseCoordX < screenwidth) && (mouseIndex >= 0) && (mouseIndex < glyphsToDisplay)) {
        const glyphIndex = glyphStartIndex + mouseIndex
        const identifier_index = glyphImagesCorrespondance[glyphIndex]
        tooltip_string = identifier_index
        if (identifier_index in state.synonymsDict) {
            tooltip_string += " = " + state.synonymsDict[identifier_index];
        } else if (identifier_index in state.aggregatesDict) {
            tooltip_string += " = " + state.aggregatesDict[identifier_index].join(" and ");

        }
    }
    if (mouseIndex === -1) {
        tooltip_string = "print level to console"
    }
    // prepare tooltip: content of a level's cell
    else if ((mouseCoordX >= 0) && (mouseCoordY >= 0) && (mouseCoordX < screenwidth) && (mouseCoordY < screenheight - editorRowCount - 2)) {
        const posMask = level.getCellInto((mouseCoordY + minj) + (mouseCoordX + mini) * level.height, _o12);
        tooltip_objects = state.idDict.filter((x, k) => (posMask.get(k) != 0))
        // prepare tooltip: object names
        if (tooltip_objects !== null) {
            tooltip_string = tooltip_objects.join(', ')
        }
    }

    // show tooltip
    if (tooltip_string.length > 0) {
        ctx.fillStyle = state.fgcolor;
        ctx.font = `16px "Source Sans Pro", Helvetica, Arial, sans-serif`;
        ctx.fillText(tooltip_string, xoffset, yoffset - 0.4 * cellheight);
    }

    if (mouseCoordX >= -1 && mouseCoordY >= -1 && mouseCoordX < screenwidth - 1 && mouseCoordY < screenheight - 1 - editorRowCount) {
        if (mouseCoordX == -1 || mouseCoordY == -1 || mouseCoordX == screenwidth - 2 || mouseCoordY === screenheight - 2 - editorRowCount) {
            ctx.drawImage(glyphHighlightResize,
                xoffset + mouseCoordX * cellwidth,
                yoffset + mouseCoordY * cellheight
            );
        } else {
            ctx.drawImage(glyphHighlight,
                xoffset + mouseCoordX * cellwidth,
                yoffset + mouseCoordY * cellheight
            );
        }
    }

}

var lastDownTarget;

var oldcellwidth = 0;
var oldcellheight = 0;
var oldtextmode = -1;
var oldfgcolor = -1;
var forceRegenImages = false;
function canvasResize(displaylevel) {
    displaylevel ||= level;
    canvas.width = canvas.parentNode.clientWidth;
    canvas.height = canvas.parentNode.clientHeight;

    screenwidth = displaylevel.width;
    screenheight = displaylevel.height;
    if (state !== undefined) {
        flickscreen = state.metadata.flickscreen !== undefined;
        zoomscreen = state.metadata.zoomscreen !== undefined;
        if (levelEditorOpened) {
            screenwidth += 2;
            var glyphcount = glyphCount();
            editorRowCount = Math.ceil(glyphcount / (screenwidth - 1));
            screenheight += 2 + editorRowCount;
        } else if (flickscreen) {
            screenwidth = state.metadata.flickscreen[0];
            screenheight = state.metadata.flickscreen[1];
        } else if (zoomscreen) {
            screenwidth = state.metadata.zoomscreen[0];
            screenheight = state.metadata.zoomscreen[1];
        }
    }

    if (textMode) {
        screenwidth = TERMINAL_WIDTH;
        screenheight = TERMINAL_HEIGHT;
    }

    cellwidth = canvas.width / screenwidth;
    cellheight = canvas.height / screenheight;

    var w = 5;//sprites[1].dat.length;
    var h = 5;//sprites[1].dat[0].length;

    if (textMode) {
        w = 5 + 1;
        var xchar = font['X'].split('\n').map(a => a.trim());
        h = xchar.length;
    }

    cellwidth = w * Math.max(~~(cellwidth / w), 1);
    cellheight = h * Math.max(~~(cellheight / h), 1);

    xoffset = 0;
    yoffset = 0;

    if (cellwidth / w > cellheight / h) {
        cellwidth = cellheight * w / h;
        xoffset = (canvas.width - cellwidth * screenwidth) / 2;
        yoffset = (canvas.height - cellheight * screenheight) / 2;
    }
    else { //if (cellheight > cellwidth) {
        cellheight = cellwidth * h / w;
        yoffset = (canvas.height - cellheight * screenheight) / 2;
        xoffset = (canvas.width - cellwidth * screenwidth) / 2;
    }

    if (levelEditorOpened && !textMode) {
        xoffset += cellwidth;
        yoffset += cellheight * (1 + editorRowCount);
    }

    cellwidth = cellwidth | 0;
    cellheight = cellheight | 0;
    xoffset = xoffset | 0;
    yoffset = yoffset | 0;

    if (oldcellwidth != cellwidth || oldcellheight != cellheight || oldtextmode != textMode || textMode || oldfgcolor != state.fgcolor || forceRegenImages) {
        forceRegenImages = false;
        regenSpriteImages();
    }

    oldcellheight = cellheight;
    oldcellwidth = cellwidth;
    oldtextmode = textMode;
    oldfgcolor = state.fgcolor;

    redraw();
}

</script>
<script>
'use strict';

/*
..................................
.............SOKOBAN..............
..................................
...........#.new game.#...........
..................................
.............continue.............
..................................
arrow keys to move................
x to action.......................
z to undo, r to restart...........
*/


let RandomGen = new RNG();

const intro_template = [
	"..................................",
	"..................................",
	"..................................",
	"......Puzzle Script Terminal......",
	"..............v 1.8...............",
	"..................................",
	"..................................",
	"..................................",
	".........insert cartridge.........",
	"..................................",
	"..................................",
	"..................................",
	".................................."
];

const messagecontainer_template = [
	"..................................",
	"..................................",
	"..................................",
	"..................................",
	"..................................",
	"..................................",
	"..................................",
	"..................................",
	"..................................",
	"..................................",
	"..........X to continue...........",
	"..................................",
	".................................."
];

const blank_row = "..................................";

const titletemplate_menu_startgame = [
	"............start game............",
	"..........#.start game.#..........",
	"-----------.start game.-----------"
]

const titletemplate_menu_newgame = [
	".............new game.............",
	"...........#.new game.#...........",
	"------------.new game.------------",

]

const titletemplate_menu_continue = [
	".............continue.............",
	"...........#.continue.#...........",
	"------------.continue.------------",
]

const titletemplate_controls = {
	arrows:
		".arrow keys to move...............",
	action:
		".X to action......................",
	undorestart:
		".Z to undo, R to restart..........",
	undo: 
		".Z to undo........................",
	restart: 
		".R to restart.....................",
};

const loading_line = "------------ loading  ------------";

let titleImage = [];
const TERMINAL_WIDTH = intro_template[0].length;
const TERMINAL_HEIGHT = intro_template.length;
let titleScreen = true;
let titleMode = 0;//1 means there are options
let titleSelection = 0;
let titleSelected = false;

function showContinueOptionOnTitleScreen() {
	return (curlevel > 0 || curlevelTarget !== null) && (curlevel in state.levels);
}

function unloadGame() {
	if (levelEditorOpened){
		printLevel();
	}
	levelEditorOpened = false;
	state = introstate;
	level = new Level(0, 5, 5, 2, null);
	level.objects = new Int32Array(0);
	generateTitleScreen();
	canvasResize();
	redraw();
}


function align_centre(str, width) {
	if (str.length>=width){
		return str;
	}
	let free_space = width - str.length;
	let left_space = Math.floor(free_space / 2);
	let right_space = free_space - left_space;
	return '.'.repeat(left_space) + str + '.'.repeat(right_space);
}

function align_right(str,width) {
	if (str.length>=width){
		return str;
	}
	//first, if possible, add single space to right
	if (str.length<width-1){
		str = str + '.';
	}
	return str.padStart(width,'.');
}

function generateTitleScreen() {	
	titleMode = showContinueOptionOnTitleScreen() ? 1 : 0;
	
	if (state.levels.length === 0) {
		//if body has light-theme, set fgcolor to black, bgcolor to white
		if (document.body.classList.contains('light-theme')) {
			state.fgcolor = '#000000';
			state.bgcolor = '#FFFFFF';
		} else {
			state.fgcolor = '#FFFFFF';
			state.bgcolor = '#000000';
		}
		titleImage = intro_template;
		return;
	}

	let title = "PuzzleScript Game";
	if (state.metadata.title !== undefined) {
		title = state.metadata.title;
	}

	let title_lines = wordwrap(expandCJKCharacters(title), TERMINAL_WIDTH);
	title_lines = title_lines.map(l => align_centre(l,TERMINAL_WIDTH));
	let author_lines = [];
	if (state.metadata.author !== undefined) {
		author_lines = wordwrap(expandCJKCharacters("by " + state.metadata.author), TERMINAL_WIDTH);
		author_lines = author_lines.map(l => align_right(l,TERMINAL_WIDTH));
	}
	

	let layout_rows = {
		header: null,
		menu_options: [],
		controls: [titletemplate_controls.arrows],
	}	

	if (titleMode===0){
		if (titleSelected){
			layout_rows.menu_options.push(blank_row);
			layout_rows.menu_options.push(titletemplate_menu_startgame[2]);
			layout_rows.menu_options.push(blank_row);
		} else {
			layout_rows.menu_options.push(blank_row);
			layout_rows.menu_options.push(titletemplate_menu_startgame[1]);
			layout_rows.menu_options.push(blank_row);
		}
	} else {
		if (titleSelection===0){
			layout_rows.menu_options.push(titletemplate_menu_newgame[titleSelected?2:1]);
			layout_rows.menu_options.push(blank_row);
			layout_rows.menu_options.push(titletemplate_menu_continue[0]);
		} else {
			layout_rows.menu_options.push(titletemplate_menu_newgame[0]);
			layout_rows.menu_options.push(blank_row);
			layout_rows.menu_options.push(titletemplate_menu_continue[titleSelected?2:1]);
		}
	}

	const has_action = !('noaction' in state.metadata);
	const has_undo = !('noundo' in state.metadata);
	const has_restart = !('norestart' in state.metadata);

	let extra_header_rows = 0;
	if (has_action){
		layout_rows.controls.push(titletemplate_controls.action);
	} else {
		extra_header_rows++;
	}
	if (has_undo && has_restart){
		layout_rows.controls.push(titletemplate_controls.undorestart);
	}
	else if (has_restart){
		layout_rows.controls.push(titletemplate_controls.restart);
	} else if (has_undo){
		layout_rows.controls.push(titletemplate_controls.undo);
	} else {
		extra_header_rows++;
	}

	if (extra_header_rows>1){
		extra_header_rows--;
		layout_rows.controls.push(blank_row);
	}
	let header_size = 5 + extra_header_rows;
	//I have five rows to allocate to title + author
	let bs=0;
	let t_len = title_lines.length;
	let bm=0;
	let a_len = author_lines.length;
	let be=0;

	if (bs+t_len+bm+a_len+be<header_size){
		be++;
	}
	if (bs+t_len+bm+a_len+be<header_size){
		bm++;
	}
	if (bs+t_len+bm+a_len+be<header_size){
		bs++;
	}

	// if we've removed input options, we
	// allocate space above and below
	if (bs+t_len+bm+a_len+be<header_size){
		bs++;
	}
	
	//if they're too long, need to trim
	if (bs+t_len+bm+a_len+be>header_size){
		let title_trimmed=false;
		let author_trimmed=false;
		while (bs+t_len+bm+a_len+be>header_size){
			if (author_lines.length>1){
				author_lines.pop();
				author_trimmed=true;
				a_len--;
			} else if (title_lines.length>1){
				title_lines.pop();
				title_trimmed=true;
				t_len--;
			}
		}
		if (title_trimmed){
			logWarning("Game title is too long to fit on screen; truncating to fit.", state.metadata_lines.title, true);
		}
		if (author_trimmed){
			logWarning("Author name is too long to fit on screen; truncating to fit.", state.metadata_lines.author, true);
		}
	}

	let header = [];
	for (let i=0;i<bs;i++){
		header.push(blank_row);
	}
	for (let i=0;i<t_len;i++){
		header.push(title_lines[i]);
	}
	for (let i=0;i<bm;i++){
		header.push(blank_row);
	}
	for (let i=0;i<a_len;i++){
		header.push(author_lines[i]);
	}
	for (let i=0;i<be;i++){
		header.push(blank_row);
	}
	
	layout_rows.header = header;

	let selection_row = 0;
	/*now to build up the screen */
	titleImage = [];
		

	for (let i=0;i<layout_rows.header.length;i++){
		titleImage.push(layout_rows.header[i]);
	}

	for (let i=0;i<layout_rows.menu_options.length;i++){

		let cur_row = layout_rows.menu_options[i];
		if (cur_row.indexOf('---') !== -1){
			selection_row = titleImage.length;
		}

		titleImage.push(cur_row);

	}

	titleImage.push(blank_row);

	for (let i=0;i<layout_rows.controls.length;i++){
		titleImage.push(layout_rows.controls[i]);
	}

	titleImage.push(blank_row);

	while (titleImage.length<TERMINAL_HEIGHT){
		titleImage.push(blank_row);
	}
	
	titleImage.push(blank_row);

	let regen_letters = false;
	if (titleSelected){		
		let frame = get_title_animation_frame()+2;
		// frame = frame % 12; // loops not pingpong
		//want it to pingpong, not loop
		const loading_text = frame > 12;
		if (loading_text) {

			titleImage[selection_row] = loading_line;
			if (frame === 13){
				//in case it has new characters...
				regen_letters=true;
			}
		}
		frame = frame % 23;
		if (frame > 11) {
			frame = (11-(frame % 12));
		}
		const left_index_to_replace = 11-frame;
		const right_index_to_replace = 22+frame;
		if (!loading_text){
			//generate a string with "left_index_to_replace" spaces
			const spaces = ' '.repeat(left_index_to_replace);
			titleImage[selection_row] = spaces + '#' + titleImage[selection_row].slice(left_index_to_replace + 1, right_index_to_replace) + '#' + spaces;
			
		} else {
			titleImage[selection_row] = 
				titleImage[selection_row].slice(0, left_index_to_replace) 
				+ '#' 
				+ titleImage[selection_row].slice(left_index_to_replace + 1, right_index_to_replace) 
				+ '#' 
				+ titleImage[selection_row].slice(right_index_to_replace + 1);
		}

		if (frame === 2){
			//when animation starts playing (on frame 2), 
			regen_letters=true;
		}
	}


	

	for (let i=0;i<titleImage.length;i++){
		titleImage[i] = titleImage[i].replace(/\./g, ' ');
	}

	if (regen_letters){
		regenSpriteImages();
	}
}

const introstate = {
	title: "EMPTY GAME",
	attribution: "increpare",
	objectCount: 2,
	metadata: [],
	levels: [],
	bgcolor: "#000000",
	fgcolor: "#FFFFFF"
};

let state = introstate;

function deepClone(item) {
	if (!item) { return item; } // null, undefined values check

	let types = [Number, String, Boolean],
		result;

	// normalizing primitives if someone did new String('aaa'), or new Number('444');
	types.forEach(function (type) {
		if (item instanceof type) {
			result = type(item);
		}
	});

	if (typeof result == "undefined") {
		if (Object.prototype.toString.call(item) === "[object Array]") {
			result = [];
			item.forEach(function (child, index, array) {
				result[index] = deepClone(child);
			});
		} else if (typeof item == "object") {
			// testing that this is DOM
			if (item.nodeType && typeof item.cloneNode == "function") {
				let result = item.cloneNode(true);
			} else if (!item.prototype) { // check that this is a literal
				if (item instanceof Date) {
					result = new Date(item);
				} else {
					// it is an object literal
					result = {};
					for (let i in item) {
						result[i] = deepClone(item[i]);
					}
				}
			} else {
                // depending what you would like here,
                // just keep the reference, or create new object
/*                if (false && item.constructor) {
                    // would not advice to do that, reason? Read below
                    result = new item.constructor();
                } else */{
					result = item;
				}
			}
		} else {
			result = item;
		}
	}

	return result;
}

function wordwrap(str, width) {

	width = width || 75;
	let cut = true;

	if (!str) { return str; }

	let regex = '.{1,' + width + '}(\\s|$)' + (cut ? '|.{' + width + '}|.+$' : '|\\S+?(\\s|$)');

	return str.match(RegExp(regex, 'g'));

}

let splitMessage = [];

function expandCJKCharacters(message) {
	//CJK characters are 2 characters wide, so we need to insert a space after
	//each one to give them space
	let expandedMessage = "";
	for (let i = 0; i < message.length; i++) {
		let char = message[i];
		expandedMessage += char;
		if (!font.hasOwnProperty(char)) {
			expandedMessage +=  " ";
		}
	}
	return expandedMessage;
}
function drawMessageScreen() {
	titleMode = 0;
	textMode = true;
	titleImage = deepClone(messagecontainer_template);

	for (let i = 0; i < titleImage.length; i++) {
		titleImage[i] = titleImage[i].replace(/\./g, ' ');
	}

	let emptyLineStr = titleImage[9];
	let xToContinueStr = titleImage[10];

	titleImage[10] = emptyLineStr;

	let width = titleImage[0].length;

	let message;
	if (messagetext === "") {
		let leveldat = state.levels[curlevel];
		message = leveldat.message.trim();
	} else {
		message = messagetext;
	}

	splitMessage = wordwrap(expandCJKCharacters(message), titleImage[0].length);


	let offset = 5 - ((splitMessage.length / 2) | 0);
	if (offset < 0) {
		offset = 0;
	}

	let count = Math.min(splitMessage.length, 12);
	for (let i = 0; i < count; i++) {
		let m = splitMessage[i];
		let row = offset + i;
		let messageLength = m.length;
		let lmargin = ((width - messageLength) / 2) | 0;
		let rmargin = width - messageLength - lmargin;
		let rowtext = titleImage[row];
		titleImage[row] = rowtext.slice(0, lmargin) + m + rowtext.slice(lmargin + m.length);
	}

	let endPos = 10;
	if (count >= 10) {
		if (count < 12) {
			endPos = count + 1;
		} else {
			endPos = 12;
		}
	}
	if (quittingMessageScreen) {
		titleImage[endPos] = emptyLineStr;
	} else {
		titleImage[endPos] = xToContinueStr;
	}

	canvasResize();
}

let loadedLevelSeed = 0;

function loadLevelFromLevelDat(state, leveldat, randomseed, clearinputhistory) {
	if (!randomseed) {
		randomseed = (Math.random() + Date.now()).toString();
	}
	loadedLevelSeed = randomseed;
	RandomGen = new RNG(loadedLevelSeed);
	forceRegenImages = true;
	ignoreNotJustPressedAction = true;
	titleScreen = false;
	titleMode = showContinueOptionOnTitleScreen() ? 1 : 0;
	titleSelection = showContinueOptionOnTitleScreen() ? 1 : 0;
	titleSelected = false;
	againing = false;
	if (leveldat === undefined) {
		consolePrint("Trying to access a level that doesn't exist.", true);
		goToTitleScreen();
		return;
	}
	if (leveldat.message === undefined) {
		titleMode = 0;
		textMode = false;
		tick_lazy_function_generation(false);
		level = leveldat.clone();
		RebuildLevelArrays();


		if (state !== undefined) {
			if (state.metadata.flickscreen !== undefined) {
				oldflickscreendat = [
					0,
					0,
					Math.min(state.metadata.flickscreen[0], level.width),
					Math.min(state.metadata.flickscreen[1], level.height)
				];
			} else if (state.metadata.zoomscreen !== undefined) {
				oldflickscreendat = [
					0,
					0,
					Math.min(state.metadata.zoomscreen[0], level.width),
					Math.min(state.metadata.zoomscreen[1], level.height)
				];
			}
		}

		backups = []
		restartTarget = backupLevel();
		keybuffer = [];

		if ('run_rules_on_level_start' in state.metadata) {
			runrulesonlevelstart_phase = true;
			processInput(-1, true);
			runrulesonlevelstart_phase = false;
		}
	} else {
		ignoreNotJustPressedAction = true;
		tryPlayShowMessageSound();
		drawMessageScreen();
		canvasResize();
	}

	if (clearinputhistory === true) {
		clearInputHistory();
	}
}

function loadLevelFromStateTarget(state, levelindex, target, randomseed) {
	let leveldat = target;
	curlevel = levelindex;
	curlevelTarget = target;
	if (leveldat.message === undefined) {
		if (levelindex === 0) {
			tryPlayStartLevelSound();
		} else {
			tryPlayStartLevelSound();
		}
	}
	loadLevelFromLevelDat(state, state.levels[levelindex], randomseed);
	restoreLevel(target);
	restartTarget = target;
}

function loadLevelFromState(state, levelindex, randomseed) {
	let leveldat = state.levels[levelindex];
	curlevel = levelindex;
	curlevelTarget = null;
	if (leveldat !== undefined && leveldat.message === undefined) {
		if (levelindex === 0) {
			tryPlayStartLevelSound();
		} else {
			tryPlayStartLevelSound();
		}
	}
	loadLevelFromLevelDat(state, leveldat, randomseed);
}

let sprites = [
	{
		color: '#423563',
		dat: [
			[1, 1, 1, 1, 1],
			[1, 0, 0, 0, 1],
			[1, 0, 0, 0, 1],
			[1, 0, 0, 0, 1],
			[1, 1, 1, 1, 1]
		]
	},
	{
		color: '#252342',
		dat: [
			[0, 0, 1, 0, 0],
			[1, 1, 1, 1, 1],
			[0, 0, 1, 0, 0],
			[0, 1, 1, 1, 0],
			[0, 1, 0, 1, 0]
		]
	}
];


generateTitleScreen();
if (titleMode > 0) {
	titleSelection = 1;
}


function tryPlaySimpleSound(soundname) {
	if (state.sfx_Events[soundname] !== undefined) {
		let seed = state.sfx_Events[soundname];
		playSound(seed, true);
	}
}
function tryPlayTitleSound() {
	tryPlaySimpleSound("titlescreen");
}

function tryPlayStartGameSound() {
	tryPlaySimpleSound("startgame");
}

function tryPlayEndGameSound() {
	tryPlaySimpleSound("endgame");
}

function tryPlayCancelSound() {
	tryPlaySimpleSound("cancel");
}

function tryPlayStartLevelSound() {
	tryPlaySimpleSound("startlevel");
}

function tryPlayEndLevelSound() {
	tryPlaySimpleSound("endlevel");
}

function tryPlayUndoSound() {
	tryPlaySimpleSound("undo");
}

function tryPlayRestartSound() {
	tryPlaySimpleSound("restart");
}

function tryPlayShowMessageSound() {
	tryPlaySimpleSound("showmessage");
}

function tryPlayCloseMessageSound() {
	tryPlaySimpleSound("closemessage");
}

let backups = [];
let restartTarget;

function backupLevel() {
	let ret = {
		dat: new Int32Array(level.objects),
		width: level.width,
		height: level.height,
		oldflickscreendat: oldflickscreendat.concat([])
	};
	return ret;
}

function level4Serialization() {
	let ret = {
		dat: Array.from(level.objects),
		width: level.width,
		height: level.height,
		oldflickscreendat: oldflickscreendat.concat([])
	};
	return ret;
}



function setGameState(_state, command, randomseed) {

	if (_state === undefined) {
		_state = introstate;
		return;
	}
	oldflickscreendat = [];
	timer = 0;
	autotick = 0;
	winning = false;
	againing = false;
	messageselected = false;
	STRIDE_MOV = _state.STRIDE_MOV;
	STRIDE_OBJ = _state.STRIDE_OBJ;
	LAYER_COUNT = _state.LAYER_COUNT;
	RebuildGameArrays();

	sfxCreateMask = new BitVec(STRIDE_OBJ);
	sfxDestroyMask = new BitVec(STRIDE_OBJ);

	if (command === undefined) {
		command = ["restart"];
	}
	if ((state.levels.length === 0 || _state.levels.length === 0) && command.length > 0 && command[0] === "rebuild") {
		command = ["restart"];
	}
	if (randomseed === undefined) {
		randomseed = null;
	}
	RandomGen = new RNG(randomseed);

	state = _state;

	if (command[0] !== "rebuild") {
		backups = [];
	}
	//set sprites
	sprites = [];
	let keys = Object.keys(state.objects);
	let keys_l = keys.length;
	for (let k_i = 0; k_i < keys_l; k_i++) {
		const k = keys[k_i];
		let object = state.objects[k];
		let sprite = {
			colors: object.colors,
			dat: object.spritematrix
		};
		sprites[object.id] = sprite;
	}
	if (state.metadata.realtime_interval !== undefined) {
		autotick = 0;
		autotickinterval = state.metadata.realtime_interval * 1000;
	} else {
		autotick = 0;
		autotickinterval = 0;
	}

	if (state.metadata.key_repeat_interval !== undefined) {
		repeatinterval = state.metadata.key_repeat_interval * 1000;
	} else {
		repeatinterval = 150;
	}

	if (state.metadata.again_interval !== undefined) {
		againinterval = state.metadata.again_interval * 1000;
	} else {
		againinterval = 150;
	}
	if (throttle_movement && autotickinterval === 0) {
		logWarning("throttle_movement is designed for use in conjunction with realtime_interval. Using it in other situations makes games gross and unresponsive, broadly speaking.  Please don't.");
	}
	norepeat_action = state.metadata.norepeat_action !== undefined;

	switch (command[0]) {
		case "restart":
			{
				winning = false;
				timer = 0;
				titleScreen = true;
				tryPlayTitleSound();
				textMode = true;
				titleSelection = showContinueOptionOnTitleScreen() ? 1 : 0;
				titleSelected = false;
				quittingMessageScreen = false;
				quittingTitleScreen = false;
				messageselected = false;
				titleMode = 0;
				if (showContinueOptionOnTitleScreen()) {
					titleMode = 1;
				}
				generateTitleScreen();
				break;
			}
		case "rebuild":
			{
				if (titleScreen) {
					generateTitleScreen();
				}
				break;
			}
		case "loadFirstNonMessageLevel": {
			for (let i = 0; i < state.levels.length; i++) {
				if (state.levels[i].hasOwnProperty("message")) {
					continue;
				}
				let targetLevel = i;
				curlevel = targetLevel;
				curlevelTarget = null;
				winning = false;
				timer = 0;
				titleScreen = false;
				textMode = false;
				tick_lazy_function_generation(false);
				titleSelection = showContinueOptionOnTitleScreen() ? 1 : 0;
				titleSelected = false;
				quittingMessageScreen = false;
				quittingTitleScreen = false;
				messageselected = false;
				titleMode = 0;
				loadLevelFromState(state, targetLevel, randomseed);
				break;
			}
			break;
		}
		case "loadLevel":
			{
				let targetLevel = command[1];
				curlevel = targetLevel;
				curlevelTarget = null;
				winning = false;
				timer = 0;
				titleScreen = false;
				textMode = false;
				tick_lazy_function_generation(false);
				titleSelection = showContinueOptionOnTitleScreen() ? 1 : 0;
				titleSelected = false;
				quittingMessageScreen = false;
				quittingTitleScreen = false;
				messageselected = false;
				titleMode = 0;
				loadLevelFromState(state, targetLevel, randomseed);
				break;
			}
		case "levelline":
			{
				let targetLine = command[1];
				for (let i = state.levels.length - 1; i >= 0; i--) {
					let level = state.levels[i];
					if (level.lineNumber <= targetLine + 1) {
						curlevel = i;
						curlevelTarget = null;
						winning = false;
						timer = 0;
						titleScreen = false;
						textMode = false;
						tick_lazy_function_generation(false);
						titleSelection = showContinueOptionOnTitleScreen() ? 1 : 0;
						titleSelected = false;
						quittingMessageScreen = false;
						quittingTitleScreen = false;
						messageselected = false;
						titleMode = 0;
						loadLevelFromState(state, i);
						break;
					}
				}
				break;
			}
	}

	if (command[0] !== "rebuild") {
		clearInputHistory();
	}
	canvasResize();


	if (state.sounds.length === 0) {
		killAudioButton();
	} else {
		showAudioButton();
	}

}

function RebuildGameArrays(){
	_o1 = new BitVec(STRIDE_OBJ);
	_o2 = new BitVec(STRIDE_OBJ);
	_o2_5 = new BitVec(STRIDE_OBJ);
	_o3 = new BitVec(STRIDE_OBJ);
	_o4 = new BitVec(STRIDE_OBJ);
	_o5 = new BitVec(STRIDE_OBJ);
	_o6 = new BitVec(STRIDE_OBJ);
	_o7 = new BitVec(STRIDE_OBJ);
	_o8 = new BitVec(STRIDE_OBJ);
	_o9 = new BitVec(STRIDE_OBJ);
	_o10 = new BitVec(STRIDE_OBJ);
	_o11 = new BitVec(STRIDE_OBJ);
	_o12 = new BitVec(STRIDE_OBJ);
	_m1 = new BitVec(STRIDE_MOV);
	_m2 = new BitVec(STRIDE_MOV);
	_m3 = new BitVec(STRIDE_MOV);
}

function RebuildLevelArrays() {
	level.movements = new Int32Array(level.n_tiles * STRIDE_MOV);

	level.rigidMovementAppliedMask = [];
	level.rigidGroupIndexMask = [];
	level.rowCellContents = [];
	level.rowCellContents_Movements = [];
	level.colCellContents = [];
	level.colCellContents_Movements = [];
	level.mapCellContents = new BitVec(STRIDE_OBJ);
	level.mapCellContents_Movements = new BitVec(STRIDE_MOV);

	//I have these to avoid dynamic allocation - I generate 3 because why not, 
	//but according to my tests I never seem to call this while a previous copy is still in scope
	_movementVecs = [new BitVec(STRIDE_MOV), new BitVec(STRIDE_MOV), new BitVec(STRIDE_MOV)];

	for (let i = 0; i < level.height; i++) {
		level.rowCellContents[i] = new BitVec(STRIDE_OBJ);
	}
	for (let i = 0; i < level.width; i++) {
		level.colCellContents[i] = new BitVec(STRIDE_OBJ);
	}

	for (let i = 0; i < level.height; i++) {
		level.rowCellContents_Movements[i] = new BitVec(STRIDE_MOV);
	}
	for (let i = 0; i < level.width; i++) {
		level.colCellContents_Movements[i] = new BitVec(STRIDE_MOV);
	}

	if (state.rigid){
		for (let i = 0; i < level.n_tiles; i++) {
			level.rigidMovementAppliedMask[i] = new BitVec(STRIDE_MOV);
			level.rigidGroupIndexMask[i] = new BitVec(STRIDE_MOV);
		}
	}
}

let messagetext = "";

function applyDiff(diff, level_objects) {

	let index = 0;

	while (index < diff.dat.length) {
		let start_index = diff.dat[index];
		let copy_length = diff.dat[index + 1];
		if (copy_length === 0) {
			break;//tail of buffer is all 0s
		}
		for (let j = 0; j < copy_length; j++) {
			level_objects[start_index + j] = diff.dat[index + 2 + j];
		}
		index += 2 + copy_length;
	}
}

function unconsolidateDiff(before, after) {

	// If before is not a diff, return it, otherwise generate a complete 'before' 
	// state from the 'after' state and the 'diff' (remember, the diffs are all 
	// backwards...).
	if (!before.hasOwnProperty("diff")) {
		return before;
	}

	let after_objects = new Int32Array(after.dat);
	applyDiff(before, after_objects);

	return {
		dat: after_objects,
		width: before.width,
		height: before.height,
		oldflickscreendat: before.oldflickscreendat
	}
}

function restoreLevel(lev) {
	let diffing = lev.hasOwnProperty("diff");

	oldflickscreendat = lev.oldflickscreendat.concat([]);

	if (diffing) {
		applyDiff(lev, level.objects);
	} else {
		level.objects = new Int32Array(lev.dat);
	}

	if (level.width !== lev.width || level.height !== lev.height) {
		level.width = lev.width;
		level.height = lev.height;
		level.n_tiles = lev.width * lev.height;
		RebuildLevelArrays();
		//regenerate all other stride-related stuff
	}
	else {
		// layercount doesn't change

		for (let i = 0; i < level.n_tiles; i++) {
			level.movements[i] = 0;
		}

		if (state.rigid){
			for (let i = 0; i < level.n_tiles; i++) {
				level.rigidMovementAppliedMask[i].setZero();
				level.rigidGroupIndexMask[i].setZero();
			}
		}

		for (let i = 0; i < level.height; i++) {
			let rcc = level.rowCellContents[i];
			rcc.setZero();
		}
		for (let i = 0; i < level.width; i++) {
			let ccc = level.colCellContents[i];
			ccc.setZero();
		}
	}

	againing = false;
	level.commandQueue = [];
	level.commandQueueSourceRules = [];
}

let zoomscreen = false;
let flickscreen = false;
let screenwidth = 0;
let screenheight = 0;


//compresses 'before' into diff
function consolidateDiff(before, after) {
	if (before.width !== after.width || before.height !== after.height || before.dat.length !== after.dat.length) {
		return before;
	}
	if (before.hasOwnProperty("diff") || after.hasOwnProperty("diff")) {
		return before;
	}
	//only generate diffs if level size is bigger than this
	if (before.dat.length < 1024) {
		return before;
	}
	//diff structure: repeating ( start,length, [ data ] )
	let result = new Int32Array(128);
	let position = 0;
	let chain = false;
	let chain_start_idx_in_diff = -1;
	let before_dat = before.dat;
	let after_dat = after.dat;
	for (let i = 0; i < before_dat.length; i++) {
		if (chain === false) {
			if (before_dat[i] !== after_dat[i]) {
				chain = true;
				chain_start_idx_in_diff = position;

				if (result.length < position + 4) {
					let doubled = new Int32Array(2 * result.length);
					doubled.set(result);
					result = doubled;
				}

				result[position + 0] = i;
				result[position + 1] = 1;
				result[position + 2] = before_dat[i];
				position += 3;
			}
		} else {
			if (before_dat[i] !== after_dat[i]) {

				if (position + 1 >= result.length) {
					if (result.length < position + 4) {
						let doubled = new Int32Array(2 * result.length);
						doubled.set(result);
						result = doubled;
					}
				}
				result[chain_start_idx_in_diff + 1]++;
				result[position] = before_dat[i];
				position++;
			} else {
				chain = false;
			}
		}
	}
	return {
		diff: true,
		dat: result,
		width: before.width,
		height: before.height,
		oldflickscreendat: before.oldflickscreendat
	}
}

function addUndoState(state) {
	backups.push(state);
	if (backups.length > 2 && !backups[backups.length - 1].hasOwnProperty("diff")) {
		backups[backups.length - 3] = consolidateDiff(backups[backups.length - 3], backups[backups.length - 2]);
	}
}

function DoRestart(force) {
	if (restarting === true) {
		return;
	}
	if (force !== true && ('norestart' in state.metadata)) {
		return;
	}

	if (againing) {
		DoUndo(force, true);
	}
	restarting = true;
	if (force !== true) {
		addUndoState(backupLevel());
	}

	if (verbose_logging) {
		consolePrint("--- restarting ---", true);
	}

	restoreLevel(restartTarget);
	tryPlayRestartSound();

	if ('run_rules_on_level_start' in state.metadata) {
		processInput(-1, true);
	}

	level.commandQueue = [];
	level.commandQueueSourceRules = [];
	restarting = false;
}

function backupDiffers() {
	if (backups.length === 0) {
		return true;
	}
	let bak = backups[backups.length - 1];

	if (bak.hasOwnProperty("diff")) {
		return bak.dat.length !== 0 && bak.dat[1] !== 0;//if it's empty or if it's all 0s
	} else {
		for (let i = 0; i < level.objects.length; i++) {
			if (level.objects[i] !== bak.dat[i]) {
				return true;
			}
		}
		return false;
	}
}

function DoUndo(force, ignoreDuplicates) {
	if ((!levelEditorOpened) && ('noundo' in state.metadata && force !== true)) {
		return;
	}
	if (verbose_logging) {
		consolePrint("--- undoing ---", true);
	}

	if (ignoreDuplicates) {
		while (backupDiffers() === false) {
			backups.pop();
		}
	}

	if (backups.length > 0) {
		let torestore = backups[backups.length - 1];
		restoreLevel(torestore);
		backups = backups.splice(0, backups.length - 1);
		if (!force) {
			tryPlayUndoSound();
		}
	}
}

function getPlayerPositions() {
	let result = [];
	let [aggregate,playerMask] = state.playerMask;
	if (aggregate){
		for (let i = 0; i < level.n_tiles; i++) {
			level.getCellInto(i, _o11);
			if (playerMask.bitsSetInArray(_o11.data)) {
				result.push(i);
			}
		}
	} else {
		for (let i = 0; i < level.n_tiles; i++) {
			level.getCellInto(i, _o11);
			if (playerMask.anyBitsInCommon(_o11)) {
				result.push(i);
			}
		}
	}
	return result;
}

function getLayersOfMask(cellMask) {
	let layers = [];
	for (let i = 0; i < state.objectCount; i++) {
		if (cellMask.get(i)) {
			let n = state.idDict[i];
			let o = state.objects[n];
			layers.push(o.layer)
		}
	}
	return layers;
}

let CACHE_MOVEENTITIESATINDEX = {}
function generate_moveEntitiesAtIndex(OBJECT_SIZE, MOVEMENT_SIZE) {
	
	const fn = `'use strict';
    let cellMask = level.getCell(positionIndex);
	${UNROLL("cellMask &= entityMask", OBJECT_SIZE)}
    let layers = getLayersOfMask(cellMask);

	let movementMask=_movementVecs[_movementVecIndex];
	_movementVecIndex=(_movementVecIndex+1)%_movementVecs.length;
	${LEVEL_GET_MOVEMENTS_INTO( "positionIndex", "movementMask", MOVEMENT_SIZE)}

    for (let i=0;i<layers.length;i++) {
    	${ISHIFTOR("movementMask", "dirMask", "(5 * layers[i])")}
    }
		
    ${LEVEL_SET_MOVEMENTS( "positionIndex", "movementMask", MOVEMENT_SIZE)}

	const colIndex=(positionIndex/level.height)|0;
	const rowIndex=(positionIndex%level.height);
	${UNROLL("level.colCellContents_Movements[colIndex] |= movementMask", MOVEMENT_SIZE)}
	${UNROLL("level.rowCellContents_Movements[rowIndex] |= movementMask", MOVEMENT_SIZE)}
	${UNROLL("level.mapCellContents_Movements |= movementMask", MOVEMENT_SIZE)}
	`
	if (fn in CACHE_MOVEENTITIESATINDEX) {
		return CACHE_MOVEENTITIESATINDEX[fn];
	}
	return CACHE_MOVEENTITIESATINDEX[fn] = new Function("level", "positionIndex", "entityMask", "dirMask", fn);
}


let CACHE_CALCULATEROWCOLMASKS = {}
function generate_calculateRowColMasks(OBJECT_SIZE, MOVEMENT_SIZE) {
	const fn = `'use strict';
		level.mapCellContents.data.fill(0);
		level.mapCellContents_Movements.data.fill(0);

		for (let i=0;i<level.width;i++) {
			let ccc = level.colCellContents[i];
			${SET_ZERO("ccc")}
			let ccc_Movements = level.colCellContents_Movements[i];
			${SET_ZERO("ccc_Movements")}
		}

		for (let i=0;i<level.height;i++) {
			let rcc = level.rowCellContents[i];
			${SET_ZERO("rcc")}
			let rcc_Movements = level.rowCellContents_Movements[i];
			${SET_ZERO("rcc_Movements")}
		}

		for (let i=0;i<level.width;i++) {
			for (let j=0;j<level.height;j++) {
				let index = j+i*level.height;
				let cellContents=_o9;
				${LEVEL_GET_CELL_INTO("level", "index", "cellContents", OBJECT_SIZE)}
				${UNROLL("level.mapCellContents |= cellContents", OBJECT_SIZE)}
				${UNROLL("level.rowCellContents[j] |= cellContents", OBJECT_SIZE)}
				${UNROLL("level.colCellContents[i] |= cellContents", OBJECT_SIZE)}
				
				let mapCellContents_Movements=level.getMovementsInto(index,_m1);
				${UNROLL("level.mapCellContents_Movements |= mapCellContents_Movements", MOVEMENT_SIZE)}
				${UNROLL("level.rowCellContents_Movements[j] |= mapCellContents_Movements", MOVEMENT_SIZE)}
				${UNROLL("level.colCellContents_Movements[i] |= mapCellContents_Movements", MOVEMENT_SIZE)}
			}
		}`
	if (fn in CACHE_CALCULATEROWCOLMASKS) {
		return CACHE_CALCULATEROWCOLMASKS[fn];
	}
	return CACHE_CALCULATEROWCOLMASKS[fn] = new Function("level", fn);
}

function startMovement(dir) {
	let movedany = false;
	let playerPositions = getPlayerPositions();
	for (let i = 0; i < playerPositions.length; i++) {
		let playerPosIndex = playerPositions[i];
		state.moveEntitiesAtIndex(level, playerPosIndex, state.playerMask[1], dir);
	}
	return playerPositions;
}

let dirMasksDelta = {
	1: [0, -1],//up
	2: [0, 1],//'down'  : 
	4: [-1, 0],//'left'  : 
	8: [1, 0],//'right' : 
	15: [0, 0],//'?' : 
	16: [0, 0],//'action' : 
	3: [0, 0]//'no'
};

let dirMaskName = {
	1: 'up',
	2: 'down',
	4: 'left',
	8: 'right',
	15: '?',
	16: 'action',
	3: 'no'
};

let seedsToPlay_CanMove = [];
let seedsToPlay_CantMove = [];

function repositionEntitiesOnLayer(positionIndex, layer, dirMask) {
	let delta = dirMasksDelta[dirMask];

	let dx = delta[0];
	let dy = delta[1];
	let tx = ((positionIndex / level.height) | 0);
	let ty = ((positionIndex % level.height));
	let maxx = level.width - 1;
	let maxy = level.height - 1;

	if ((tx === 0 && dx < 0) || (tx === maxx && dx > 0) || (ty === 0 && dy < 0) || (ty === maxy && dy > 0)) {
		return false;
	}

	let targetIndex = (positionIndex + delta[1] + delta[0] * level.height);

	let layerMask = state.layerMasks[layer];
	let targetMask = level.getCellInto(targetIndex, _o7);
	let sourceMask = level.getCellInto(positionIndex, _o8);

	if (layerMask.anyBitsInCommon(targetMask) && (dirMask != 16)) {
		return false;
	}

	for (let i = 0; i < state.sfx_MovementMasks[layer].length; i++) {
		let o = state.sfx_MovementMasks[layer][i];
		let objectMask = o.objectMask;
		if (objectMask.anyBitsInCommon(sourceMask)) {
			let movementMask = level.getMovements(positionIndex);
			let directionMask = o.directionMask;
			if (movementMask.anyBitsInCommon(directionMask) && seedsToPlay_CanMove.indexOf(o.seed) === -1) {
				seedsToPlay_CanMove.push(o.seed);
			}
		}
	}

	let movingEntities = sourceMask.clone();
	sourceMask.iclear(layerMask);
	movingEntities.iand(layerMask);
	targetMask.ior(movingEntities);

	level.setCell(positionIndex, sourceMask);
	level.setCell(targetIndex, targetMask);

	let colIndex = (targetIndex / level.height) | 0;
	let rowIndex = (targetIndex % level.height);

	level.colCellContents[colIndex].ior(movingEntities);
	level.rowCellContents[rowIndex].ior(movingEntities);
	//corresponding movement stuff in setmovements
	return true;
}

let CACHE_REPOSITIONENTITIESATCELL = {}
function generate_repositionEntitiesAtCell(OBJECT_SIZE, MOVEMENT_SIZE) {
	let fn = `'use strict';
    const movementMask = level.getMovements(positionIndex);
    if (${IS_ZERO("movementMask",MOVEMENT_SIZE)}){
        return false;
	}

    let moved = false;
    ${FOR(0,LAYER_COUNT,layer=>`{
        const layerMovement = ${GETSHIFTOR("movementMask",0x1f, 5*layer)};
        if (layerMovement !== 0) {
            const thismoved = repositionEntitiesOnLayer(positionIndex, ${layer}, layerMovement);
            if (thismoved) {
                ${ISHIFTCLEAR("movementMask","layerMovement", 5*layer)}
                moved = true;
            }
        }
	}`)}

	${FOR(0,MOVEMENT_SIZE,i=>`
		level.movements[positionIndex * STRIDE_MOV + ${i}] = movementMask.data[${i}];
	`)}
		
	//corresponding object stuff in repositionEntitiesOnLayer
	const colIndex=(positionIndex/this.height)|0;
	const rowIndex=(positionIndex%level.height);
	${UNROLL("level.colCellContents_Movements[colIndex] |= movementMask",MOVEMENT_SIZE)}
	${UNROLL("level.rowCellContents_Movements[rowIndex] |= movementMask",MOVEMENT_SIZE)}
	${UNROLL("level.mapCellContents_Movements |= movementMask",MOVEMENT_SIZE)}
	
    return moved;`
	if (fn in CACHE_REPOSITIONENTITIESATCELL) {
		return CACHE_REPOSITIONENTITIESATCELL[fn];
	}
	return CACHE_REPOSITIONENTITIESATCELL[fn] = new Function("level", "positionIndex", fn);
}

let ellipsisPattern = ['ellipsis'];


function Rule(rule) {
	this.direction = rule[0]; 		/* direction rule scans in */
	this.patterns = rule[1];		/* lists of CellPatterns to match */
	this.hasReplacements = rule[2];
	this.lineNumber = rule[3];		/* rule source for debugging */
	this.ellipsisCount = rule[4];		/* number of ellipses present */
	this.groupNumber = rule[5];		/* execution group number of rule */
	this.rigid = rule[6];
	this.commands = rule[7];		/* cancel, restart, sfx, etc */
	this.isRandom = rule[8];
	this.cellRowMasks = rule[9];
	this.cellRowMasks_Movements = rule[10];
	this.ruleMask = new BitVec(STRIDE_OBJ);
	this.applyAt = this.generateApplyAt(this.patterns, this.ellipsisCount, STRIDE_OBJ, STRIDE_MOV);
	for (const m of this.cellRowMasks) {
		this.ruleMask.ior(m);
	}

	/*I tried out doing a ruleMask_movements as well along the lines of the above,
	but it didn't help at all - I guess because almost every tick there are movements 
	somewhere on the board - move filtering works well at a row/col level, but is pretty 
	useless (or worse than useless) on a boardwide level*/

	
	this.cellRowMatches = [];
	
	if (lazyFunctionGeneration){
		WORKLIST_OBJECTS_TO_GENERATE_FUNCTIONS_FOR.push(this);
	} else {
		this.generate_all_MatchFunctions();
	}
	/* TODO: eliminate rigid, groupNumber, isRandom
	from this class by moving them up into a RuleGroup class */

	this.findMatches = this.generateFindMatchesFunction();
}

Rule.prototype.generate_all_MatchFunctions = function(){
	for (let i = 0; i < this.patterns.length; i++) {
		this.cellRowMatches.push(this.generateCellRowMatchesFunction(this.patterns[i], this.ellipsisCount[i]));
	}
}

let CACHE_RULE_CELLROWMATCHESFUNCTION = {}
Rule.prototype.generateCellRowMatchesFunction = function (cellRow, ellipsisCount) {
	if (ellipsisCount === 0) {
		let cr_l = cellRow.length;

		// Find which object and movement indices are actually used
		let usedObjectIndices = new Set();
		let usedMovementIndices = new Set();
		
		for (let i = 0; i < cr_l; i++) {
			const pattern = cellRow[i];
			for (let j = 0; j < STRIDE_OBJ; j++) {
				if (pattern.objectsPresent.data[j] || pattern.objectsMissing.data[j]) {
					usedObjectIndices.add(j);
				}
			}
			//and anyObjectsPresent
			for (let j = 0; j < pattern.anyObjectsPresent.length; j++) {
				for (let k = 0; k < STRIDE_OBJ; k++) {
					if (pattern.anyObjectsPresent[j].data[k]) {
						usedObjectIndices.add(k);
					}
				}
			}
			for (let j = 0; j < STRIDE_MOV; j++) {
				if (pattern.movementsPresent.data[j] || pattern.movementsMissing.data[j]) {
					usedMovementIndices.add(j);
				}
			}
		}

		// Generate function with only used indices
		let fn = "";
		const objStride = STRIDE_OBJ === 1 ? '' : '*' + STRIDE_OBJ;
		const movStride = STRIDE_MOV === 1 ? '' : '*' + STRIDE_MOV;
		
		for (let i of usedObjectIndices) {
			fn += 'let cellObjects' + i + ' = objects[i' + objStride + (i ? '+' + i : '') + '];\n';
		}
		for (let i of usedMovementIndices) {
			fn += 'let cellMovements' + i + ' = movements[i' + movStride + (i ? '+' + i : '') + '];\n';
		}
		
		fn += "return " + cellRow[0].generateMatchString('0_');
		for (let cellIndex = 1; cellIndex < cr_l; cellIndex++) {
			fn += "&&cellRow[" + cellIndex + "].matches(i+" + cellIndex + "*d, objects, movements)";
		}
		fn += ";";

		if (fn in CACHE_RULE_CELLROWMATCHESFUNCTION) {
			return CACHE_RULE_CELLROWMATCHESFUNCTION[fn];
		}
		return CACHE_RULE_CELLROWMATCHESFUNCTION[fn] = new Function("cellRow", "i", 'd', 'objects', 'movements', fn);
	} else if (ellipsisCount === 1) {
		let cr_l = cellRow.length;

		let fn = `let result = [];
if(cellRow[0].matches(i, objects, movements)`;
		let cellIndex = 1;
		for (; cellRow[cellIndex] !== ellipsisPattern; cellIndex++) {
			fn += "&&cellRow[" + cellIndex + "].matches(i+" + cellIndex + "*d, objects, movements)";
		}
		cellIndex++;
		fn += `) {
	for (let k=kmin;k<kmax;k++) {
		if(cellRow[`+ cellIndex + `].matches((i+d*(k+` + (cellIndex - 1) + `)), objects, movements)`;
		cellIndex++;
		for (; cellIndex < cr_l; cellIndex++) {
			fn += "&&cellRow[" + cellIndex + "].matches((i+d*(k+" + (cellIndex - 1) + ")), objects, movements)";
		}
		fn += `){
			result.push([i,k]);
		}
	}
}
`;
		fn += "return result;"


		if (fn in CACHE_RULE_CELLROWMATCHESFUNCTION) {
			return CACHE_RULE_CELLROWMATCHESFUNCTION[fn];
		}
		return CACHE_RULE_CELLROWMATCHESFUNCTION[fn] = new Function("cellRow", "i", "kmax", "kmin", 'd', "objects", "movements", fn);
	} else { //ellipsisCount===2
		let cr_l = cellRow.length;

		let ellipsis_index_1 = -1;
		let ellipsis_index_2 = -1;
		for (let cellIndex = 0; cellIndex < cr_l; cellIndex++) {
			if (cellRow[cellIndex] === ellipsisPattern) {
				if (ellipsis_index_1 === -1) {
					ellipsis_index_1 = cellIndex;
				} else {
					ellipsis_index_2 = cellIndex;
					break;
				}
			}
		}

		let fn = `let result = [];
if(cellRow[0].matches(i, objects, movements)`;

		for (let idx = 1; idx < ellipsis_index_1; idx++) {
			fn += "&&cellRow[" + idx + "].matches(i+" + idx + "*d, objects, movements)";
		}
		fn += ") {\n";

		//try match middle part
		fn += `
	for (let k1=k1min;k1<k1max;k1++) {
		if(cellRow[`+ (ellipsis_index_1 + 1) + `].matches((i+d*(k1+` + (ellipsis_index_1 + 1 - 1) + `)), objects, movements)`;
		for (let idx = ellipsis_index_1 + 2; idx < ellipsis_index_2; idx++) {
			fn += "&&cellRow[" + idx + "].matches((i+d*(k1+" + (idx - 1) + ")), objects, movements)";
		}
		fn += "		){\n";
		//try match right part

		fn += `
			for (let k2=k2min;k1+k2<kmax && k2<k2max;k2++) {
				if(cellRow[`+ (ellipsis_index_2 + 1) + `].matches((i+d*(k1+k2+` + (ellipsis_index_2 + 1 - 2) + `)), objects, movements)`;
		for (let idx = ellipsis_index_2 + 2; idx < cr_l; idx++) {
			fn += "&&cellRow[" + idx + "].matches((i+d*(k1+k2+" + (idx - 2) + ")), objects, movements)";
		}
		fn += `
				){
					result.push([i,k1,k2]);
				}
			}
		}
	}			
}	
return result;`;

		if (fn in CACHE_RULE_CELLROWMATCHESFUNCTION) {
			return CACHE_RULE_CELLROWMATCHESFUNCTION[fn];
		}
		return CACHE_RULE_CELLROWMATCHESFUNCTION[fn] = new Function("cellRow", "i", "kmax", "kmin", "k1max", "k1min", "k2max", "k2min", 'd', "objects", "movements", fn);
	}
}


let STRIDE_OBJ = 1;
let STRIDE_MOV = 1;
let LAYER_COUNT = 1;
const FALSE_FUNCTION = new Function("return false;");

// We don't generate the matches functions all at once at initailization, we generate them in the background/as needed

function CellPattern(row) {
	this.objectsPresent = row[0];
	this.objectsMissing = row[1];
	this.anyObjectsPresent = row[2];
	this.movementsPresent = row[3];
	this.movementsMissing = row[4];
	if (lazyFunctionGeneration){
		WORKLIST_OBJECTS_TO_GENERATE_FUNCTIONS_FOR.push(this);
	} else {
		this.matches = this.generateMatchFunction();
	}
	this.replacement = row[5];

};


function CellReplacement(row) {
	this.objectsClear = row[0];
	this.objectsSet = row[1];
	this.movementsClear = row[2];
	this.movementsSet = row[3];
	this.movementsLayerMask = row[4];
	this.randomEntityMask = row[5];
	this.randomDirMask = row[6];
	this.replace = null;
};

CellPattern.prototype.replace = function (level, rule, currentIndex) {
	let fn = this.generateReplaceFunction(
			STRIDE_OBJ,
			STRIDE_MOV,
			rule
		);
	this.replace = fn;
	return this.replace(level, rule, currentIndex);
}

CellPattern.prototype.generateMatchString = function () {
	let fn = "(true";
	for (let i = 0; i < Math.max(STRIDE_OBJ, STRIDE_MOV); ++i) {
		const co = 'cellObjects' + i;
		const cm = 'cellMovements' + i;
		const op = this.objectsPresent.data[i];
		const om = this.objectsMissing.data[i];
		const mp = this.movementsPresent.data[i];
		const mm = this.movementsMissing.data[i];
		if (op) {
			if (op & (op - 1))
				fn += '\t\t&& ((' + co + '&' + op + ')===' + op + ')\n';
			else
				fn += '\t\t&& (' + co + '&' + op + ')\n';
		}
		if (om)
			fn += '\t\t&& !(' + co + '&' + om + ')\n';
		if (mp) {
			if (mp & (mp - 1))
				fn += '\t\t&& ((' + cm + '&' + mp + ')===' + mp + ')\n';
			else
				fn += '\t\t&& (' + cm + '&' + mp + ')\n';
		}
		if (mm)
			fn += '\t\t&& !(' + cm + '&' + mm + ')\n';
	}
	for (let j = 0; j < this.anyObjectsPresent.length; j++) {
		fn += "\t\t&& (0";
		for (let i = 0; i < STRIDE_OBJ; ++i) {
			const aop = this.anyObjectsPresent[j].data[i];
			if (aop)
				fn += "|(cellObjects" + i + "&" + aop + ")";
		}
		fn += ")";
	}
	fn += '\t)';
	return fn;
}

let CACHE_CELLPATTERN_MATCHFUNCTION = new Map();
let _generateMatchFunction_key_array = new Int32Array(0);
CellPattern.prototype.generateMatchFunction = function() {
    // Calculate total size needed for the key array
    const keyLength = STRIDE_OBJ * 2 + STRIDE_MOV * 2 + 
                     this.anyObjectsPresent.length * STRIDE_OBJ + 2;
	if (keyLength!==_generateMatchFunction_key_array.length) {
		_generateMatchFunction_key_array = new Int32Array(keyLength);
	}
    const keyArray = _generateMatchFunction_key_array;
    let keyIndex = 0;

    // Fill the array with data
    for (let i = 0; i < STRIDE_OBJ; i++) {
        keyArray[keyIndex++] = this.objectsPresent.data[i] || 0;
        keyArray[keyIndex++] = this.objectsMissing.data[i] || 0;
    }
    for (let i = 0; i < STRIDE_MOV; i++) {
        keyArray[keyIndex++] = this.movementsPresent.data[i] || 0;
        keyArray[keyIndex++] = this.movementsMissing.data[i] || 0;
    }
    for (let i = 0; i < this.anyObjectsPresent.length; i++) {
        for (let j = 0; j < STRIDE_OBJ; j++) {
            keyArray[keyIndex++] = this.anyObjectsPresent[i].data[j] || 0;
        }
    }
    keyArray[keyIndex++] = STRIDE_OBJ;
    keyArray[keyIndex++] = STRIDE_MOV;
	let str_key = keyArray.toString();

    if (CACHE_CELLPATTERN_MATCHFUNCTION.has(str_key)) {
        return CACHE_CELLPATTERN_MATCHFUNCTION.get(str_key);
    }

    const objStride = STRIDE_OBJ === 1 ? '' : `*${STRIDE_OBJ}`;
    const movStride = STRIDE_MOV === 1 ? '' : `*${STRIDE_MOV}`;
    
    let fn = '';
    
    for (let i = 0; i < STRIDE_OBJ; ++i) {
        fn += `const cellObjects${i} = objects[i${objStride}${i ? '+' + i : ''}];\n`;
    }
    
    for (let i = 0; i < STRIDE_MOV; ++i) {
        fn += `const cellMovements${i} = movements[i${movStride}${i ? '+' + i : ''}];\n`;
    }
    
    fn += `return ${this.generateMatchString()};`;

    const result = new Function("i", "objects", "movements", fn);
    CACHE_CELLPATTERN_MATCHFUNCTION.set(str_key, result);
    return result;
}

let _o1, _o2, _o2_5, _o3, _o4, _o5, _o6, _o7, _o8, _o9, _o10, _o11, _o12;
let _m1, _m2, _m3;

let CACHE_CELLPATTERN_REPLACEFUNCTION = {}
let CACHE_CHECK_COUNT=0;
let CACHE_HIT_COUNT=0;
let _replace_function_key_array = new Int32Array(0);


CellPattern.prototype.generateReplaceFunction = function (OBJECT_SIZE, MOVEMENT_SIZE,rule) {
	if (this.replacement===null){
		return FALSE_FUNCTION;
	}

	const array_len = 3*OBJECT_SIZE + 4*MOVEMENT_SIZE + 3;
	if (array_len!==_replace_function_key_array.length) {
		_replace_function_key_array = new Int32Array(array_len);
	}

	const key_array = _replace_function_key_array;
	for (let i = 0; i < OBJECT_SIZE; i++) {
		key_array[i] = this.replacement.objectsSet.data[i] || 0;
		key_array[i+OBJECT_SIZE] = this.replacement.objectsClear.data[i] || 0;
		key_array[i+2*OBJECT_SIZE+3*MOVEMENT_SIZE] = this.replacement.randomEntityMask.data[i] || 0;
	}
	for (let i = 0; i < MOVEMENT_SIZE; i++) {
		key_array[i+2*OBJECT_SIZE] = this.replacement.movementsSet.data[i] || 0;
		key_array[i+2*OBJECT_SIZE+MOVEMENT_SIZE] = this.replacement.movementsClear.data[i] || 0;
		key_array[i+2*OBJECT_SIZE+2*MOVEMENT_SIZE] = this.replacement.movementsLayerMask.data[i] || 0;
		key_array[i+3*OBJECT_SIZE+3*MOVEMENT_SIZE] = this.replacement.randomDirMask.data[i] || 0;
	}
	key_array[3*OBJECT_SIZE + 4*MOVEMENT_SIZE] = OBJECT_SIZE;
	key_array[3*OBJECT_SIZE + 4*MOVEMENT_SIZE+1] = MOVEMENT_SIZE;
	key_array[3*OBJECT_SIZE + 4*MOVEMENT_SIZE+2] = rule.rigid;

	const key = key_array.toString();
	if (key in CACHE_CELLPATTERN_REPLACEFUNCTION) {
		return CACHE_CELLPATTERN_REPLACEFUNCTION[key];
	}
	
	const replace_randomEntityMask_zero = this.replacement.randomEntityMask.iszero()
	const replace_randomDirMask_zero = this.replacement.randomDirMask.iszero()
	let deterministic = replace_randomEntityMask_zero && replace_randomDirMask_zero;

	let fn = `	
		let replace = this.replacement;

		if (replace === null) {
			return false;
		}

		const replace_RandomEntityMask = replace.randomEntityMask;
		const replace_RandomDirMask = replace.randomDirMask;

		// Using IMPORT_COMPILE_TIME_ARRAY should make the following three declarations faster,
		// but it really slows down the compiler.
		const objectsSet = _o1;	
		${UNROLL("objectsSet = replace.objectsSet", OBJECT_SIZE)}
	
		const objectsClear = _o2;
		${UNROLL("objectsClear = replace.objectsClear", OBJECT_SIZE)}

		const movementsSet = _m1;
		${UNROLL("movementsSet = replace.movementsSet", MOVEMENT_SIZE)}
		
		const movementsClear = _m2;
		
		${FOR(0,MOVEMENT_SIZE,i=>
			`movementsClear.data[${i}] = ${this.replacement.movementsClear.data[i] | this.replacement.movementsLayerMask.data[i]};\n`
		)}

		${IF_LAZY(!replace_randomEntityMask_zero,()=>`
			const choices=[];
			${FOR(0,(32*OBJECT_SIZE),i =>
			`{
				if (${this.replacement.randomEntityMask.get(i)}) {
					choices.push(${i});
				}
			}`
			)}
			const rand = choices[Math.floor(RandomGen.uniform() * choices.length)];
			const n = state.idDict[rand];
			const o = state.objects[n];
			${IBITSET("objectsSet", "rand")}
			${UNROLL("objectsClear |= state.layerMasks[o.layer]", OBJECT_SIZE)}
			${ISHIFTOR("movementsClear", "0x1f", "(5 * o.layer)")}
		`)}
		${IF_LAZY(!replace_randomDirMask_zero,()=>`
			${FOR(0, LAYER_COUNT, layerIndex =>
			`{
				if (${GET("replace_RandomDirMask", 5*layerIndex )}) {
					const randomDir = Math.floor(RandomGen.uniform()*4);
					${IBITSET("movementsSet", `(randomDir + 5 * ${layerIndex})`)}
				}
			}`
			)}
		`)}
		


		const oldCellMask = _o3;
		${LEVEL_GET_CELL_INTO("level", "currentIndex", "oldCellMask", OBJECT_SIZE)}

		const curCellMask = _o2_5;
		${FOR(0, OBJECT_SIZE,i=>`
			curCellMask.data[${i}] = (oldCellMask.data[${i}] & (~objectsClear.data[${i}])) | objectsSet.data[${i}];
		`)}

		const oldMovementMask = level.getMovements(currentIndex);
		const curMovementMask = _m3;
		${FOR(0, MOVEMENT_SIZE, i => `
			curMovementMask.data[${i}] = (oldMovementMask.data[${i}] & (~movementsClear.data[${i}])) | movementsSet.data[${i}]
		`)}


		let curRigidGroupIndexMask;
		let curRigidMovementAppliedMask;
		let rigidchange=false;		
		${IF_LAZY(rule.rigid,()=>`
			const rigidGroupIndex = ${state.groupNumber_to_RigidGroupIndex[rule.groupNumber]+1};
			const rigidMask = new BitVec(${STRIDE_MOV});
			${FOR(0,level.layerCount,layer=>`
				${ISHIFTOR("rigidMask", "rigidGroupIndex", layer * 5)}
			`)}
			${UNROLL("rigidMask &= replace.movementsLayerMask", MOVEMENT_SIZE)}
			
			curRigidGroupIndexMask = level.rigidGroupIndexMask[currentIndex] || new BitVec(${STRIDE_MOV});
			curRigidMovementAppliedMask = level.rigidMovementAppliedMask[currentIndex] || new BitVec(${STRIDE_MOV});

			if (${NOT_BITS_SET_IN_ARRAY("rigidMask", "curRigidGroupIndexMask.data", MOVEMENT_SIZE)} &&
				${NOT_BITS_SET_IN_ARRAY("replace.movementsLayerMask", "curRigidMovementAppliedMask.data", MOVEMENT_SIZE)}) 
			{
				${UNROLL("curRigidGroupIndexMask |= rigidMask", MOVEMENT_SIZE)}
				${UNROLL("curRigidMovementAppliedMask |= replace.movementsLayerMask", MOVEMENT_SIZE)}
				rigidchange=true;
			}
		`)}
		
		if (${EQUALS("oldCellMask", "curCellMask", OBJECT_SIZE)} 
			&& ${EQUALS("oldMovementMask", "curMovementMask", MOVEMENT_SIZE)} 
			&& !rigidchange) { 
			//nothing changed
			return false;
		}
				
		if (rigidchange) {
			level.rigidGroupIndexMask[currentIndex] = curRigidGroupIndexMask;
			level.rigidMovementAppliedMask[currentIndex] = curRigidMovementAppliedMask;
		}

		const created = _o4;
		${UNROLL("created = curCellMask", OBJECT_SIZE)}
		${UNROLL("created &= ~oldCellMask", OBJECT_SIZE)}
		${UNROLL("sfxCreateMask |= created", OBJECT_SIZE)}
		
		const destroyed = _o5;
		${UNROLL("destroyed = oldCellMask", OBJECT_SIZE)}
		${UNROLL("destroyed &= ~curCellMask", OBJECT_SIZE)}
		${UNROLL("sfxDestroyMask |= destroyed", OBJECT_SIZE)}

		${LEVEL_SET_CELL("level", "currentIndex", "curCellMask", OBJECT_SIZE)}
		${LEVEL_SET_MOVEMENTS( "currentIndex", "curMovementMask", MOVEMENT_SIZE)}

		const colIndex=(currentIndex/level.height)|0;
		const rowIndex=(currentIndex%level.height);

		${UNROLL("level.colCellContents[colIndex] |= curCellMask", OBJECT_SIZE)}
		${UNROLL("level.rowCellContents[rowIndex] |= curCellMask", OBJECT_SIZE)}
		${UNROLL("level.mapCellContents |= curCellMask", OBJECT_SIZE)}
		return true;	
	`

	return CACHE_CELLPATTERN_REPLACEFUNCTION[key] = new Function("level", "rule", "currentIndex", fn);
}


let CACHE_MATCHCELLROW = {}
function generateMatchCellRow(OBJECT_SIZE, MOVEMENT_SIZE) {
	const fn = `'use strict';
	let result=[];
	
	if ((${NOT_BITS_SET_IN_ARRAY("cellRowMask", "level.mapCellContents.data", OBJECT_SIZE)})||
	(${NOT_BITS_SET_IN_ARRAY("cellRowMask_Movements", "level.mapCellContents_Movements.data", MOVEMENT_SIZE)})) {
		return result;
	}

	let xmin=0;
	let xmax=level.width;
	let ymin=0;
	let ymax=level.height;

    let len=cellRow.length;

    switch(direction) {
    	case 1://up
    	{
    		ymin+=(len-1);
    		break;
    	}
    	case 2: //down 
    	{
			ymax-=(len-1);
			break;
    	}
    	case 4: //left
    	{
    		xmin+=(len-1);
    		break;
    	}
    	case 8: //right
		{
			xmax-=(len-1);	
			break;
		}
    	default:
    	{
    		window.console.log("EEEP "+direction);
    	}
    }

    const horizontal=direction>2;
    if (horizontal) {
		for (let y=ymin;y<ymax;y++) {
			if (${NOT_BITS_SET_IN_ARRAY("cellRowMask", "level.rowCellContents[y].data", OBJECT_SIZE)} 
			|| ${NOT_BITS_SET_IN_ARRAY("cellRowMask_Movements", "level.rowCellContents_Movements[y].data", MOVEMENT_SIZE)}) {
				continue;
			}

			for (let x=xmin;x<xmax;x++) {
				const i = x*level.height+y;
				if (cellRowMatch(cellRow,i,d, level.objects, level.movements))
				{
					result.push(i);
				}
			}
		}
	} else {
		for (let x=xmin;x<xmax;x++) {
			if (${NOT_BITS_SET_IN_ARRAY("cellRowMask", "level.colCellContents[x].data", OBJECT_SIZE)}
			|| ${NOT_BITS_SET_IN_ARRAY("cellRowMask_Movements", "level.colCellContents_Movements[x].data", MOVEMENT_SIZE)}) {
				continue;
			}

			for (let y=ymin;y<ymax;y++) {
				const i = x*level.height+y;
				if (cellRowMatch(cellRow,i, d, level.objects, level.movements))
				{
					result.push(i);
				}
			}
		}		
	}

	return result;`
	if (fn in CACHE_MATCHCELLROW) {
		return CACHE_MATCHCELLROW[fn];
	}
	return CACHE_MATCHCELLROW[fn] = new Function("level", "direction", "cellRowMatch", "cellRow", "cellRowMask", "cellRowMask_Movements", "d", fn);
}

let CACHE_MATCHCELLROWWILDCARD = {}
function generateMatchCellRowWildCard(OBJECT_SIZE, MOVEMENT_SIZE) {
	const fn = `'use strict';
	let result=[];
	if ((${NOT_BITS_SET_IN_ARRAY("cellRowMask", "level.mapCellContents.data", OBJECT_SIZE)})||
	(${NOT_BITS_SET_IN_ARRAY("cellRowMask_Movements", "level.mapCellContents_Movements.data", MOVEMENT_SIZE)})) {
		return result;
	}
	
	let xmin=0;
	let xmax=level.width;
	let ymin=0;
	let ymax=level.height;

	let len=cellRow.length-wildcardCount;//remove one to deal with wildcard
    switch(direction) {
    	case 1://up
    	{
    		ymin+=(len-1);
    		break;
    	}
    	case 2: //down 
    	{
			ymax-=(len-1);
			break;
    	}
    	case 4: //left
    	{
    		xmin+=(len-1);
    		break;
    	}
    	case 8: //right
		{
			xmax-=(len-1);	
			break;
		}
    	default:
    	{
    		window.console.log("EEEP2 "+direction);
    	}
    }

    const horizontal=direction>2;
    if (horizontal) {
		for (let y=ymin;y<ymax;y++) {
			if (${NOT_BITS_SET_IN_ARRAY("cellRowMask", "level.rowCellContents[y].data", OBJECT_SIZE)}
			|| ${NOT_BITS_SET_IN_ARRAY("cellRowMask_Movements", "level.rowCellContents_Movements[y].data", MOVEMENT_SIZE)}) {
				continue;
			}

			for (let x=xmin;x<xmax;x++) {
				const i = x*level.height+y;
				let kmax;

				if (direction === 4) { //left
					kmax=x-len+2;
				} else if (direction === 8) { //right
					kmax=level.width-(x+len)+1;	
				} else {
					window.console.log("EEEP2 "+direction);					
				}

				if (wildcardCount===1) {
					result.push.apply(result, cellRowMatch(cellRow,i,kmax,0, d, level.objects, level.movements));
				} else {
					result.push.apply(result, cellRowMatch(cellRow,i,kmax,0,kmax,0,kmax,0, d, level.objects, level.movements));
				}
			}
		}
	} else {
		for (let x=xmin;x<xmax;x++) {
			if (${NOT_BITS_SET_IN_ARRAY("cellRowMask", "level.colCellContents[x].data", OBJECT_SIZE)}
			|| ${NOT_BITS_SET_IN_ARRAY("cellRowMask_Movements", "level.colCellContents_Movements[x].data", MOVEMENT_SIZE)}) {
				continue;
			}

			for (let y=ymin;y<ymax;y++) {
				const i = x*level.height+y;
				let kmax;

				if (direction === 2) { // down
					kmax=level.height-(y+len)+1;
				} else if (direction === 1) { // up
					kmax=y-len+2;					
				} else {
					window.console.log("EEEP2 "+direction);
				}
				if (wildcardCount===1) {
					result.push.apply(result, cellRowMatch(cellRow,i,kmax,0, d, level.objects, level.movements));
				} else {
					result.push.apply(result, cellRowMatch(cellRow,i,kmax,0, kmax,0, kmax,0, d, level.objects, level.movements));
				}
			}
		}		
	}

	return result;`
	//function matchCellRowWildCard(direction, cellRowMatch, cellRow,cellRowMask,cellRowMask_Movements,d,wildcardCount) {
	if (fn in CACHE_MATCHCELLROWWILDCARD) {
		return CACHE_MATCHCELLROWWILDCARD[fn];
	}
	return CACHE_MATCHCELLROWWILDCARD[fn] = new Function("direction", "cellRowMatch", "cellRow", "cellRowMask", "cellRowMask_Movements", "d", "wildcardCount", fn);
}

function generateTuples(lists) {
	let tuples = [[]];

	for (let i = 0; i < lists.length; i++) {
		const row = lists[i];
		const newtuples = [];
		for (let j = 0; j < row.length; j++) {
			let valtoappend = row[j];
			for (let k = 0; k < tuples.length; k++) {
				const tuple = tuples[k];
				const newtuple = tuple.concat([valtoappend]);
				newtuples.push(newtuple);
			}
		}
		tuples = newtuples;
	}
	return tuples;
}

Rule.prototype.findMatches = function () {
	if (!this.ruleMask.bitsSetInArray(level.mapCellContents.data))
		return [];

	const d = level.delta_index(this.direction)

	let matches = [];
	const cellRowMasks = this.cellRowMasks;
	const cellRowMasks_Movements = this.cellRowMasks_Movements;
	for (let cellRowIndex = 0; cellRowIndex < this.patterns.length; cellRowIndex++) {
		const cellRow = this.patterns[cellRowIndex];
		const matchFunction = this.cellRowMatches[cellRowIndex];
		let match;
		if (this.ellipsisCount[cellRowIndex] === 0) {
			match = state.matchCellRow(level, this.direction, matchFunction, cellRow, cellRowMasks[cellRowIndex], cellRowMasks_Movements[cellRowIndex], d);
		} else { // ellipsiscount===1/2
			match = state.matchCellRowWildCard(this.direction, matchFunction, cellRow, cellRowMasks[cellRowIndex], cellRowMasks_Movements[cellRowIndex], d, this.ellipsisCount[cellRowIndex]);
		}
		if (match.length === 0) {
			return [];
		} else {
			matches.push(match);
		}
	}
	return matches;
};

Rule.prototype.directional = function () {
	//Check if other rules in its rulegroup with the same line number.
	for (let i = 0; i < state.rules.length; i++) {
		const rg = state.rules[i];
		let copyCount = 0;
		for (let j = 0; j < rg.length; j++) {
			if (this.lineNumber === rg[j].lineNumber) {
				copyCount++;
			}
			if (copyCount > 1) {
				return true;
			}
		}
	}

	return false;
}

function IF(condition) {
	if (condition) {
		return "";
	} else {
		return "/*";
	}
}

function IF_LAZY(condition, fn) {
	if (condition) {
		return fn();
	} else {
		return "";
	}
}

function IF_ELSE_LAZY(condition, fn_if, fn_else) {
	if (condition) {
		return fn_if();
	} else {
		return fn_else();
	}
}

function ENDIF(condition) {
	if (condition) {
		return "";
	} else {
		return "*/";
	}
}
function ELSE(condition) {
	if (condition) {
		return "/*";
	} else {
		return "*/";
	}
}
function ENDELSE(condition) {
	if (condition) {
		return "*/";
	} else {
		return "";
	}
}

function FOR(start, end, fn) {
	let result = "";
	for (let i = start; i < end; i++) {
		result += fn(i);
	}
	return result;
}

let CACHE_RULE_APPLYAT = {}
Rule.prototype.generateApplyAt = function (patterns, ellipsisCount, OBJECT_SIZE, MOVEMENT_SIZE) {
	const fn = `'use strict';
	//have to double check they apply 
	//(cf test ellipsis bug: rule matches two candidates, first replacement invalidates second)
	if (check)
	{
	${FOR(0, patterns.length, cellRowIndex => `
		{
			${IF(ellipsisCount[cellRowIndex] === 0)}
				if ( ! this.cellRowMatches[${cellRowIndex}](
					this.patterns[${cellRowIndex}], 
						tuple[${cellRowIndex}], 
						delta, level.objects, level.movements
						) )
				return false
			${ENDIF(ellipsisCount[cellRowIndex] === 0)}
			${IF(ellipsisCount[cellRowIndex] === 1)}
				if ( this.cellRowMatches[${cellRowIndex}](
						this.patterns[${cellRowIndex}], 
						tuple[${cellRowIndex}][0], 
						tuple[${cellRowIndex}][1]+1, 
							tuple[${cellRowIndex}][1], 
						delta, level.objects, level.movements
					).length === 0 )
					return false
			${ENDIF(ellipsisCount[cellRowIndex] === 1)}
			${IF(ellipsisCount[cellRowIndex] === 2)}
				if ( this.cellRowMatches[${cellRowIndex}](
						this.patterns[${cellRowIndex}], 
						tuple[${cellRowIndex}][0],  
						tuple[${cellRowIndex}][1]+tuple[${cellRowIndex}][2]+1, 
							tuple[${cellRowIndex}][1]+tuple[${cellRowIndex}][2], 
						tuple[${cellRowIndex}][1]+1, 
							tuple[${cellRowIndex}][1],  
						tuple[${cellRowIndex}][2]+1, 
							tuple[${cellRowIndex}][2], 
							delta, level.objects, level.movements
						).length === 0 )
					return false
			${ENDIF(ellipsisCount[cellRowIndex] === 2)}
		}`)}
	}

    let result=false;
	let anyellipses=false;

    //APPLY THE RULE
	${FOR(0, patterns.length, cellRowIndex => {
		const preRow = patterns[cellRowIndex];
		return `
			{
				let ellipse_index=0;
				let currentIndex = ${ellipsisCount[cellRowIndex] > 0 ? `tuple[${cellRowIndex}][0]` : `tuple[${cellRowIndex}]`}
				${FOR(0, preRow.length, cellIndex => `
					{
						${IF(preRow[cellIndex] === ellipsisPattern)}
							const k = tuple[${cellRowIndex}][1+ellipse_index];
							ellipse_index++;
							anyellipses=true;
							currentIndex += delta*k;
						${ELSE(preRow[cellIndex] === ellipsisPattern)}
							const preCell = this.patterns[${cellRowIndex}][${cellIndex}];
							result = preCell.replace(level,this, currentIndex) || result;
							currentIndex += delta;
						${ENDELSE(preRow[cellIndex] === ellipsisPattern)}
					}
				`)}
			}`
	}
	)}

	if (verbose_logging && result){
		let ruleDirection = dirMaskName[this.direction];
		if (!this.directional()){
			ruleDirection="";
		}

		let inspect_ID =  addToDebugTimeline(level,this.lineNumber);
		let gapMessage="";
		
		let logString = '<font color="green">Rule <a onclick="jumpToLine(' + this.lineNumber + ');" href="javascript:void(0);">' + this.lineNumber + '</a> ' + ruleDirection + ' applied' + gapMessage + '.</font>';
		consolePrint(logString,false,this.lineNumber,inspect_ID);
		
	}

    return result;
	`
	if (fn in CACHE_RULE_APPLYAT) {
		return CACHE_RULE_APPLYAT[fn];
	}
	return CACHE_RULE_APPLYAT[fn] = new Function("level", "tuple", "check", "delta", fn);
};

Rule.prototype.tryApply = function (level) {
	const delta = level.delta_index(this.direction);

	//get all cellrow matches
	let matches = this.findMatches(level);
	if (matches.length === 0) {
		return false;
	}

	let result = false;
	if (this.hasReplacements) {
		let tuples = generateTuples(matches);
		for (let tupleIndex = 0; tupleIndex < tuples.length; tupleIndex++) {
			let tuple = tuples[tupleIndex];
			let shouldCheck = tupleIndex > 0;
			let success = this.applyAt(level, tuple, shouldCheck, delta);
			result = success || result;
		}
	}

	if (matches.length > 0) {
		this.queueCommands();
	}
	return result;
};

Rule.prototype.queueCommands = function () {

	if (this.commands.length === 0) {
		return;
	}

	//commandQueue is an array of strings, message.commands is an array of array of strings (For messagetext parameter), so I search through them differently
	let preexisting_cancel = level.commandQueue.indexOf("cancel") >= 0;
	let preexisting_restart = level.commandQueue.indexOf("restart") >= 0;

	let currule_cancel = false;
	let currule_restart = false;
	for (let i = 0; i < this.commands.length; i++) {
		let cmd = this.commands[i][0];
		if (cmd === "cancel") {
			currule_cancel = true;
		} else if (cmd === "restart") {
			currule_restart = true;
		}
	}

	//priority cancel > restart > everything else
	//if cancel is the queue from other rules, ignore everything
	if (preexisting_cancel) {
		return;
	}
	//if restart is in the queue from other rules, only apply if there's a cancel present here
	if (preexisting_restart && !currule_cancel) {
		return;
	}

	//if you are writing a cancel or restart, clear the current queue
	if (currule_cancel || currule_restart) {
		level.commandQueue = [];
		level.commandQueueSourceRules = [];
		messagetext = "";
	}

	for (let i = 0; i < this.commands.length; i++) {
		const command = this.commands[i];
		let already = false;
		if (level.commandQueue.indexOf(command[0]) >= 0) {
			continue;
		}
		level.commandQueue.push(command[0]);
		level.commandQueueSourceRules.push(this);

		if (verbose_logging) {
			const lineNumber = this.lineNumber;
			const ruleDirection = dirMaskName[this.direction];
			const logString = '<font color="green">Rule <a onclick="jumpToLine(' + lineNumber.toString() + ');"  href="javascript:void(0);">' + lineNumber.toString() + '</a> triggers command ' + command[0] + '.</font>';
			consolePrint(logString, false, lineNumber, null);
		}

		if (command[0] === 'message') {
			messagetext = command[1];
		}
	}
};

function showTempMessage() {
	keybuffer = [];
	textMode = true;
	titleScreen = false;
	quittingMessageScreen = false;
	messageselected = false;
	ignoreNotJustPressedAction = true;
	tryPlayShowMessageSound();
	drawMessageScreen();
	canvasResize();
}

function processOutputCommands(commands) {
	for (let i = 0; i < commands.length; i++) {
		let command = commands[i];
		if (command.charAt(1) === 'f') {//identifies sfxN
			tryPlaySimpleSound(command);
		}
		if (unitTesting === false) {
			if (command === 'message') {
				showTempMessage();
			}
		}
	}
}

function applyRandomRuleGroup(level, ruleGroup) {
	let propagated = false;

	let matches = [];
	for (let ruleIndex = 0; ruleIndex < ruleGroup.length; ruleIndex++) {
		let rule = ruleGroup[ruleIndex];
		let ruleMatches = rule.findMatches(level);
		if (ruleMatches.length > 0) {
			let tuples = generateTuples(ruleMatches);
			for (let j = 0; j < tuples.length; j++) {
				let tuple = tuples[j];
				matches.push([ruleIndex, tuple]);
			}
		}
	}

	if (matches.length === 0) {
		return false;
	}

	let match = matches[Math.floor(RandomGen.uniform() * matches.length)];
	let ruleIndex = match[0];
	let rule = ruleGroup[ruleIndex];
	let tuple = match[1];
	let check = false;
	const delta = level.delta_index(rule.direction)
	let modified = rule.applyAt(level, tuple, check, delta);

	rule.queueCommands();

	return modified;
}


function applyRuleGroup(ruleGroup) {
    if (ruleGroup[0].isRandom) {
        return applyRandomRuleGroup(level, ruleGroup);
    }

    const MAX_LOOP_COUNT = 200;
    const GROUP_LENGTH = ruleGroup.length;
    const shouldLog = verbose_logging;
    let hasChanges = false;        
    let madeChangeThisLoop = true; 
    let loopcount = 0;
    
    while (madeChangeThisLoop && loopcount++ < MAX_LOOP_COUNT) {
        madeChangeThisLoop = false;
        let consecutiveFailures = 0;

        for (let ruleIndex = 0; ruleIndex < GROUP_LENGTH; ruleIndex++) {
            const rule = ruleGroup[ruleIndex];
            
            if (rule.tryApply(level)) {
                madeChangeThisLoop = true;
                consecutiveFailures = 0;
            } else {
                consecutiveFailures++;
                if (consecutiveFailures === GROUP_LENGTH) {
                    break;  // No rule can apply - exit early
                }
            }            
        }

        if (madeChangeThisLoop) {
            hasChanges = true;
            if (shouldLog) {
                debugger_turnIndex++;
                addToDebugTimeline(level, -2);
            }
        }
    }

    if (loopcount >= MAX_LOOP_COUNT) {
        logErrorCacheable("Got caught looping lots in a rule group :O", ruleGroup[0].lineNumber, true);
    }

    return hasChanges;
}

function applyRules(rules, loopPoint, bannedGroup) {
    let loopPropagated = false;
    let loopCount = 0;
    let ruleGroupIndex = 0;
	const RULES_COUNT = rules.length;
    while (ruleGroupIndex < RULES_COUNT) {
        // Apply rules if not banned
        if (!bannedGroup || !bannedGroup[ruleGroupIndex]) {
            loopPropagated = applyRuleGroup(rules[ruleGroupIndex]) || loopPropagated;
        }

        // Handle mid-sequence loop point
        if (loopPropagated && loopPoint[ruleGroupIndex] !== undefined) {
            ruleGroupIndex = loopPoint[ruleGroupIndex];
            loopPropagated = false;
            loopCount++;
            
            if (loopCount > 200) {
                logErrorCacheable("got caught in an endless startloop...endloop vortex, escaping!", rules[ruleGroupIndex][0].lineNumber, true);
                break;
            }

            if (verbose_logging) {
                debugger_turnIndex++;
                addToDebugTimeline(level, -2);
            }
            continue;
        }

        ruleGroupIndex++;
        
        // Handle end-sequence loop point
        if (ruleGroupIndex === rules.length && loopPropagated && loopPoint[ruleGroupIndex] !== undefined) {
            ruleGroupIndex = loopPoint[ruleGroupIndex];
            loopPropagated = false;
            loopCount++;
            
            if (loopCount > 200) {
                logErrorCacheable("got caught in an endless startloop...endloop vortex, escaping!", rules[ruleGroupIndex][0].lineNumber, true);
                break;
            }
        }

        if (verbose_logging) {
            debugger_turnIndex++;
            addToDebugTimeline(level, -2);
        }
    }
}

let CACHE_RESOLVEMOVEMENTS = {}
function generate_resolveMovements(OBJECT_SIZE, MOVEMENT_SIZE,state) {
	const fn = `'use strict';
		let moved=true;
		while(moved){
			moved=false;
			for (let i=0;i<level.n_tiles;i++) {
				moved = state.repositionEntitiesAtCell(level,i) || moved;
			}
		}
		let doUndo=false;
	
		//Search for any rigidly-caused movements remaining
		for (let i=0;i<level.n_tiles;i++) {
			let cellMask = level.getCellInto(i,_o6);
			let movementMask = level.getMovements(i);
			if (${IS_NONZERO("movementMask", MOVEMENT_SIZE)}) {

				${IF_LAZY(state.rigid,()=>`
					let rigidMovementAppliedMask = level.rigidMovementAppliedMask[i];
				if (${IS_NONZERO("rigidMovementAppliedMask", MOVEMENT_SIZE)}) {
					${UNROLL("movementMask &= rigidMovementAppliedMask", MOVEMENT_SIZE)}
					if (${IS_NONZERO("movementMask", MOVEMENT_SIZE)}) 
				outer_area: {
						//find what layer was restricted
						${FOR(0,LAYER_COUNT,j=>`{
							let layerSection = ${GETSHIFTOR("movementMask", 0x1f, 5*j)};
							if (layerSection!==0) {
								//this is our layer!
								let rigidGroupIndexMask = level.rigidGroupIndexMask[i];
								let rigidGroupIndex = ${GETSHIFTOR("rigidGroupIndexMask", 0x1f, 5*j)};
								rigidGroupIndex--;//group indices start at zero, but are incremented for storing in the bitfield
								let groupIndex = state.rigidGroupIndex_to_GroupIndex[rigidGroupIndex];
								if (bannedGroup[groupIndex]!==true){
									bannedGroup[groupIndex]=true
									doUndo=true;
								}
								break outer_area;
							}
						}`)}
					}
				}`)}


				for (let j=0;j<state.sfx_MovementFailureMasks.length;j++) {
					let o = state.sfx_MovementFailureMasks[j];
					let objectMask = o.objectMask;
		
					if (${ANY_BITS_IN_COMMON("cellMask", "objectMask", OBJECT_SIZE)} 
					&& ${ANY_BITS_IN_COMMON("o.directionMask","movementMask", MOVEMENT_SIZE)} 
					&& seedsToPlay_CantMove.indexOf(o.seed)===-1) {
						seedsToPlay_CantMove.push(o.seed);
					}
				}
			}

			for (let j=0;j<STRIDE_MOV;j++) {
				level.movements[j+i*STRIDE_MOV]=0;
			}

			${IF(state.rigid)}
				${SET_ZERO("level.rigidGroupIndexMask[i]")}
				${SET_ZERO("level.rigidMovementAppliedMask[i]")}
			${ENDIF(state.rigid)}

		}
		return doUndo;
	`
	//	function resolveMovements(level, bannedGroup){
	if (fn in CACHE_RESOLVEMOVEMENTS) {
		return CACHE_RESOLVEMOVEMENTS[fn];
	}
	return CACHE_RESOLVEMOVEMENTS[fn] = new Function("level", "bannedGroup", fn);
}

let sfxCreateMask = null;
let sfxDestroyMask = null;

/* returns a bool indicating if anything changed */
function processInput(dir, dontDoWin, dontModify) {
	againing = false;

	let bak = backupLevel();
	let inputindex = dir;
	let playerPositions = [];

	if (verbose_logging) {
		debugger_turnIndex++;
		addToDebugTimeline(level, -2); // pre-movement-applied debug state
	}

	if (dir >= 0) {
		switch (dir) {
			case 0: // up
				dir = parseInt('00001', 2);
				break;
			case 1: // left
				dir = parseInt('00100', 2);
				break;
			case 2: // down
				dir = parseInt('00010', 2);
				break;
			case 3: // right
				dir = parseInt('01000', 2);
				break;
			case 4: // action
				dir = parseInt('10000', 2);
				break;
		}
		playerPositions = startMovement(dir);
	}

	if (verbose_logging) {
		consolePrint('Applying rules');
		let inspect_ID = addToDebugTimeline(level, -1);
		if (dir === -1) {
			consolePrint(`Turn starts with no input.`, false, null, inspect_ID);
		} else {
			consolePrint(`Turn starts with input of ${['up', 'left', 'down', 'right', 'action'][inputindex]}.`, false, null, inspect_ID);
		}
	}

	// Initialize the variables we make use of in the course of our turn
	let bannedGroup = [];
	level.commandQueue = [];
	level.commandQueueSourceRules = [];
	let rigidloop = false;
	const startState = {
		objects: new Int32Array(level.objects),
		movements: new Int32Array(level.movements),
		rigidGroupIndexMask: level.rigidGroupIndexMask.concat([]),
		rigidMovementAppliedMask: level.rigidMovementAppliedMask.concat([]),
		commandQueue: [],
		commandQueueSourceRules: []
	};
	sfxCreateMask.setZero();
	sfxDestroyMask.setZero();
	seedsToPlay_CanMove = [];
	seedsToPlay_CantMove = [];
	state.calculateRowColMasks(level);
	let alreadyResolved = [];

	// The main loop (dominated by rigid, but if you ignore that nonsense, it's
	// not too complicated)!
	let i = 0;
	do {
		rigidloop = false;
		i++;

		//everything outside of these two lines in this loop is rigid-body nonsense
		applyRules(state.rules, state.loopPoint, bannedGroup);
		let shouldUndo = state.resolveMovements(level, bannedGroup);

		if (shouldUndo) {
			rigidloop = true;

			// trackback
			if (IDE) {
				let newBannedGroups = [];
				for (let key in bannedGroup) {
					if (!alreadyResolved.includes(key)) {
						newBannedGroups.push(key);
						alreadyResolved.push(key);
					}
				}
				let bannedLineNumbers = newBannedGroups.map(rgi => state.rules[rgi][0].lineNumber);
				let ts = bannedLineNumbers.length > 1 ? "lines " : "line ";
				ts += bannedLineNumbers.map(ln => `<a onclick="jumpToLine(${ln});" href="javascript:void(0);">${ln}</a>`).join(", ");
				consolePrint(`Rigid movement application failed in rule-Group starting from ${ts}, and will be disabled in resimulation. Rolling back...`);
			}
			level.objects = new Int32Array(startState.objects);
			level.movements = new Int32Array(startState.movements);
			level.rigidGroupIndexMask = startState.rigidGroupIndexMask.concat([]);
			level.rigidMovementAppliedMask = startState.rigidMovementAppliedMask.concat([]);
			level.commandQueue = startState.commandQueue.concat([]);
			level.commandQueueSourceRules = startState.commandQueueSourceRules.concat([]);
			sfxCreateMask.setZero();
			sfxDestroyMask.setZero();

			if (verbose_logging && rigidloop && i > 0) {
				consolePrint('Relooping through rules because of rigid.');
				debugger_turnIndex++;
				addToDebugTimeline(level, -2); // pre-movement-applied debug state
			}

		} else {
			if (verbose_logging) {
				let eof_idx = debug_visualisation_array[debugger_turnIndex].length + 1;
				let inspect_ID = addToDebugTimeline(level, eof_idx);
				consolePrint(`Processed movements.`, false, null, inspect_ID);

				if (state.lateRules.length > 0) {
					debugger_turnIndex++;
					addToDebugTimeline(level, -2); // pre-movement-applied debug state
					consolePrint('Applying late rules');
				}
			}
			applyRules(state.lateRules, state.lateLoopPoint);
		}
	} while (i < 50 && rigidloop);

	if (i >= 50) {
		consolePrint("Looped through 50 times, gave up.  too many loops!");
	}

	// Post move stuff
	if (playerPositions.length > 0 && state.metadata.require_player_movement !== undefined) {
		let somemoved = false;
		for (let i = 0; i < playerPositions.length; i++) {
			let pos = playerPositions[i];
			let val = level.getCell(pos);
			if (state.playerMask[1].bitsClearInArray(val.data)) {
				somemoved = true;
				break;
			}
		}
		if (somemoved === false) {
			if (verbose_logging) {
				consolePrint('require_player_movement set, but no player movement detected, so cancelling turn.');
				consoleCacheDump();
			}
			addUndoState(bak);
			DoUndo(true, false);
			messagetext = "";
			textMode = false;
			tick_lazy_function_generation(false);
			return false;
		}
	}

	// Factorized command-queue processing
	let modified = processCommandQueue(bak, dontModify, dontDoWin, inputindex);

	if (verbose_logging) {
		consoleCacheDump();
	}
	if (winning) {
		againing = false;
	}

	return modified;
}

function playSounds(seedsToPlay_CantMove, seedsToPlay_CanMove, sfx_CreationMasks, sfx_DestructionMasks, sfxCreateMask, sfxDestroyMask) {
	for (let i = 0; i < seedsToPlay_CantMove.length; i++) {
		playSound(seedsToPlay_CantMove[i]);
	}
	for (let i = 0; i < seedsToPlay_CanMove.length; i++) {
		playSound(seedsToPlay_CanMove[i]);
	}
	for (let i = 0; i < sfx_CreationMasks.length; i++) {
		let entry = sfx_CreationMasks[i];
		if (sfxCreateMask.anyBitsInCommon(entry.objectMask)) {
			playSound(entry.seed);
		}
	}
	for (let i = 0; i < sfx_DestructionMasks.length; i++) {
		let entry = sfx_DestructionMasks[i];
		if (sfxDestroyMask.anyBitsInCommon(entry.objectMask)) {
			playSound(entry.seed);
		}
	}
}

function processCommandQueue(bak, dontModify, dontDoWin, inputDir) {
	// Process CANCEL command
	const cancelIndex = level.commandQueue.indexOf('cancel');
	if (cancelIndex >= 0) {
		if (verbose_logging) {
			consoleCacheDump();
			let cancelRule = level.commandQueueSourceRules[cancelIndex];
			consolePrintFromRule('CANCEL command executed, cancelling turn.', cancelRule, true);
		}
		if (!dontModify) {
			processOutputCommands(level.commandQueue);
		}
		let commandsLeft = level.commandQueue.length > 1;
		addUndoState(bak);
		DoUndo(true, false);
		tryPlayCancelSound();
		return commandsLeft;
	}

	// Process RESTART command
	const restartIndex = level.commandQueue.indexOf('restart');
	if (restartIndex >= 0) {
		if (verbose_logging && runrulesonlevelstart_phase) {
			let r = level.commandQueueSourceRules[restartIndex];
			logWarning(
				'A "restart" command is being triggered in the "run_rules_on_level_start" section of level creation, which would cause an infinite loop if it was actually triggered, but it\'s being ignored.',
				r.lineNumber,
				true
			);
		}
		if (verbose_logging) {
			let r = level.commandQueueSourceRules[restartIndex];
			consolePrintFromRule('RESTART command executed, reverting to restart state.', r);
			consoleCacheDump();
		}
		if (!dontModify) {
			processOutputCommands(level.commandQueue);
		}
		addUndoState(bak);
		if (!dontModify) {
			DoRestart(true);
		}
	}

	// Check for modifications comparing level.objects to backup
	let modified = false;
	for (let i = 0; i < level.objects.length; i++) {
		if (level.objects[i] !== bak.dat[i]) {
			if (dontModify) {
				if (verbose_logging) {
					consoleCacheDump();
				}
				addUndoState(bak);
				DoUndo(true, false);
				return true;
			} else {
				if (inputDir !== -1) {
					addUndoState(bak);
				} else if (backups.length > 0) {
					backups[backups.length - 1] = unconsolidateDiff(backups[backups.length - 1], bak);
				}
				modified = true;
			}
			break;
		}
	}

	// When dontModify is set, also check for win or restart commands.
	if (dontModify && (level.commandQueue.includes('win') || level.commandQueue.includes('restart'))) {
		return true;
	}

	if (!dontModify) {
		// Play failure/movement sounds as needed.
		playSounds(seedsToPlay_CantMove, seedsToPlay_CanMove, state.sfx_CreationMasks, state.sfx_DestructionMasks, sfxCreateMask, sfxDestroyMask);
		processOutputCommands(level.commandQueue);
	}

	// If not in text mode, check for win conditions.
	if (textMode === false) {
		if (dontDoWin === undefined) {
			dontDoWin = false;
		}
		checkWin(dontDoWin);
	}

	// If not winning, process checkpoints and AGAIN command.
	if (!winning) {
		let checkpointIndex = level.commandQueue.indexOf('checkpoint');
		if (checkpointIndex >= 0) {
			if (verbose_logging) {
				let r = level.commandQueueSourceRules[checkpointIndex];
				consolePrintFromRule('CHECKPOINT command executed, saving current state to the restart state.', r);
			}
			restartTarget = level4Serialization();
			hasUsedCheckpoint = true;
			let backupStr = JSON.stringify(restartTarget);
			storage_set(document.URL + '_checkpoint', backupStr);
			storage_set(document.URL, curlevel);
		}

		let againIndex = level.commandQueue.indexOf('again');
		if (againIndex >= 0 && modified) {
			let r = level.commandQueueSourceRules[againIndex];
			let oldVerboseLogging = verbose_logging;
			let oldMessageText = messagetext;
			verbose_logging = false;
			if (processInput(-1, true, true)) {
				verbose_logging = oldVerboseLogging;
				if (verbose_logging) {
					consolePrintFromRule('AGAIN command executed, with changes detected - will execute another turn.', r);
				}
				againing = true;
				timer = 0;
			} else {
				verbose_logging = oldVerboseLogging;
				if (verbose_logging) {
					consolePrintFromRule("AGAIN command not executed, it wouldn't make any changes.", r);
				}
			}
			verbose_logging = oldVerboseLogging;
			messagetext = oldMessageText;
		}
	}

	if (verbose_logging) {
		consolePrint('Turn complete');
	}

	level.commandQueue = [];
	level.commandQueueSourceRules = [];
	return modified;
}

function checkWin(dontDoWin) {

	if (levelEditorOpened) {
		dontDoWin = true;
	}

	if (level.commandQueue.indexOf('win') >= 0) {
		if (runrulesonlevelstart_phase) {
			consolePrint("Win Condition Satisfied (However this is in the run_rules_on_level_start rule pass, so I'm going to ignore it for you.  Why would you want to complete a level before it's already started?!)");
		} else {
			consolePrint("Win Condition Satisfied");
		}
		if (!dontDoWin) {
			DoWin();
		}
		return;
	}

	if (state.winconditions.length === 0) {
		return false;
	}

	let won = false;

	let passed = true;
	const WINCONDITIONS_LENGTH = state.winconditions.length;
	for (let wcIndex = 0; wcIndex < WINCONDITIONS_LENGTH; wcIndex++) {
		let wincondition = state.winconditions[wcIndex];
		let filter1 = wincondition[1];
		let filter2 = wincondition[2];
		let aggr1 = wincondition[4];
		let aggr2 = wincondition[5];

		let rulePassed = true;

		const f1 = aggr1 ? c => filter1.bitsSetInArray(c) : c => !filter1.bitsClearInArray(c);
		const f2 = aggr2 ? c => filter2.bitsSetInArray(c) : c => !filter2.bitsClearInArray(c);

		switch (wincondition[0]) {
			case -1://NO
				{
					for (let i = 0; i < level.n_tiles; i++) {
						let cell = level.getCellInto(i, _o10);
						if ((f1(cell.data)) &&
							(f2(cell.data))) {
							rulePassed = false;
							break;
						}
					}

					break;
				}
			case 0://SOME
				{
					let passedTest = false;
					for (let i = 0; i < level.n_tiles; i++) {
						let cell = level.getCellInto(i, _o10);
						if ((f1(cell.data)) &&
							(f2(cell.data))) {
							passedTest = true;
							break;
						}
					}
					if (passedTest === false) {
						rulePassed = false;
					}
					break;
				}
			case 1://ALL
				{
					for (let i = 0; i < level.n_tiles; i++) {
						let cell = level.getCellInto(i, _o10);
						if ((f1(cell.data)) &&
							(!f2(cell.data))) {
							rulePassed = false;
							break;
						}
					}
					break;
				}
		}
		if (rulePassed === false) {
			passed = false;
		}
	}
	won = passed;

	if (won) {
		if (runrulesonlevelstart_phase) {
			consolePrint("Win Condition Satisfied (However this is in the run_rules_on_level_start rule pass, so I'm going to ignore it for you.  Why would you want to complete a level before it's already started?!)");
		} else {
			consolePrint("Win Condition Satisfied");
		}
		if (!dontDoWin) {
			DoWin();
		}
	}
}

function DoWin() {
	if (winning) {
		return;
	}
	againing = false;
	tryPlayEndLevelSound();
	if (unitTesting) {
		nextLevel();
		return;
	}

	winning = true;
	timer = 0;
}

function nextLevel() {
	againing = false;
	messagetext = "";
	if (state && state.levels && (curlevel > state.levels.length)) {
		curlevel = state.levels.length - 1;
	}

	ignoreNotJustPressedAction = true;
	if (titleScreen) {
		if (titleSelection === 0) {
			//new game
			curlevel = 0;
			curlevelTarget = null;
		}
		if (curlevelTarget !== null) {
			loadLevelFromStateTarget(state, curlevel, curlevelTarget);
		} else {
			loadLevelFromState(state, curlevel);
		}
	} else {
		if (hasUsedCheckpoint) {
			curlevelTarget = null;
			hasUsedCheckpoint = false;
		}
		if (curlevel < (state.levels.length - 1)) {
			curlevel++;
			curlevelTarget = null;
			textMode = false;
			tick_lazy_function_generation(false);
			tick_lazy_function_generation(false);
			titleScreen = false;
			quittingMessageScreen = false;
			messageselected = false;
			loadLevelFromState(state, curlevel);			
		} else {
			try {
				storage_remove(document.URL);
				storage_remove(document.URL + '_checkpoint');
			} catch (ex) {

			}

			curlevel = 0;
			curlevelTarget = null;
			goToTitleScreen();
			tryPlayEndGameSound();
		}
		//continue existing game
	}
	try {
		storage_set(document.URL, curlevel);
		if (curlevelTarget !== null) {
			restartTarget = level4Serialization();
			let backupStr = JSON.stringify(restartTarget);
			storage_set(document.URL + '_checkpoint', backupStr);
		} else {
			storage_remove(document.URL + "_checkpoint");
		}
	} catch (ex) {

	}

	if (state !== undefined && state.metadata.flickscreen !== undefined) {
		oldflickscreendat = [0, 0, Math.min(state.metadata.flickscreen[0], level.width), Math.min(state.metadata.flickscreen[1], level.height)];
	}
	canvasResize();
}

function goToTitleScreen() {
	againing = false;
	messagetext = "";
	titleScreen = true;
	textMode = true;
	doSetupTitleScreenLevelContinue();
	titleSelection = showContinueOptionOnTitleScreen() ? 1 : 0;
	generateTitleScreen();
	if (canvas !== null) {//otherwise triggers error in cat bastard test
		regenSpriteImages();
	}
}

let CACHE_RULE_FINDMATCHES = {}
Rule.prototype.generateFindMatchesFunction = function () {
	let fn = '';

	// Initial mask check
	fn += `if (${NOT_BITS_SET_IN_ARRAY("this.ruleMask", "level.mapCellContents.data", STRIDE_OBJ)}) return [];\n`;
	fn += 'const d = level.delta_index(this.direction);\n';
	fn += 'const matches = [];\n';

	// Unroll the pattern matching loop
	for (let i = 0; i < this.patterns.length; i++) {
		fn += `let match${i};\n`;

		// Generate specialized matching code based on ellipsis count
		if (this.ellipsisCount[i] === 0) {
			fn += `match${i} = state.matchCellRow(level,this.direction, this.cellRowMatches[${i}], ` +
				`this.patterns[${i}], this.cellRowMasks[${i}], ` +
				`this.cellRowMasks_Movements[${i}], d);\n`;
		} else if (this.ellipsisCount[i] === 1) {
			fn += `match${i} = state.matchCellRowWildCard(this.direction, this.cellRowMatches[${i}], ` +
				`this.patterns[${i}], this.cellRowMasks[${i}], ` +
				`this.cellRowMasks_Movements[${i}], d, 1);\n`;
		} else { // ellipsisCount === 2
			fn += `match${i} = state.matchCellRowWildCard(this.direction, this.cellRowMatches[${i}], ` +
				`this.patterns[${i}], this.cellRowMasks[${i}], ` +
				`this.cellRowMasks_Movements[${i}], d, 2);\n`;
		}

		// Early return if no matches
		fn += `if (match${i}.length === 0) return [];\n`;
		fn += `matches.push(match${i});\n`;
	}

	fn += 'return matches;';

	if (fn in CACHE_RULE_FINDMATCHES) {
		return CACHE_RULE_FINDMATCHES[fn];
	}
	return CACHE_RULE_FINDMATCHES[fn] = new Function('level', fn);
}
</script>
<script>
'use strict';

/*
credits

brunt of the work by increpare (www.increpare.com)

all open source mit license blah blah

testers:
none, yet

code used

colors used
color values for named colours from arne, mostly (and a couple from a 32-colour palette attributed to him)
http://androidarts.com/palette/16pal.htm

the editor is a slight modification of codemirro (codemirror.net), which is crazy awesome.

for post-launch credits, check out activty on github.com/increpare/PuzzleScript

*/


const MAX_ERRORS_FOR_REAL = 100;

let compiling = false;
let errorStrings = [];//also stores warning strings
let errorCount = 0;//only counts errors

function TooManyErrors() {
    const message = compiling ? "Too many errors/warnings; aborting compilation." : "Too many errors/warnings; noping out.";
    consolePrint(message, true);
    throw new Error(message);
}

function logErrorCacheable(str, lineNumber, urgent) {
    if (compiling || urgent) {
        if (lineNumber === undefined) {
            return logErrorNoLine(str, urgent);
        }
        let errorString = '<a onclick="jumpToLine(' + lineNumber.toString() + ');"  href="javascript:void(0);"><span class="errorTextLineNumber"> line ' + lineNumber.toString() + '</span></a> : ' + '<span class="errorText">' + str + '</span>';
        if (errorStrings.indexOf(errorString) >= 0 && !urgent) {
            //do nothing, duplicate error
        } else {
            consolePrint(errorString);
            errorStrings.push(errorString);
            errorCount++;
            if (errorStrings.length > MAX_ERRORS_FOR_REAL) {
                TooManyErrors();
            }
        }
    }
}

function logError(str, lineNumber, urgent) {
    if (compiling || urgent) {
        if (lineNumber === undefined) {
            return logErrorNoLine(str, urgent);
        }
        let errorString = '<a onclick="jumpToLine(' + lineNumber.toString() + ');"  href="javascript:void(0);"><span class="errorTextLineNumber"> line ' + lineNumber.toString() + '</span></a> : ' + '<span class="errorText">' + str + '</span>';
        if (errorStrings.indexOf(errorString) >= 0 && !urgent) {
            //do nothing, duplicate error
        } else {
            consolePrint(errorString, true);
            errorStrings.push(errorString);
            errorCount++;
            if (errorStrings.length > MAX_ERRORS_FOR_REAL) {
                TooManyErrors();
            }
        }
    }
}

function logWarning(str, lineNumber, urgent) {
    if (compiling || urgent) {
        if (lineNumber === undefined) {
            return logWarningNoLine(str, urgent);
        }
        let errorString = '<a onclick="jumpToLine(' + lineNumber.toString() + ');"  href="javascript:void(0);"><span class="errorTextLineNumber"> line ' + lineNumber.toString() + '</span></a> : ' + '<span class="warningText">' + str + '</span>';
        if (errorStrings.indexOf(errorString) >= 0 && !urgent) {
            //do nothing, duplicate error
        } else {
            consolePrint(errorString, true);
            errorStrings.push(errorString);
            if (errorStrings.length > MAX_ERRORS_FOR_REAL) {
                TooManyErrors();
            }
        }
    }
}

function logWarningNoLine(str, urgent) {
    if (compiling || urgent) {
        let errorString = '<span class="warningText">' + str + '</span>';
        if (errorStrings.indexOf(errorString) >= 0 && !urgent) {
            //do nothing, duplicate error
        } else {
            consolePrint(errorString, true);
            errorStrings.push(errorString);
            errorCount++;
            if (errorStrings.length > MAX_ERRORS_FOR_REAL) {
                TooManyErrors();
            }
        }
    }
}


function logErrorNoLine(str, urgent) {
    if (compiling || urgent) {
        let errorString = '<span class="errorText">' + str + '</span>';
        if (errorStrings.indexOf(errorString) >= 0 && !urgent) {
            //do nothing, duplicate error
        } else {
            consolePrint(errorString, true);
            errorStrings.push(errorString);
            errorCount++;
            if (errorStrings.length > MAX_ERRORS_FOR_REAL) {
                TooManyErrors();
            }
        }
    }
}

function blankLineHandle(state) {
    if (state.section === 'levels') {
        if (state.levels[state.levels.length - 1].length > 0) {
            state.levels.push([]);
        }
    } else if (state.section === 'objects') {
        state.objects_section = 0;
    }
}

//returns null if not delcared, otherwise declaration
//note to self: I don't think that aggregates or properties know that they're aggregates or properties in and of themselves.
function wordAlreadyDeclared(state, n) {
    n = n.toLowerCase();
    if (n in state.objects) {
        return state.objects[n];
    }
    for (let i = 0; i < state.legend_aggregates.length; i++) {
        let a = state.legend_aggregates[i];
        if (a[0] === n) {
            return state.legend_aggregates[i];
        }
    }
    for (let i = 0; i < state.legend_properties.length; i++) {
        let a = state.legend_properties[i];
        if (a[0] === n) {
            return state.legend_properties[i];
        }
    }
    for (let i = 0; i < state.legend_synonyms.length; i++) {
        let a = state.legend_synonyms[i];
        if (a[0] === n) {
            return state.legend_synonyms[i];
        }
    }
    return null;
}


//for IE support
if (typeof Object.assign != 'function') {
    (function () {
        Object.assign = function (target) {
            'use strict';
            // We must check against these specific cases.
            if (target === undefined || target === null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }

            let output = Object(target);
            for (let index = 1; index < arguments.length; index++) {
                let source = arguments[index];
                if (source !== undefined && source !== null) {
                    for (let nextKey in source) {
                        if (source.hasOwnProperty(nextKey)) {
                            output[nextKey] = source[nextKey];
                        }
                    }
                }
            }
            return output;
        };
    })();
}


let codeMirrorFn = function () {
    'use strict';

    function checkNameDefined(state, candname) {
        if (state.objects[candname] !== undefined) {
            return;
        }
        for (let i = 0; i < state.legend_synonyms.length; i++) {
            let entry = state.legend_synonyms[i];
            if (entry[0] == candname) {
                return;
            }
        }
        for (let i = 0; i < state.legend_aggregates.length; i++) {
            let entry = state.legend_aggregates[i];
            if (entry[0] == candname) {
                return;
            }
        }
        for (let i = 0; i < state.legend_properties.length; i++) {
            let entry = state.legend_properties[i];
            if (entry[0] == candname) {
                return;
            }
        }

        logError(`You're talking about ${candname.toUpperCase()} but it's not defined anywhere.`, state.lineNumber);
    }

    function registerOriginalCaseName(state, candname, mixedCase, lineNumber) {

        function escapeRegExp(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        }

        let nameFinder = new RegExp("\\b" + escapeRegExp(candname) + "\\b", "i")
        let match = mixedCase.match(nameFinder);
        if (match != null) {
            state.original_case_names[candname] = match[0];
            state.original_line_numbers[candname] = lineNumber;
        }
    }

    function errorFallbackMatchToken(stream) {
        let match = stream.match(reg_match_until_commentstart_or_whitespace, true);
        if (match === null) {
            //just in case, I don't know for sure if it can happen but, just in case I don't 
            //understand unicode and the above doesn't match anything, force some match progress.
            match = stream.match(reg_notcommentstart, true);
        }
        return match;
    }

    function processLegendLine(state, mixedCase) {
        let ok = true;
        let splits = state.current_line_wip_array;
        if (splits.length === 0) {
            return;
        }

        if (splits.length === 1) {
            logError('Incorrect format of legend - should be one of "A = B", "A = B or C [ or D ...]", "A = B and C [ and D ...]".', state.lineNumber);
            ok = false;
        } else if (splits.length % 2 === 0) {
            logError(`Incorrect format of legend - should be one of "A = B", "A = B or C [ or D ...]", "A = B and C [ and D ...]", but it looks like you have a dangling "${state.current_line_wip_array[state.current_line_wip_array.length - 1].toUpperCase()}"?`, state.lineNumber);
            ok = false;
        } else {
            let candname = splits[0];

            let alreadyDefined = wordAlreadyDeclared(state, candname);
            if (alreadyDefined !== null) {
                logError(`Name "${candname.toUpperCase()}" already in use (on line <a onclick="jumpToLine(${alreadyDefined.lineNumber});" href="javascript:void(0);"><span class="errorTextLineNumber">line ${alreadyDefined.lineNumber}</span></a>).`, state.lineNumber);
                ok = false;
            }

            if (keyword_array.indexOf(candname) >= 0) {
                logWarning('You named an object "' + candname.toUpperCase() + '", but this is a keyword. Don\'t do that!', state.lineNumber);
            }


            for (let i = 2; i < splits.length; i += 2) {
                let nname = splits[i];
                if (nname === candname) {
                    logError("You can't define object " + candname.toUpperCase() + " in terms of itself!", state.lineNumber);
                    ok = false;
                    let idx = splits.indexOf(candname, 2);
                    while (idx >= 2) {
                        if (idx >= 4) {
                            splits.splice(idx - 1, 2);
                        } else {
                            splits.splice(idx, 2);
                        }
                        idx = splits.indexOf(candname, 2);
                    }
                }
                for (let j = 2; j < i; j += 2) {
                    let oname = splits[j];
                    if (oname === nname) {
                        logWarning("You're repeating the object " + oname.toUpperCase() + " here multiple times on the RHS.  This makes no sense.  Don't do that.", state.lineNumber);
                    }
                }
            }

            //for every other word, check if it's a valid name
            for (let i = 2; i < splits.length; i += 2) {
                let defname = splits[i];
                if (defname !== candname) {//we already have an error message for that just above.
                    checkNameDefined(state, defname);
                }
            }

            if (splits.length === 3) {
                //SYNONYM
                let synonym = [splits[0], splits[2]];
                synonym.lineNumber = state.lineNumber;
                registerOriginalCaseName(state, splits[0], mixedCase, state.lineNumber);
                state.legend_synonyms.push(synonym);
            } else if (splits[3] === 'and') {
                //AGGREGATE
                let substitutor = function (n) {
                    n = n.toLowerCase();
                    if (n in state.objects) {
                        return [n];
                    }
                    for (let i = 0; i < state.legend_synonyms.length; i++) {
                        let a = state.legend_synonyms[i];
                        if (a[0] === n) {
                            return substitutor(a[1]);
                        }
                    }
                    for (let i = 0; i < state.legend_aggregates.length; i++) {
                        let a = state.legend_aggregates[i];
                        if (a[0] === n) {
                            return [].concat.apply([], a.slice(1).map(substitutor));
                        }
                    }
                    for (let i = 0; i < state.legend_properties.length; i++) {
                        let a = state.legend_properties[i];
                        if (a[0] === n) {
                            logError("Cannot define an aggregate (using 'and') in terms of properties (something that uses 'or').", state.lineNumber);
                            ok = false;
                            return [n];
                        }
                    }
                    //seems like this shouldn't be reachable?
                    return [n];
                };

                let newlegend = [splits[0]].concat(substitutor(splits[2])).concat(substitutor(splits[4]));
                for (let i = 6; i < splits.length; i += 2) {
                    newlegend = newlegend.concat(substitutor(splits[i]));
                }
                newlegend.lineNumber = state.lineNumber;

                registerOriginalCaseName(state, newlegend[0], mixedCase, state.lineNumber);
                state.legend_aggregates.push(newlegend);

            } else if (splits[3] === 'or') {
                let malformed = false;

                let substitutor = function (n) {

                    n = n.toLowerCase();
                    if (n in state.objects) {
                        return [n];
                    }

                    for (let i = 0; i < state.legend_synonyms.length; i++) {
                        let a = state.legend_synonyms[i];
                        if (a[0] === n) {
                            return substitutor(a[1]);
                        }
                    }
                    for (let i = 0; i < state.legend_aggregates.length; i++) {
                        let a = state.legend_aggregates[i];
                        if (a[0] === n) {
                            logError(`Cannot define a property (something defined in terms of 'or') in terms of an aggregate (something that uses 'and').  In this case, you can't define "${splits[0]}" in terms of "${n}".`, state.lineNumber);
                            malformed = true;
                            return [];
                        }
                    }
                    for (let i = 0; i < state.legend_properties.length; i++) {
                        let a = state.legend_properties[i];
                        if (a[0] === n) {
                            let result = [];
                            for (let j = 1; j < a.length; j++) {
                                if (a[j] === n) {
                                    //error here superfluous, also detected elsewhere (cf 'You can't define object' / #789)
                                    //logError('Error, recursive definition found for '+n+'.', state.lineNumber);                                
                                } else {
                                    result = result.concat(substitutor(a[j]));
                                }
                            }
                            return result;
                        }
                    }
                    return [n];
                };

                for (let i = 5; i < splits.length; i += 2) {
                    if (splits[i].toLowerCase() !== 'or') {
                        malformed = true;
                        break;
                    }
                }
                if (!malformed) {
                    let newlegend = [splits[0]].concat(substitutor(splits[2])).concat(substitutor(splits[4]));
                    for (let i = 6; i < splits.length; i += 2) {
                        newlegend.push(splits[i].toLowerCase());
                    }
                    newlegend.lineNumber = state.lineNumber;

                    registerOriginalCaseName(state, newlegend[0], mixedCase, state.lineNumber);
                    state.legend_properties.push(newlegend);
                }
            } else {
                if (ok) {
                    //no it's not ok but we don't know why
                    logError('This legend-entry is incorrectly-formatted - it should be one of A = B, A = B or C ( or D ...), A = B and C (and D ...)', state.lineNumber);
                    ok = false;
                }
            }
        }
    }

    function processSoundsLine(state) {
        if (state.current_line_wip_array.length === 0) {
            return;
        }
        //if last entry in array is 'ERROR', do nothing
        if (state.current_line_wip_array[state.current_line_wip_array.length - 1] === 'ERROR') {

        } else {
            //take the first component from each pair in the array
            let soundrow = state.current_line_wip_array;//.map(function(a){return a[0];});
            soundrow.push(state.lineNumber);
            state.sounds.push(soundrow);
        }

    }

    // because of all the early-outs in the token function, this is really just right now attached
    // too places where we can early out during the legend. To make it more versatile we'd have to change 
    // all the early-outs in the token function to flag-assignment for returning outside the case 
    // statement.
    function endOfLineProcessing(state, mixedCase) {
        if (state.section === 'legend') {
            processLegendLine(state, mixedCase);
        } else if (state.section === 'sounds') {
            processSoundsLine(state);
        }
    }

    //  let keywordRegex = new RegExp("\\b(("+cons.join(")|(")+"))$", 'i');

    let fullSpriteMatrix = [
        '00000',
        '00000',
        '00000',
        '00000',
        '00000'
    ];

    return {
        copyState: function (state) {
            let objectsCopy = {};
            for (let i in state.objects) {
                if (state.objects.hasOwnProperty(i)) {
                    let o = state.objects[i];
                    objectsCopy[i] = {
                        colors: o.colors.concat([]),
                        lineNumber: o.lineNumber,
                        spritematrix: o.spritematrix.concat([])
                    }
                }
            }

            let collisionLayersCopy = [];
            for (let i = 0; i < state.collisionLayers.length; i++) {
                collisionLayersCopy.push(state.collisionLayers[i].concat([]));
            }

            let legend_synonymsCopy = [];
            let legend_aggregatesCopy = [];
            let legend_propertiesCopy = [];
            let soundsCopy = [];
            let levelsCopy = [];
            let winConditionsCopy = [];
            let rulesCopy = [];

            for (let i = 0; i < state.legend_synonyms.length; i++) {
                legend_synonymsCopy.push(state.legend_synonyms[i].concat([]));
            }
            for (let i = 0; i < state.legend_aggregates.length; i++) {
                legend_aggregatesCopy.push(state.legend_aggregates[i].concat([]));
            }
            for (let i = 0; i < state.legend_properties.length; i++) {
                legend_propertiesCopy.push(state.legend_properties[i].concat([]));
            }
            for (let i = 0; i < state.sounds.length; i++) {
                soundsCopy.push(state.sounds[i].concat([]));
            }
            for (let i = 0; i < state.levels.length; i++) {
                levelsCopy.push(state.levels[i].concat([]));
            }
            for (let i = 0; i < state.winconditions.length; i++) {
                winConditionsCopy.push(state.winconditions[i].concat([]));
            }
            for (let i = 0; i < state.rules.length; i++) {
                rulesCopy.push(state.rules[i].concat([]));
            }

            let original_case_namesCopy = Object.assign({}, state.original_case_names);
            let original_line_numbersCopy = Object.assign({}, state.original_line_numbers);

            let nstate = {
                lineNumber: state.lineNumber,

                objects: objectsCopy,
                collisionLayers: collisionLayersCopy,

                commentLevel: state.commentLevel,
                section: state.section,
                visitedSections: state.visitedSections.concat([]),

                line_should_end: state.line_should_end,
                line_should_end_because: state.line_should_end_because,
                sol_after_comment: state.sol_after_comment,

                objects_candname: state.objects_candname,
                objects_section: state.objects_section,
                objects_spritematrix: state.objects_spritematrix.concat([]),

                tokenIndex: state.tokenIndex,

                current_line_wip_array: state.current_line_wip_array.concat([]),

                legend_synonyms: legend_synonymsCopy,
                legend_aggregates: legend_aggregatesCopy,
                legend_properties: legend_propertiesCopy,

                sounds: soundsCopy,

                rules: rulesCopy,

                names: state.names.concat([]),

                winconditions: winConditionsCopy,

                original_case_names: original_case_namesCopy,
                original_line_numbers: original_line_numbersCopy,

                abbrevNames: state.abbrevNames.concat([]),

                metadata: state.metadata.concat([]),
                metadata_lines: Object.assign({}, state.metadata_lines),

                levels: levelsCopy,

                STRIDE_OBJ: state.STRIDE_OBJ,
                STRIDE_MOV: state.STRIDE_MOV
            };

            return nstate;
        },
        blankLine: function (state) {
            if (state.section === 'levels') {
                if (state.levels[state.levels.length - 1].length > 0) {
                    state.levels.push([]);
                }
            }
        },
        token: function (stream, state) {
            let mixedCase = stream.string;
            let sol = stream.sol();
            if (sol) {
                state.lineNumber++;
                state.current_line_wip_array = [];
                stream.string = stream.string.toLowerCase();
                state.tokenIndex = 0;
                state.line_should_end = false;
            }
            if (state.sol_after_comment) {
                sol = true;
                state.sol_after_comment = false;
            }



            stream.eatWhile(/[ \t]/);

            ////////////////////////////////
            // COMMENT PROCESSING BEGIN
            ////////////////////////////////

            //NESTED COMMENTS
            let ch = stream.peek();
            if (ch === '(' && state.tokenIndex !== -4) { // tokenIndex -4 indicates message command
                stream.next();
                state.commentLevel++;
            } else if (ch === ')') {
                stream.next();
                if (state.commentLevel > 0) {
                    state.commentLevel--;
                    if (state.commentLevel === 0) {
                        state.sol_after_comment = true;
                        return 'comment';
                    }
                } else {
                    logWarning("You're trying to close a comment here, but I can't find any opening bracket to match it? [This is highly suspicious; you probably want to fix it.]", state.lineNumber);
                    return 'ERROR';
                }
            }
            if (state.commentLevel > 0) {
                if (sol) {
                    state.sol_after_comment = true;
                }
                while (true) {
                    stream.eatWhile(/[^\(\)]+/);

                    if (stream.eol()) {
                        break;
                    }

                    ch = stream.peek();

                    if (ch === '(') {
                        state.commentLevel++;
                    } else if (ch === ')') {
                        state.commentLevel--;
                    }
                    stream.next();

                    if (state.commentLevel === 0) {
                        break;
                    }
                }

                if (stream.eol()) {
                    endOfLineProcessing(state, mixedCase);
                }
                return 'comment';
            }

            stream.eatWhile(/[ \t]/);

            if (sol && stream.eol()) {
                endOfLineProcessing(state, mixedCase);
                return blankLineHandle(state);
            }

            if (state.line_should_end && !stream.eol()) {
                logError('Only comments should go after ' + state.line_should_end_because + ' on a line.', state.lineNumber);
                stream.skipToEnd();
                return 'ERROR';
            }

            //MATCH '==="s AT START OF LINE
            //for #977 we need to be careful about matching an equals row in the levels section
            //check if the line contains something other than an equals characte or space
            let shouldmatchequals = true;
            if (sol && state.section === "levels") {
                let linestring = stream.string.substring(stream.pos);
                const reg_matchall_whitespace_equals = /^[\p{Z}\s=]*$/u;
                if (!reg_matchall_whitespace_equals.test(linestring)) {
                    shouldmatchequals = false;
                }
            }

            if (sol && (shouldmatchequals && stream.match(reg_equalsrow, true))) {
                state.line_should_end = true;
                state.line_should_end_because = 'a bunch of equals signs (\'===\')';
                return 'EQUALSBIT';
            }

            //MATCH SECTION NAME
            if (state.section !== "levels" /*cf #976 lol*/) {
                let sectionNameMatches = stream.match(reg_sectionNames, true);
                if (sol && sectionNameMatches) {

                    state.section = sectionNameMatches[0].trim();
                    if (state.visitedSections.indexOf(state.section) >= 0) {
                        logError('cannot duplicate sections (you tried to duplicate \"' + state.section.toUpperCase() + '").', state.lineNumber);
                    }
                    state.line_should_end = true;
                    state.line_should_end_because = `a section name ("${state.section.toUpperCase()}")`;
                    state.visitedSections.push(state.section);
                    let sectionIndex = sectionNames.indexOf(state.section);
                    if (sectionIndex == 0) {
                        state.objects_section = 0;
                        if (state.visitedSections.length > 1) {
                            logError('section "' + state.section.toUpperCase() + '" must be the first section', state.lineNumber);
                        }
                    } else if (state.visitedSections.indexOf(sectionNames[sectionIndex - 1]) == -1) {
                        if (sectionIndex === -1) {
                            //honestly not sure how I could get here.
                            logError('no such section as "' + state.section.toUpperCase() + '".', state.lineNumber);
                        } else {
                            logError('section "' + state.section.toUpperCase() + '" is out of order, must follow  "' + sectionNames[sectionIndex - 1].toUpperCase() + '" (or it could be that the section "' + sectionNames[sectionIndex - 1].toUpperCase() + `"is just missing totally.  You have to include all section headings, even if the section itself is empty).`, state.lineNumber);
                        }
                    }

                    if (state.section === 'sounds') {
                        //populate names from rules
                        for (let n in state.objects) {
                            if (state.objects.hasOwnProperty(n)) {
                                /*                                if (state.names.indexOf(n)!==-1) {
                                                                logError('Object "'+n+'" has been declared to be multiple different things',state.objects[n].lineNumber);
                                                            }*/
                                state.names.push(n);
                            }
                        }
                        //populate names from legends
                        for (let i = 0; i < state.legend_synonyms.length; i++) {
                            let n = state.legend_synonyms[i][0];
                            /*
                            if (state.names.indexOf(n)!==-1) {
                                logError('Object "'+n+'" has been declared to be multiple different things',state.legend_synonyms[i].lineNumber);
                            }
                            */
                            state.names.push(n);
                        }
                        for (let i = 0; i < state.legend_aggregates.length; i++) {
                            let n = state.legend_aggregates[i][0];
                            /*
                            if (state.names.indexOf(n)!==-1) {
                                logError('Object "'+n+'" has been declared to be multiple different things',state.legend_aggregates[i].lineNumber);
                            }
                            */
                            state.names.push(n);
                        }
                        for (let i = 0; i < state.legend_properties.length; i++) {
                            let n = state.legend_properties[i][0];
                            /*
                            if (state.names.indexOf(n)!==-1) {
                                logError('Object "'+n+'" has been declared to be multiple different things',state.legend_properties[i].lineNumber);
                            }                           
                            */
                            state.names.push(n);
                        }
                    }
                    else if (state.section === 'levels') {
                        //populate character abbreviations
                        for (let n in state.objects) {
                            if (state.objects.hasOwnProperty(n) && n.length === 1) {
                                state.abbrevNames.push(n);
                            }
                        }

                        for (let i = 0; i < state.legend_synonyms.length; i++) {
                            if (state.legend_synonyms[i][0].length === 1) {
                                state.abbrevNames.push(state.legend_synonyms[i][0]);
                            }
                        }
                        for (let i = 0; i < state.legend_aggregates.length; i++) {
                            if (state.legend_aggregates[i][0].length === 1) {
                                state.abbrevNames.push(state.legend_aggregates[i][0]);
                            }
                        }
                    }
                    return 'HEADER';
                } else {
                    if (state.section === undefined) {
                        //unreachable I think, pre-empted caught above
                        logError('must start with section "OBJECTS"', state.lineNumber);
                    }
                }
            }

            if (stream.eol()) {

                endOfLineProcessing(state, mixedCase);
                return null;
            }

            //if color is set, try to set matrix
            //if can't set matrix, try to parse name
            //if color is not set, try to parse color
            switch (state.section) {
                case 'objects':
                    {
                        let tryParseName = function () {
                            //LOOK FOR NAME
                            let match_name = sol ? stream.match(reg_name, true) : stream.match(/[^\p{Z}\s\()]+[\p{Z}\s]*/u, true);
                            if (match_name == null) {
                                stream.match(reg_notcommentstart, true);
                                if (stream.pos > 0) {
                                    logWarning('Unknown junk in object section (possibly: sprites have to be 5 pixels wide and 5 pixels high exactly. Or maybe: the main names for objects have to be words containing only the letters a-z0.9 - if you want to call them something like ",", do it in the legend section).', state.lineNumber);
                                }
                                return 'ERROR';
                            } else {
                                let candname = match_name[0].trim();
                                if (state.objects[candname] !== undefined) {
                                    logError('Object "' + candname.toUpperCase() + '" defined multiple times.', state.lineNumber);
                                    return 'ERROR';
                                }
                                for (let i = 0; i < state.legend_synonyms.length; i++) {
                                    let entry = state.legend_synonyms[i];
                                    if (entry[0] == candname) {
                                        logError('Name "' + candname.toUpperCase() + '" already in use.', state.lineNumber);
                                    }
                                }
                                if (keyword_array.indexOf(candname) >= 0) {
                                    logWarning('You named an object "' + candname.toUpperCase() + '", but this is a keyword. Don\'t do that!', state.lineNumber);
                                }

                                if (sol) {
                                    state.objects_candname = candname;
                                    registerOriginalCaseName(state, candname, mixedCase, state.lineNumber);
                                    state.objects[state.objects_candname] = {
                                        lineNumber: state.lineNumber,
                                        colors: [],
                                        spritematrix: []
                                    };

                                } else {
                                    //set up alias
                                    registerOriginalCaseName(state, candname, mixedCase, state.lineNumber);
                                    let synonym = [candname, state.objects_candname];
                                    synonym.lineNumber = state.lineNumber;
                                    state.legend_synonyms.push(synonym);
                                }
                                state.objects_section = 1;
                                return 'NAME';
                            }
                        };

                        if (sol && state.objects_section == 2) {
                            state.objects_section = 3;
                        }

                        if (sol && state.objects_section == 1) {
                            state.objects_section = 2;
                        }

                        switch (state.objects_section) {
                            case 0:
                            case 1:
                                {
                                    state.objects_spritematrix = [];
                                    return tryParseName();
                                }
                            case 2:
                                {
                                    //LOOK FOR COLOR
                                    state.tokenIndex = 0;

                                    let match_color = stream.match(reg_color, true);
                                    if (match_color == null) {
                                        let str = stream.match(reg_name, true) || stream.match(reg_notcommentstart, true);
                                        logError('Was looking for color for object ' + state.objects_candname.toUpperCase() + ', got "' + str + '" instead.', state.lineNumber);
                                        return null;
                                    } else {
                                        if (state.objects[state.objects_candname].colors === undefined) {
                                            state.objects[state.objects_candname].colors = [match_color[0].trim()];
                                        } else {
                                            state.objects[state.objects_candname].colors.push(match_color[0].trim());
                                        }

                                        let candcol = match_color[0].trim().toLowerCase();
                                        if (candcol in colorPalettes.arnecolors) {
                                            return 'COLOR COLOR-' + candcol.toUpperCase();
                                        } else if (candcol === "transparent") {
                                            return 'COLOR FADECOLOR';
                                        } else {
                                            return 'MULTICOLOR' + match_color[0];
                                        }
                                    }
                                }
                            case 3:
                                {
                                    let ch = stream.eat(/[.\d]/);
                                    let spritematrix = state.objects_spritematrix;
                                    if (ch === undefined) {
                                        if (spritematrix.length === 0) {
                                            return tryParseName();
                                        }
                                        logError('Unknown junk in spritematrix for object ' + state.objects_candname.toUpperCase() + '.', state.lineNumber);
                                        stream.match(reg_notcommentstart, true);
                                        return null;
                                    }

                                    if (sol) {
                                        spritematrix.push('');
                                    }

                                    let o = state.objects[state.objects_candname];

                                    spritematrix[spritematrix.length - 1] += ch;
                                    if (spritematrix[spritematrix.length - 1].length > 5) {
                                        logWarning('Sprites must be 5 wide and 5 high.', state.lineNumber);
                                        stream.match(reg_notcommentstart, true);
                                        return null;
                                    }
                                    o.spritematrix = state.objects_spritematrix;
                                    if (spritematrix.length === 5 && spritematrix[spritematrix.length - 1].length === 5) {
                                        state.objects_section = 0;
                                    }

                                    if (ch !== '.') {
                                        let n = parseInt(ch);
                                        if (n >= o.colors.length) {
                                            logError("Trying to access color number " + n + " from the color palette of sprite " + state.objects_candname.toUpperCase() + ", but there are only " + o.colors.length + " defined in it.", state.lineNumber);
                                            return 'ERROR';
                                        }
                                        return 'COLOR BOLDCOLOR COLOR-' + o.colors[n].toUpperCase();
                                    }
                                    return 'COLOR FADECOLOR';
                                }
                            default:
                                {
                                    window.console.logError("EEK shouldn't get here.");
                                }
                        }
                        break;
                    }
                case 'legend':
                    {
                        let resultToken = "";
                        let match_name = null;
                        if (state.tokenIndex === 0) {
                            match_name = stream.match(/[^=\p{Z}\s\(]*(\p{Z}\s)*/u, true);
                            let new_name = match_name[0].trim();

                            if (wordAlreadyDeclared(state, new_name)) {
                                resultToken = 'ERROR';
                            } else {
                                resultToken = 'NAME';
                            }

                            //if name already declared, we have a problem                            
                            state.tokenIndex++;
                        } else if (state.tokenIndex === 1) {
                            match_name = stream.match(/=/u, true);
                            if (match_name === null || match_name[0].trim() !== "=") {
                                logError(`In the legend, define new items using the equals symbol - declarations must look like "A = B", "A = B or C [ or D ...]", "A = B and C [ and D ...]".`, state.lineNumber);
                                stream.match(reg_notcommentstart, true);
                                resultToken = 'ERROR';
                                match_name = ["ERROR"];//just to reduce the chance of crashes
                            }
                            stream.match(/[\p{Z}\s]*/u, true);
                            state.tokenIndex++;
                            resultToken = 'ASSIGNMENT';
                        } else if (state.tokenIndex >= 3 && ((state.tokenIndex % 2) === 1)) {
                            //matches AND/OR
                            match_name = stream.match(reg_name, true);
                            if (match_name === null) {
                                logError("Something bad's happening in the LEGEND", state.lineNumber);
                                let match = stream.match(reg_notcommentstart, true);
                                resultToken = 'ERROR';
                            } else {
                                let candname = match_name[0].trim();
                                if (candname === "and" || candname === "or") {
                                    resultToken = 'LOGICWORD';
                                    if (state.tokenIndex >= 5) {
                                        if (candname !== state.current_line_wip_array[3]) {
                                            logError("Hey! You can't go mixing ANDs and ORs in a single legend entry.", state.lineNumber);
                                            resultToken = 'ERROR';
                                        }
                                    }
                                } else {
                                    logError(`Expected and 'AND' or an 'OR' here, but got ${candname.toUpperCase()} instead. In the legend, define new items using the equals symbol - declarations must look like 'A = B' or 'A = B and C' or 'A = B or C'.`, state.lineNumber);
                                    resultToken = 'ERROR';
                                    // match_name=["and"];//just to reduce the chance of crashes
                                }
                            }
                            state.tokenIndex++;
                        }
                        else {
                            match_name = stream.match(reg_name, true);
                            if (match_name === null) {
                                logError("Something bad's happening in the LEGEND", state.lineNumber);
                                let match = stream.match(reg_notcommentstart, true);
                                resultToken = 'ERROR';
                            } else {
                                let candname = match_name[0].trim();
                                if (wordAlreadyDeclared(state, candname)) {
                                    resultToken = 'NAME';
                                } else {
                                    resultToken = 'ERROR';
                                }
                                state.tokenIndex++;

                            }
                        }

                        if (match_name !== null) {
                            state.current_line_wip_array.push(match_name[0].trim());
                        }

                        if (stream.eol()) {
                            processLegendLine(state, mixedCase);
                        }

                        return resultToken;
                        break;
                    }
                case 'sounds':
                    {
                        /*
                        SOUND DEFINITION:
                            SOUNDEVENT ~ INT (Sound events take precedence if there's name overlap)
                            OBJECT_NAME
                                NONDIRECTIONAL_VERB ~ INT
                                DIRECTIONAL_VERB
                                    INT
                                    DIR+ ~ INT
                        */
                        let tokentype = "";

                        if (state.current_line_wip_array.length > 0 && state.current_line_wip_array[state.current_line_wip_array.length - 1] === 'ERROR') {
                            // match=stream.match(reg_notcommentstart, true);
                            //if there was an error earlier on the line just try to do greedy matching here
                            let match = null;

                            //events
                            if (match === null) {
                                match = stream.match(reg_soundevents, true);
                                if (match !== null) {
                                    tokentype = 'SOUNDEVENT';
                                }
                            }

                            //verbs
                            if (match === null) {
                                match = stream.match(reg_soundverbs, true);
                                if (match !== null) {
                                    tokentype = 'SOUNDVERB';
                                }
                            }
                            //directions
                            if (match === null) {
                                match = stream.match(reg_sounddirectionindicators, true);
                                if (match !== null) {
                                    tokentype = 'DIRECTION';
                                }
                            }

                            //sound seeds
                            if (match === null) {
                                let match = stream.match(reg_soundseed, true);
                                if (match !== null) {
                                    tokentype = 'SOUND';
                                }
                            }

                            //objects
                            if (match === null) {
                                match = stream.match(reg_name, true);
                                if (match !== null) {
                                    if (wordAlreadyDeclared(state, match[0].trim())) {
                                        tokentype = 'NAME';
                                    } else {
                                        tokentype = 'ERROR';
                                    }
                                }
                            }

                            //error
                            if (match === null) {
                                match = errorFallbackMatchToken(stream);
                                tokentype = 'ERROR';
                            }


                        } else if (state.current_line_wip_array.length === 0) {
                            //can be OBJECT_NAME or SOUNDEVENT
                            let match = stream.match(reg_soundevents, true);
                            if (match == null) {
                                match = stream.match(reg_name, true);
                                if (match == null) {
                                    tokentype = 'ERROR';
                                    match = errorFallbackMatchToken(stream);
                                    state.current_line_wip_array.push("ERROR");
                                    logWarning("Was expecting a sound event (like SFX3, or ENDLEVEL) or an object name, but didn't find either.", state.lineNumber);
                                } else {
                                    let matched_name = match[0].trim();
                                    if (!wordAlreadyDeclared(state, matched_name)) {
                                        tokentype = 'ERROR';
                                        state.current_line_wip_array.push("ERROR");
                                        logError(`unexpected sound token "${matched_name}".`, state.lineNumber);
                                    } else {
                                        tokentype = 'NAME';
                                        state.current_line_wip_array.push([matched_name, tokentype]);
                                        state.tokenIndex++;
                                    }
                                }
                            } else {
                                tokentype = 'SOUNDEVENT';
                                state.current_line_wip_array.push([match[0].trim(), tokentype]);
                                state.tokenIndex++;
                            }

                        } else if (state.current_line_wip_array.length === 1) {
                            let is_soundevent = state.current_line_wip_array[0][1] === 'SOUNDEVENT';

                            if (is_soundevent) {
                                let match = stream.match(reg_soundseed, true);
                                if (match !== null) {
                                    tokentype = 'SOUND';
                                    state.current_line_wip_array.push([match[0].trim(), tokentype]);
                                    state.tokenIndex++;
                                } else {
                                    match = errorFallbackMatchToken(stream);
                                    logError("Was expecting a sound seed here (a number like 123123, like you generate by pressing the buttons above the console panel), but found something else.", state.lineNumber);
                                    tokentype = 'ERROR';
                                    state.current_line_wip_array.push("ERROR");
                                }
                            } else {
                                //[0] is object name
                                //it's a sound verb
                                let match = stream.match(reg_soundverbs, true);
                                if (match !== null) {
                                    tokentype = 'SOUNDVERB';
                                    state.current_line_wip_array.push([match[0].trim(), tokentype]);
                                    state.tokenIndex++;
                                } else {
                                    match = errorFallbackMatchToken(stream);
                                    logError("Was expecting a soundverb here (MOVE, DESTROY, CANTMOVE, or the like), but found something else.", state.lineNumber);
                                    tokentype = 'ERROR';
                                    state.current_line_wip_array.push("ERROR");
                                }

                            }
                        } else {
                            let is_soundevent = state.current_line_wip_array[0][1] === 'SOUNDEVENT';
                            if (is_soundevent) {
                                let match = errorFallbackMatchToken(stream);
                                logError(`I wasn't expecting anything after the sound declaration ${state.current_line_wip_array[state.current_line_wip_array.length - 1][0].toUpperCase()} on this line, so I don't know what to do with "${match[0].trim().toUpperCase()}" here.`, state.lineNumber);
                                tokentype = 'ERROR';
                                state.current_line_wip_array.push("ERROR");
                            } else {
                                //if there's a seed on the right, any additional content is superfluous
                                let is_seedonright = state.current_line_wip_array[state.current_line_wip_array.length - 1][1] === 'SOUND';
                                if (is_seedonright) {
                                    let match = errorFallbackMatchToken(stream);
                                    logError(`I wasn't expecting anything after the sound declaration ${state.current_line_wip_array[state.current_line_wip_array.length - 1][0].toUpperCase()} on this line, so I don't know what to do with "${match[0].trim().toUpperCase()}" here.`, state.lineNumber);
                                    tokentype = 'ERROR';
                                    state.current_line_wip_array.push("ERROR");
                                } else {
                                    let directional_verb = soundverbs_directional.indexOf(state.current_line_wip_array[1][0]) >= 0;
                                    if (directional_verb) {
                                        //match seed or direction                          
                                        let is_direction = stream.match(reg_sounddirectionindicators, true);
                                        if (is_direction !== null) {
                                            tokentype = 'DIRECTION';
                                            state.current_line_wip_array.push([is_direction[0].trim(), tokentype]);
                                            state.tokenIndex++;
                                        } else {
                                            let is_seed = stream.match(reg_soundseed, true);
                                            if (is_seed !== null) {
                                                tokentype = 'SOUND';
                                                state.current_line_wip_array.push([is_seed[0].trim(), tokentype]);
                                                state.tokenIndex++;
                                            } else {
                                                let match = errorFallbackMatchToken(stream);
                                                //depending on whether the verb is directional or not, we log different errors
                                                logError(`Ah I was expecting direction or a sound seed here after ${state.current_line_wip_array[state.current_line_wip_array.length - 1][0].toUpperCase()}, but I don't know what to make of "${match[0].trim().toUpperCase()}".`, state.lineNumber);
                                                tokentype = 'ERROR';
                                                state.current_line_wip_array.push("ERROR");
                                            }
                                        }
                                    } else {
                                        //only match seed
                                        let is_seed = stream.match(reg_soundseed, true);
                                        if (is_seed !== null) {
                                            tokentype = 'SOUND';
                                            state.current_line_wip_array.push([is_seed[0].trim(), tokentype]);
                                            state.tokenIndex++;
                                        } else {
                                            let match = errorFallbackMatchToken(stream);
                                            //depending on whether the verb is directional or not, we log different errors
                                            logError(`Ah I was expecting a sound seed here after ${state.current_line_wip_array[state.current_line_wip_array.length - 1][0].toUpperCase()}, but I don't know what to make of "${match[0].trim().toUpperCase()}".`, state.lineNumber);
                                            tokentype = 'ERROR';
                                            state.current_line_wip_array.push("ERROR");
                                        }
                                    }
                                }
                            }
                        }

                        if (stream.eol()) {
                            processSoundsLine(state);
                        }

                        return tokentype;
                    }
                case 'collisionlayers':
                    {
                        if (sol) {
                            //create new collision layer
                            state.collisionLayers.push([]);
                            //empty current_line_wip_array
                            state.current_line_wip_array = [];
                            state.tokenIndex = 0;
                        }

                        let match_name = stream.match(reg_name, true);
                        if (match_name === null) {
                            //then strip spaces and commas
                            let prepos = stream.pos;
                            stream.match(reg_csv_separators, true);
                            if (stream.pos == prepos) {
                                logError("error detected - unexpected character " + stream.peek(), state.lineNumber);
                                stream.next();
                            }
                            return null;
                        } else {
                            //have a name: let's see if it's valid
                            let candname = match_name[0].trim();

                            let substitutor = function (n) {
                                n = n.toLowerCase();
                                if (n in state.objects) {
                                    return [n];
                                }


                                for (let i = 0; i < state.legend_synonyms.length; i++) {
                                    let a = state.legend_synonyms[i];
                                    if (a[0] === n) {
                                        return substitutor(a[1]);
                                    }
                                }

                                for (let i = 0; i < state.legend_aggregates.length; i++) {
                                    let a = state.legend_aggregates[i];
                                    if (a[0] === n) {
                                        logError('"' + n + '" is an aggregate (defined using "and"), and cannot be added to a single layer because its constituent objects must be able to coexist.', state.lineNumber);
                                        return [];
                                    }
                                }
                                for (let i = 0; i < state.legend_properties.length; i++) {
                                    let a = state.legend_properties[i];
                                    if (a[0] === n) {
                                        let result = [];
                                        for (let j = 1; j < a.length; j++) {
                                            if (a[j] === n) {
                                                //error here superfluous, also detected elsewhere (cf 'You can't define object' / #789)
                                                //logError('Error, recursive definition found for '+n+'.', state.lineNumber);                                
                                            } else {
                                                result = result.concat(substitutor(a[j]));
                                            }
                                        }
                                        return result;
                                    }
                                }
                                logError('Cannot add "' + candname.toUpperCase() + '" to a collision layer; it has not been declared.', state.lineNumber);
                                return [];
                            };
                            if (candname === 'background') {
                                if (state.collisionLayers.length > 0 && state.collisionLayers[state.collisionLayers.length - 1].length > 0) {
                                    logError("Background must be in a layer by itself.", state.lineNumber);
                                }
                                state.tokenIndex = 1;
                            } else if (state.tokenIndex !== 0) {
                                logError("Background must be in a layer by itself.", state.lineNumber);
                            }

                            let ar = substitutor(candname);

                            if (state.collisionLayers.length === 0) {
                                //pre-empted by other messages
                                logError("no layers found.", state.lineNumber);
                                return 'ERROR';
                            }

                            let foundOthers = [];
                            let foundSelves = [];
                            for (let i = 0; i < ar.length; i++) {
                                let tcandname = ar[i];
                                for (let j = 0; j <= state.collisionLayers.length - 1; j++) {
                                    let clj = state.collisionLayers[j];
                                    if (clj.indexOf(tcandname) >= 0) {
                                        if (j !== state.collisionLayers.length - 1) {
                                            foundOthers.push(j);
                                        } else {
                                            foundSelves.push(j);
                                        }
                                    }
                                }
                            }
                            if (foundOthers.length > 0) {
                                let warningStr = 'Object "' + candname.toUpperCase() + '" included in multiple collision layers ( layers ';
                                for (let i = 0; i < foundOthers.length; i++) {
                                    warningStr += "#" + (foundOthers[i] + 1) + ", ";
                                }
                                warningStr += "#" + state.collisionLayers.length;
                                logWarning(warningStr + ' ). You should fix this!', state.lineNumber);
                            }

                            if (state.current_line_wip_array.indexOf(candname) >= 0) {
                                let warningStr = 'Object "' + candname.toUpperCase() + '" included explicitly multiple times in the same layer. Don\'t do that innit.';
                                logWarning(warningStr, state.lineNumber);
                            }
                            state.current_line_wip_array.push(candname);

                            state.collisionLayers[state.collisionLayers.length - 1] = state.collisionLayers[state.collisionLayers.length - 1].concat(ar);
                            if (ar.length > 0) {
                                return 'NAME';
                            } else {
                                return 'ERROR';
                            }
                        }
                        break;
                    }
                case 'rules':
                    {
                        if (sol) {
                            let rule = reg_notcommentstart.exec(stream.string)[0];
                            state.rules.push([rule, state.lineNumber, mixedCase]);
                            state.tokenIndex = 0;//in rules, records whether bracket has been found or not
                        }

                        if (state.tokenIndex === -4) {
                            stream.skipToEnd();
                            return 'MESSAGE';
                        }
                        if (stream.match(/[\p{Z}\s]*->[\p{Z}\s]*/u, true)) {
                            return 'ARROW';
                        }
                        if (ch === '[' || ch === '|' || ch === ']' || ch === '+') {
                            if (ch !== '+') {
                                state.tokenIndex = 1;
                            }
                            stream.next();
                            stream.match(/[\p{Z}\s]*/u, true);
                            return 'BRACKET';
                        } else {
                            let m = stream.match(/[^\[\|\]\p{Z}\s]*/u, true)[0].trim();

                            if (state.tokenIndex === 0 && reg_loopmarker.exec(m)) {
                                return 'BRACKET';
                            } else if (state.tokenIndex === 0 && reg_ruledirectionindicators.exec(m)) {
                                stream.match(/[\p{Z}\s]*/u, true);
                                return 'DIRECTION';
                            } else if (state.tokenIndex === 1 && reg_directions.exec(m)) {
                                stream.match(/[\p{Z}\s]*/u, true);
                                return 'DIRECTION';
                            } else {
                                if (state.names.indexOf(m) >= 0) {
                                    if (sol) {
                                        logError('Objects cannot appear outside of square brackets in rules, only directions can.', state.lineNumber);
                                        return 'ERROR';
                                    } else {
                                        stream.match(/[\p{Z}\s]*/u, true);
                                        return 'NAME';
                                    }
                                } else if (m === '...') {
                                    return 'DIRECTION';
                                } else if (m === 'rigid') {
                                    return 'DIRECTION';
                                } else if (m === 'random') {
                                    return 'DIRECTION';
                                } else if (commandwords.indexOf(m) >= 0) {
                                    if (m === 'message') {
                                        state.tokenIndex = -4;
                                    }
                                    return 'COMMAND';
                                } else {
                                    logError('Name "' + m + '", referred to in a rule, does not exist.', state.lineNumber);
                                    return 'ERROR';
                                }
                            }
                        }

                        break;
                    }
                case 'winconditions':
                    {
                        if (sol) {
                            let tokenized = reg_notcommentstart.exec(stream.string);
                            let splitted = tokenized[0].split(/[\p{Z}\s]/u);
                            let filtered = splitted.filter(function (v) { return v !== '' });
                            filtered.push(state.lineNumber);

                            state.winconditions.push(filtered);
                            state.tokenIndex = -1;
                        }
                        state.tokenIndex++;

                        let match = stream.match(/[\p{Z}\s]*[\p{L}\p{N}_]+[\p{Z}\s]*/u);
                        if (match === null) {
                            logError('incorrect format of win condition.', state.lineNumber);
                            stream.match(reg_notcommentstart, true);
                            return 'ERROR';

                        } else {
                            let candword = match[0].trim();
                            if (state.tokenIndex === 0) {
                                if (reg_winconditionquantifiers.exec(candword)) {
                                    return 'LOGICWORD';
                                }
                                else {
                                    logError('Expecting the start of a win condition ("ALL","SOME","NO") but got "' + candword.toUpperCase() + "'.", state.lineNumber);
                                    return 'ERROR';
                                }
                            }
                            else if (state.tokenIndex === 2) {
                                if (candword != 'on') {
                                    logError('Expecting the word "ON" but got "' + candword.toUpperCase() + "\".", state.lineNumber);
                                    return 'ERROR';
                                } else {
                                    return 'LOGICWORD';
                                }
                            }
                            else if (state.tokenIndex === 1 || state.tokenIndex === 3) {
                                if (state.names.indexOf(candword) === -1) {
                                    logError('Error in win condition: "' + candword.toUpperCase() + '" is not a valid object name.', state.lineNumber);
                                    return 'ERROR';
                                } else {
                                    return 'NAME';
                                }
                            } else {
                                logError("Error in win condition: I don't know what to do with " + candword.toUpperCase() + ".", state.lineNumber);
                                return 'ERROR';
                            }
                        }
                        break;
                    }
                case 'levels':
                    {
                        if (sol) {
                            if (stream.match(/[\p{Z}\s]*message\b[\p{Z}\s]*/u, true)) {
                                state.tokenIndex = -4;//-4/2 = message/level
                                let newdat = ['\n', mixedCase.slice(stream.pos).trim(), state.lineNumber];
                                if (state.levels[state.levels.length - 1].length === 0) {
                                    state.levels.splice(state.levels.length - 1, 0, newdat);
                                } else {
                                    state.levels.push(newdat);
                                }
                                return 'MESSAGE_VERB';//a duplicate of the previous section as a legacy thing for #589 
                            } else if (stream.match(/[\p{Z}\s]*message[\p{Z}\s]*/u, true)) {//duplicating previous section because of #589
                                logWarning("You probably meant to put a space after 'message' innit.  That's ok, I'll still interpret it as a message, but you probably want to put a space there.", state.lineNumber);
                                state.tokenIndex = -4;//-4/2 = message/level
                                let newdat = ['\n', mixedCase.slice(stream.pos).trim(), state.lineNumber];
                                if (state.levels[state.levels.length - 1].length === 0) {
                                    state.levels.splice(state.levels.length - 1, 0, newdat);
                                } else {
                                    //don't seem to ever reach this.
                                    state.levels.push(newdat);
                                }
                                return 'MESSAGE_VERB';
                            } else {
                                let matches = stream.match(reg_notcommentstart, false);
                                if (matches === null || matches.length === 0) {
                                    //not sure if it's possible to get here.
                                    logError("Detected a comment where I was expecting a level. Oh gosh; if this is to do with you using '(' as a character in the legend, please don't do that ^^", state.lineNumber);
                                    state.commentLevel++;
                                    stream.skipToEnd();
                                    return 'comment';
                                } else {
                                    let line = matches[0].trim();
                                    state.tokenIndex = 2;
                                    let lastlevel = state.levels[state.levels.length - 1];
                                    if (lastlevel[0] == '\n') {
                                        state.levels.push([state.lineNumber, line]);
                                    } else {
                                        if (lastlevel.length == 0) {
                                            lastlevel.push(state.lineNumber);
                                        }
                                        lastlevel.push(line);

                                        if (lastlevel.length > 1) {
                                            if (line.length != lastlevel[1].length) {
                                                logWarning("Maps must be rectangular, yo (In a level, the length of each row must be the same).", state.lineNumber);
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if (state.tokenIndex == -4) {
                                stream.skipToEnd();
                                return 'MESSAGE';
                            }
                        }

                        if (state.tokenIndex === 2 && !stream.eol()) {
                            let ch = stream.peek();
                            stream.next();
                            if (state.abbrevNames.indexOf(ch) >= 0) {
                                return 'LEVEL';
                            } else {
                                logError('Key "' + ch.toUpperCase() + '" not found. Do you need to add it to the legend, or define a new object?', state.lineNumber);
                                return 'ERROR';
                            }
                        }
                        break;
                    }

                default://if you're in the preamble
                    {
                        if (sol || state.sol_after_comment) {
                            state.tokenIndex = 0;
                        }
                        if (state.tokenIndex == 0) {
                            let match = stream.match(/[\p{Z}\s]*[\p{L}\p{N}_]+[\p{Z}\s]*/u);
                            if (match !== null) {
                                let token = match[0].trim();
                                if (sol) {
                                    if (['title', 'author', 'homepage', 'background_color', 'text_color', 'key_repeat_interval', 'realtime_interval', 'again_interval', 'flickscreen', 'zoomscreen', 'color_palette', 'youtube'].indexOf(token) >= 0) {

                                        if (token === 'author' || token === 'homepage' || token === 'title') {
                                            stream.string = mixedCase;
                                        }

                                        if (token === "youtube") {
                                            logWarning("Unfortunately, YouTube support hasn't been working properly for a long time - it was always a hack and it hasn't gotten less hacky over time, so I can no longer pretend to support it.", state.lineNumber);
                                        }

                                        let m2 = stream.match(reg_notcommentstart, false);

                                        if (m2 !== null) {
                                            state.metadata.push(token);
                                            state.metadata.push(m2[0].trim());
                                            if (token in state.metadata_lines) {
                                                let otherline = state.metadata_lines[token];
                                                logWarning(`You've already defined a ${token.toUpperCase()} in the prelude on line <a onclick="jumpToLine(${otherline})>${otherline}</a>.`, state.lineNumber);
                                            }
                                            state.metadata_lines[token] = state.lineNumber;
                                        } else {
                                            logError('MetaData "' + token + '" needs a value.', state.lineNumber);
                                        }
                                        state.tokenIndex = 1;
                                        return 'METADATA';
                                    } else if (['run_rules_on_level_start', 'norepeat_action', 'require_player_movement', 'debug', 'verbose_logging', 'throttle_movement', 'noundo', 'noaction', 'norestart', 'scanline'].indexOf(token) >= 0) {
                                        state.metadata.push(token);
                                        state.metadata.push("true");
                                        state.tokenIndex = -1;


                                        let m2 = stream.match(reg_notcommentstart, false);

                                        if (m2 !== null) {
                                            let extra = m2[0].trim();
                                            logWarning('MetaData ' + token.toUpperCase() + ' doesn\'t take any parameters, but you went and gave it "' + extra + '".', state.lineNumber);
                                        }

                                        return 'METADATA';
                                    } else {
                                        logError('Unrecognised stuff in the prelude.', state.lineNumber);
                                        return 'ERROR';
                                    }
                                } else if (state.tokenIndex == -1) {
                                    //no idea how to get here. covered with a similar error message above.
                                    logError('MetaData "' + token + '" has no parameters.', state.lineNumber);
                                    return 'ERROR';
                                }
                                return 'METADATA';
                            } else {
                                //garbage found
                                logError(`Unrecognised stuff "${stream.string}" in the prelude.`, state.lineNumber);
                            }
                        } else {
                            stream.match(reg_notcommentstart, true);
                            state.tokenIndex++;

                            let key = state.metadata[state.metadata.length - 2];
                            let val = state.metadata[state.metadata.length - 1];

                            if (state.tokenIndex > 2) {
                                logWarning("Error: you can't embed comments in metadata values. Anything after the comment will be ignored.", state.lineNumber);
                                return 'ERROR';
                            }
                            if (key === "background_color" || key === "text_color") {
                                let candcol = val.trim().toLowerCase();
                                if (candcol in colorPalettes.arnecolors) {
                                    return 'COLOR COLOR-' + candcol.toUpperCase();
                                } else if (candcol === "transparent") {
                                    return 'COLOR FADECOLOR';
                                } else if ((candcol.length === 4) || (candcol.length === 7)) {
                                    let color = candcol.match(/#[0-9a-fA-F]+/);
                                    if (color !== null) {
                                        return 'MULTICOLOR' + color[0];
                                    }
                                }

                            }
                            return "METADATATEXT";
                        }
                        break;
                    }
            }


            if (stream.eol()) {
                //don't know how to reach this.
                return null;
            }

            if (!stream.eol()) {
                stream.next();
                return null;
            }
        },
        startState: function () {
            return {
                /*
                    permanently useful
                */
                objects: {},

                /*
                    for parsing
                */
                lineNumber: 0,

                commentLevel: 0,

                section: '',
                visitedSections: [],

                line_should_end: false,
                line_should_end_because: '',
                sol_after_comment: false,

                objects_candname: '',
                objects_section: 0, //whether reading name/color/spritematrix
                objects_spritematrix: [],

                collisionLayers: [],

                tokenIndex: 0,

                current_line_wip_array: [],

                legend_synonyms: [],
                legend_aggregates: [],
                legend_properties: [],

                sounds: [],
                rules: [],

                names: [],

                winconditions: [],
                metadata: [],
                metadata_lines: {},

                original_case_names: {},
                original_line_numbers: {},

                abbrevNames: [],

                levels: [[]],

                subsection: ''
            };
        }
    };
};

window.CodeMirror.defineMode('puzzle', codeMirrorFn);

</script>
<script>
'use strict';


function isColor(str) {
    str = str.trim();
    if (str in colorPalettes.arnecolors)
        return true;
    if (REGEX_HEX.test(str))
        return true;
    if (str === "transparent")
        return true;
    return false;
}

function colorToHex(palette, str) {
    str = str.trim();
    if (str in palette) {
        return palette[str];
    }

    return str;
}


function generateSpriteMatrix(dat) {

    let result = [];
    for (let i = 0; i < dat.length; i++) {
        let row = [];
        for (let j = 0; j < dat.length; j++) {
            let ch = dat[i].charAt(j);
            if (ch === '.') {
                row.push(-1);
            } else {
                row.push(ch);
            }
        }
        result.push(row);
    }
    return result;
}

let debugMode;
let colorPalette;

function generateExtraMembers(state) {

    //annotate objects with layers
    //assign ids at the same time
    state.idDict = [];
    let idcount = 0;
    for (let layerIndex = 0; layerIndex < state.collisionLayers.length; layerIndex++) {
        for (let j = 0; j < state.collisionLayers[layerIndex].length; j++) {
            let n = state.collisionLayers[layerIndex][j];
            if (n in state.objects) {
                let o = state.objects[n];
                o.layer = layerIndex;
                o.id = idcount;
                state.idDict[idcount] = n;
                idcount++;
            }
        }
    }

    //set object count
    state.objectCount = idcount;

    //calculate blank mask template
    let layerCount = state.collisionLayers.length;
    let blankMask = [];
    for (let i = 0; i < layerCount; i++) {
        blankMask.push(-1);
    }

    // how many words do our bitvecs need to hold?
    STRIDE_OBJ = Math.ceil(state.objectCount / 32) | 0;
    STRIDE_MOV = Math.ceil(layerCount / 5) | 0;
    LAYER_COUNT = layerCount;
    state.STRIDE_OBJ = STRIDE_OBJ;
    state.STRIDE_MOV = STRIDE_MOV;
    state.LAYER_COUNT = LAYER_COUNT;
    RebuildGameArrays();
    
    //get colorpalette name
    debugMode = false;
    verbose_logging = false;
    throttle_movement = false;
    colorPalette = colorPalettes.arnecolors;
    for (let i = 0; i < state.metadata.length; i += 2) {
        let key = state.metadata[i];
        let val = state.metadata[i + 1];
        if (key === 'color_palette') {
            if (val in colorPalettesAliases) {
                val = colorPalettesAliases[val];
            }
            if (colorPalettes[val] === undefined) {
                logError('Palette "' + val + '" not found, defaulting to arnecolors.', 0);
            } else {
                colorPalette = colorPalettes[val];
            }
        } else if (key === 'debug') {
            if (IDE && unitTesting === false) {
                debugMode = true;
                cache_console_messages = true;
            }
        } else if (key === 'verbose_logging') {
            if (IDE && unitTesting === false) {
                verbose_logging = true;
                cache_console_messages = true;
            }
        } else if (key === 'throttle_movement') {
            throttle_movement = true;
        }
    }

    let glyphOrder = [];
    let glyphDict = {};

    //convert colors to hex
    const state_object_keys = Object.keys(state.objects);
    const state_object_keys_l = state_object_keys.length;
    for (let k_i = 0; k_i < state_object_keys_l; k_i++) {
        const n = state_object_keys[k_i];
        //convert color to hex
        let o = state.objects[n];
        if (o.colors.length > 10) {
            logError("a sprite cannot have more than 10 colors.  Why you would want more than 10 is beyond me.", o.lineNumber + 1);
        }
        for (let i = 0; i < o.colors.length; i++) {
            let c = o.colors[i];
            if (isColor(c)) {
                c = colorToHex(colorPalette, c);
                o.colors[i] = c;
            } else {
                logError('Invalid color specified for object "' + n + '", namely "' + o.colors[i] + '".', o.lineNumber + 1);
                o.colors[i] = '#ff00ff'; // magenta error color
            }
        }        

        if (o.colors.length === 0) {
            logError('color not specified for object "' + n + '".', o.lineNumber);
            o.colors = ["#ff00ff"];
        }
        if (o.spritematrix.length === 0) {
            o.spritematrix = [
                [0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0]
            ];
        } else {
            if (o.spritematrix.length !== 5 || o.spritematrix[0].length !== 5 || o.spritematrix[1].length !== 5 || o.spritematrix[2].length !== 5 || o.spritematrix[3].length !== 5 || o.spritematrix[4].length !== 5) {
                logWarning("Sprite graphics must be 5 wide and 5 high exactly.", o.lineNumber);
            }
            o.spritematrix = generateSpriteMatrix(o.spritematrix);
        }    

        let mask = blankMask.concat([]);
        mask[o.layer] = o.id;
        glyphDict[n] = mask;
        glyphOrder.push([o.lineNumber, n]);    
    }

    let added = true;
    while (added) {
        added = false;

        //then, synonyms
        for (let i = 0; i < state.legend_synonyms.length; i++) {
            let dat = state.legend_synonyms[i];
            let key = dat[0];
            let val = dat[1];
            if ((!(key in glyphDict) || (glyphDict[key] === undefined)) && (glyphDict[val] !== undefined)) {
                added = true;
                glyphDict[key] = glyphDict[val];
                glyphOrder.push([dat.lineNumber, key]);
            }
        }

        //then, aggregates
        for (let i = 0; i < state.legend_aggregates.length; i++) {
            let dat = state.legend_aggregates[i];
            let key = dat[0];
            let vals = dat.slice(1);
            let allVallsFound = true;
            for (let j = 0; j < vals.length; j++) {
                let v = vals[j];
                if (glyphDict[v] === undefined) {
                    allVallsFound = false;
                    break;
                }
            }
            if ((!(key in glyphDict) || (glyphDict[key] === undefined)) && allVallsFound) {
                let mask = blankMask.concat([]);

                for (let j = 1; j < dat.length; j++) {
                    let n = dat[j];
                    let o = state.objects[n];
                    if (o === undefined) {
                        logError('Object not found with name ' + n, state.lineNumber);
                    }
                    if (mask[o.layer] === -1) {
                        mask[o.layer] = o.id;
                    } else {
                        if (o.layer === undefined) {
                            logError('Object "' + n.toUpperCase() + '" has been defined, but not assigned to a layer.', dat.lineNumber);
                        } else {
                            let n1 = n.toUpperCase();
                            let n2 = state.idDict[mask[o.layer]].toUpperCase();
                            // if (n1 !== n2) {
                            logError(
                                'Trying to create an aggregate object (something defined in the LEGEND section using AND) with both "' +
                                n1 + '" and "' + n2 + '", which are on the same layer and therefore can\'t coexist.',
                                dat.lineNumber
                            );
                            // }
                        }
                    }
                }
                added = true;
                glyphDict[dat[0]] = mask;
                glyphOrder.push([dat.lineNumber, key]);
            }
        }
    }

    //sort glyphs line number
    glyphOrder.sort((a, b) => a[0] - b[0]);
    glyphOrder = glyphOrder.map(a => a[1]);

    state.glyphDict = glyphDict;
    state.glyphOrder = glyphOrder;

    let aggregatesDict = {};
    for (let i = 0; i < state.legend_aggregates.length; i++) {
        let entry = state.legend_aggregates[i];
        aggregatesDict[entry[0]] = entry.slice(1);
    }
    state.aggregatesDict = aggregatesDict;

    let propertiesDict = {};
    for (let i = 0; i < state.legend_properties.length; i++) {
        let entry = state.legend_properties[i];
        propertiesDict[entry[0]] = entry.slice(1);
    }
    state.propertiesDict = propertiesDict;

    //calculate lookup dictionaries
    let synonymsDict = {};
    for (let i = 0; i < state.legend_synonyms.length; i++) {
        let entry = state.legend_synonyms[i];
        let key = entry[0];
        let value = entry[1];
        if (value in aggregatesDict) {
            aggregatesDict[key] = aggregatesDict[value];
        } else if (value in propertiesDict) {
            propertiesDict[key] = propertiesDict[value];
        } else if (key !== value) {
            synonymsDict[key] = value;
        }
    }
    state.synonymsDict = synonymsDict;

    let modified = true;
    while (modified) {
        modified = false;

        const synonymsDict_keys = Object.keys(synonymsDict);
        const synonymsDict_keys_l = synonymsDict_keys.length;   
        for (let k_i = 0; k_i < synonymsDict_keys_l; k_i++) {
            const n = synonymsDict_keys[k_i];
            let value = synonymsDict[n];
            if (value in propertiesDict) {
                delete synonymsDict[n];
                propertiesDict[n] = propertiesDict[value];
                modified = true;
            } else if (value in aggregatesDict) {
                delete aggregatesDict[n];
                aggregatesDict[n] = aggregatesDict[value];
                modified = true;
            } else if (value in synonymsDict) {
                synonymsDict[n] = synonymsDict[value];
            }            
        }

        const propertiesDict_keys = Object.keys(propertiesDict);
        const propertiesDict_keys_l = propertiesDict_keys.length;
        for (let k_i = 0; k_i < propertiesDict_keys_l; k_i++) {
            const n = propertiesDict_keys[k_i];
            let values = propertiesDict[n];
            for (let i = 0; i < values.length; i++) {
                let value = values[i];
                if (value in synonymsDict) {
                    values[i] = synonymsDict[value];
                    modified = true;
                } else if (value in propertiesDict) {
                    values.splice(i, 1);
                    let newvalues = propertiesDict[value];
                    for (let j = 0; j < newvalues.length; j++) {
                        let newvalue = newvalues[j];
                        if (values.indexOf(newvalue) === -1) {
                            values.push(newvalue);
                        }
                    }
                    modified = true;
                }
                if (value in aggregatesDict) {
                    logError('Trying to define property "' + n.toUpperCase() + '" in terms of aggregate "' + value.toUpperCase() + '".');
                }
            }        
        }

        const aggregatesDict_keys = Object.keys(aggregatesDict);
        const aggregatesDict_keys_l = aggregatesDict_keys.length;
        for (let k_i = 0; k_i < aggregatesDict_keys_l; k_i++) {
            const n = aggregatesDict_keys[k_i];
            let values = aggregatesDict[n];
            for (let i = 0; i < values.length; i++) {
                let value = values[i];
                if (value in synonymsDict) {
                    values[i] = synonymsDict[value];
                    modified = true;
                } else if (value in aggregatesDict) {
                    values.splice(i, 1);
                    let newvalues = aggregatesDict[value];
                    for (let j = 0; j < newvalues.length; j++) {
                        let newvalue = newvalues[j];
                        if (values.indexOf(newvalue) === -1) {
                            values.push(newvalue);
                        }
                    }
                    modified = true;
                }
                if (value in propertiesDict) {
                    logError('Trying to define aggregate "' + n.toUpperCase() + '" in terms of property "' + value.toUpperCase() + '".');
                }
            }        
        }
    }

    /* determine which properties specify objects all on one layer */
    state.propertiesSingleLayer = {};
    const propertiesDict_keys = Object.keys(propertiesDict);
    const propertiesDict_keys_l = propertiesDict_keys.length;
    for (let k_i = 0; k_i < propertiesDict_keys_l; k_i++) {
        const key = propertiesDict_keys[k_i];
        let values = propertiesDict[key];
        let sameLayer = true;
        for (let i = 1; i < values.length; i++) {
            if ((state.objects[values[i - 1]].layer !== state.objects[values[i]].layer)) {
                sameLayer = false;
                break;
            }
        }
        if (sameLayer) {
            state.propertiesSingleLayer[key] = state.objects[values[0]].layer;        
        }
    }

    if (state.idDict[0] === undefined && state.collisionLayers.length > 0) {
        logError('You need to have some objects defined');
    }

    //set default background object
    let backgroundid;
    let backgroundlayer;
    if (state.objects.background === undefined) {
        if ('background' in state.synonymsDict) {
            let n = state.synonymsDict['background'];
            let o = state.objects[n];
            backgroundid = o.id;
            backgroundlayer = o.layer;
        } else if ('background' in state.propertiesDict) {
            let backgrounddef = state.propertiesDict['background'];
            let n = backgrounddef[0];
            let o = state.objects[n];
            backgroundid = o.id;
            backgroundlayer = o.layer;
            for (let i = 1; i < backgrounddef.length; i++) {
                let nnew = backgrounddef[i];
                let onew = state.objects[nnew];
                if (onew.layer !== backgroundlayer) {
                    let lineNumber = state.original_line_numbers['background'];
                    logError('Background objects must be on the same layer', lineNumber);
                }
            }
        } else if ('background' in state.aggregatesDict) {
            let o = state.objects[state.idDict[0]];
            backgroundid = o.id;
            backgroundlayer = o.layer;
            let lineNumber = state.original_line_numbers['background'];
            logError("background cannot be an aggregate (declared with 'and'), it has to be a simple type, or property (declared in terms of others using 'or').", lineNumber);
        } else {
            //background doesn't exist. Error already printed elsewhere.
            let o = state.objects[state.idDict[0]];
            if (o != null) {
                backgroundid = o.id;
                backgroundlayer = o.layer;
            }
            logError("Seriously, you have to define something to be the background.");
        }
    } else {
        backgroundid = state.objects.background.id;
        backgroundlayer = state.objects.background.layer;
    }
    state.backgroundid = backgroundid;
    state.backgroundlayer = backgroundlayer;
}

function levelFromString(state, level) {
    let backgroundlayer = state.backgroundlayer;
    let backgroundid = state.backgroundid;
    let backgroundLayerMask = state.layerMasks[backgroundlayer];
    let o = new Level(level[0], level[1].length, level.length - 1, state.collisionLayers.length, null);
    o.objects = new Int32Array(o.width * o.height * STRIDE_OBJ);

    for (let i = 0; i < o.width; i++) {
        for (let j = 0; j < o.height; j++) {
            let ch = level[j + 1].charAt(i);
            if (ch.length === 0) {
                ch = level[j + 1].charAt(level[j + 1].length - 1);
            }
            let mask = state.glyphDict[ch];

            if (mask === undefined) {
                if (state.propertiesDict[ch] === undefined) {
                    logError('Error, symbol "' + ch + '", used in map, not found.', level[0] + j);
                } else {
                    logError('Error, symbol "' + ch + '" is defined using OR, and therefore ambiguous - it cannot be used in a map. Did you mean to define it in terms of AND?', level[0] + j);
                }
                return o;
            }

            let maskint = new BitVec(STRIDE_OBJ);
            mask = mask.concat([]);
            for (let z = 0; z < o.layerCount; z++) {
                if (mask[z] >= 0) {
                    maskint.ibitset(mask[z]);
                }
            }
            for (let w = 0; w < STRIDE_OBJ; ++w) {
                o.objects[STRIDE_OBJ * (i * o.height + j) + w] = maskint.data[w];
            }
        }
    }

    const levelBackgroundMask = o.calcBackgroundMask(state);
    for (let i = 0; i < o.n_tiles; i++) {
        let cell = o.getCell(i);
        if (!backgroundLayerMask.anyBitsInCommon(cell)) {
            cell.ior(levelBackgroundMask);
            o.setCell(i, cell);
        }
    }
    return o;
}
//also assigns glyphDict
function levelsToArray(state) {
    let levels = state.levels;
    let processedLevels = [];

    for (let levelIndex = 0; levelIndex < levels.length; levelIndex++) {
        let level = levels[levelIndex];
        if (level.length === 0) {
            continue;
        }
        if (level[0] === '\n') {

            let o = {
                message: level[1]
            };
            splitMessage = wordwrap(o.message, intro_template[0].length);
            if (splitMessage.length > 12) {
                logWarning('Message too long to fit on screen.', level[2]);
            }

            processedLevels.push(o);
        } else {
            let o = levelFromString(state, level);
            processedLevels.push(o);
        }

    }

    state.levels = processedLevels;
}

function directionalRule(rule) {
    for (let i = 0; i < rule.lhs.length; i++) {
        let cellRow = rule.lhs[i];
        if (cellRow.length > 1) {
            return true;
        }
        for (let j = 0; j < cellRow.length; j++) {
            let cell = cellRow[j];
            for (let k = 0; k < cell.length; k += 2) {
                if (relativeDirections.indexOf(cell[k]) >= 0) {
                    return true;
                }
            }
        }
    }
    for (let i = 0; i < rule.rhs.length; i++) {
        let cellRow = rule.rhs[i];
        for (let j = 0; j < cellRow.length; j++) {
            let cell = cellRow[j];
            for (let k = 0; k < cell.length; k += 2) {
                if (relativeDirections.indexOf(cell[k]) >= 0) {
                    return true;
                }
            }
        }
    }
    return false;
}

function findIndexAfterToken(str, tokens, tokenIndex) {
    str = str.toLowerCase();
    let curIndex = 0;
    for (let i = 0; i <= tokenIndex; i++) {
        let token = tokens[i];
        curIndex = str.indexOf(token, curIndex) + token.length;
    }
    return curIndex;
}
function rightBracketToRightOf(tokens, i) {
    for (; i < tokens.length; i++) {
        if (tokens[i] === "]") {
            return true;
        }
    }
    return false;
}

function processRuleString(rule, state, curRules) {
    /*

        intermediate structure
            dirs: Directions[]
            pre : CellMask[]
            post : CellMask[]

            //pre/post pairs must have same lengths
        final rule structure
            dir: Direction
            pre : CellMask[]
            post : CellMask[]
    */
    let line = rule[0];
    let lineNumber = rule[1];
    let origLine = rule[2];

    // STEP ONE, TOKENIZE
    line = line.replace(/\[/g, ' [ ').replace(/\]/g, ' ] ').replace(/\|/g, ' | ').replace(/\-\>/g, ' -> ');
    line = line.trim();
    if (line[0] === '+') {
        line = line.substring(0, 1) + " " + line.substring(1, line.length);
    }
    let tokens = line.split(/\s/).filter(function (v) { return v !== '' });

    if (tokens.length === 0) {
        logError('Spooky error!  Empty line passed to rule function.', lineNumber);
    }


    // STEP TWO, READ DIRECTIONS
    /*
        STATE
        0 - scanning for initial directions
        LHS
        1 - reading cell contents LHS
        2 - reading cell contents RHS
    */
    let parsestate = 0;
    let directions = [];

    let curcell = null; // [up, cat, down mouse]
    let curcellrow = []; // [  [up, cat]  [ down, mouse ] ]

    let incellrow = false;

    let appendGroup = false;
    let rhs = false;
    let lhs_cells = [];
    let rhs_cells = [];
    let late = false;
    let rigid = false;
    let groupNumber = lineNumber;
    let commands = [];
    let randomRule = false;
    let has_plus = false;

    if (tokens.length === 1) {
        if (tokens[0] === "startloop") {
            let rule_line = {
                bracket: 1
            }
            return rule_line;
        } else if (tokens[0] === "endloop") {
            let rule_line = {
                bracket: -1
            }
            return rule_line;
        }
    }

    if (tokens.indexOf('->') === -1) {
        logError("A rule has to have an arrow in it.  There's no arrow here! Consider reading up about rules - you're clearly doing something weird", lineNumber);
    }

    curcell = [];
    let bracketbalance = 0;
    for (let i = 0; i < tokens.length; i++) {
        let token = tokens[i];
        switch (parsestate) {
            case 0:
                {
                    //read initial directions
                    if (token === '+') {
                        has_plus = true;
                        if (groupNumber === lineNumber) {
                            if (curRules.length === 0) {
                                logError('The "+" symbol, for joining a rule with the group of the previous rule, needs a previous rule to be applied to.', lineNumber);
                                has_plus = false;
                            }
                            if (i !== 0) {
                                logError('The "+" symbol, for joining a rule with the group of the previous rule, must be the first symbol on the line ', lineNumber);
                            }
                            if (has_plus) {
                                groupNumber = curRules[curRules.length - 1].groupNumber;
                            }
                        } else {
                            logError('Two "+"s (the "append to previous rule group" symbol) applied to the same rule.', lineNumber);
                        }
                    } else if (token in directionaggregates) {
                        directions = directions.concat(directionaggregates[token]);
                    } else if (token === 'late') {
                        late = true;
                    } else if (token === 'rigid') {
                        rigid = true;
                    } else if (token === 'random') {
                        randomRule = true;
                        if (has_plus) {
                            logError(`A rule-group can only be marked random by the opening rule in the group (aka, a '+' and 'random' can't appear as rule modifiers on the same line).  Why? Well, you see "random" isn't a property of individual rules, but of whole rule groups.  It indicates that a single possible application of some rule from the whole group should be applied at random.`, lineNumber)
                        }

                    } else if (simpleAbsoluteDirections.indexOf(token) >= 0) {
                        directions.push(token);
                    } else if (simpleRelativeDirections.indexOf(token) >= 0) {
                        logError('You cannot use relative directions (\"^v<>\") to indicate in which direction(s) a rule applies.  Use absolute directions indicators (Up, Down, Left, Right, Horizontal, or Vertical, for instance), or, if you want the rule to apply in all four directions, do not specify directions', lineNumber);
                    } else if (token === '[') {
                        if (directions.length === 0) {
                            directions = directions.concat(directionaggregates['orthogonal']);
                        }
                        parsestate = 1;
                        i--;
                    } else {
                        logError("The start of a rule must consist of some number of directions (possibly 0), before the first bracket, specifying in what directions to look (with no direction specified, it applies in all four directions).  It seems you've just entered \"" + token.toUpperCase() + '\".', lineNumber);
                    }
                    break;
                }
            case 1:
                {
                    if (token === '[') {
                        bracketbalance++;
                        if (bracketbalance > 1) {
                            logWarning("Multiple opening brackets without closing brackets.  Something fishy here.  Every '[' has to be closed by a ']', and you can't nest them.", lineNumber);
                        }
                        if (curcell.length > 0) {
                            logError('Error, malformed cell rule - encountered a "["" before previous bracket was closed', lineNumber);
                        }
                        incellrow = true;
                        curcell = [];
                    } else if (reg_directions_only.exec(token)) {
                        if (curcell.length % 2 === 1) {
                            logError("Error, an item can only have one direction/action at a time, but you're looking for several at once!", lineNumber);
                        } else if (!incellrow) {
                            logWarning("Invalid syntax. Directions should be placed at the start of a rule.", lineNumber);
                        } else if (late && token !== 'no' && token !== 'random' && token !== 'randomdir') {
                            logError("Movements cannot appear in late rules.", lineNumber);
                        } else {
                            curcell.push(token);
                        }
                    } else if (token === '|') {
                        if (!incellrow) {
                            logWarning('Janky syntax.  "|" should only be used inside cell rows (the square brackety bits).', lineNumber);
                        } else if (curcell.length % 2 === 1) {
                            logError('In a rule, if you specify a movement, it has to act on an object.', lineNumber);
                        } else {
                            curcellrow.push(curcell);
                            curcell = [];
                        }
                    } else if (token === ']') {

                        bracketbalance--;
                        if (bracketbalance < 0) {
                            logWarning("Multiple closing brackets without corresponding opening brackets.  Something fishy here.  Every '[' has to be closed by a ']', and you can't nest them.", lineNumber);
                            return null;
                        }

                        if (curcell.length % 2 === 1) {
                            if (curcell[0] === '...') {
                                logError('Cannot end a rule with ellipses.', lineNumber);
                            } else {
                                logError('In a rule, if you specify a movement, it has to act on an object.', lineNumber);
                            }
                        } else {
                            curcellrow.push(curcell);
                            curcell = [];
                        }

                        if (rhs) {
                            rhs_cells.push(curcellrow);
                        } else {
                            lhs_cells.push(curcellrow);
                        }
                        curcellrow = [];
                        incellrow = false;
                    } else if (token === '->') {

                        if (groupNumber !== lineNumber) {
                            let parentrule = curRules[curRules.length - 1];
                            if (parentrule.late !== late) {
                                logWarning('Oh gosh you can mix late and non-late rules in a rule-group if you really want to, but gosh why would you want to do that?  What do you expect to accomplish?', lineNumber);
                            }
                        }

                        if (incellrow) {
                            logWarning('Encountered an unexpected "->" inside square brackets.  It\'s used to separate states, it has no place inside them >:| .', lineNumber);
                        } else if (rhs) {
                            logError('Error, you can only use "->" once in a rule; it\'s used to separate before and after states.', lineNumber);
                            return null;
                        } else {
                            rhs = true;
                        }
                    } else if (state.names.indexOf(token) >= 0) {
                        if (!incellrow) {
                            logWarning("Invalid token " + token.toUpperCase() + ". Object names should only be used within cells (square brackets).", lineNumber);
                        } else {
                            //check that the object is not already present in the cell
                            for (let j = 0; j < curcell.length; j += 2) {
                                if (curcell[j + 1] === token) {
                                    logError(`You cannot specify the same object more than once in a single cell (in this case ${token} occurs mutliple times).`, lineNumber);
                                    if (token in state.propertiesDict){
                                        logWarningNoLine(`( However, noticing that you're committing this crime with <i>properties</i>, and not being able to help but acknowledge that you <i>may</i> be trying to do something esoteric and <i>clever</i> with the property inference system,  I might be brought to suggest that you consider this: you can have multiple equivalent properties with different names. )`);
                                    } 
                                }
                            }
                            if (curcell.length % 2 === 0) {
                                curcell.push('');
                                curcell.push(token);
                            } else if (curcell.length % 2 === 1) {
                                curcell.push(token);
                            } 
                        }
                    } else if (token === '...') {
                        if (!incellrow) {
                            logWarning("Invalid syntax, ellipses should only be used within cells (square brackets).", lineNumber);
                        } else {
                            curcell.push(token);
                            curcell.push(token);
                        }
                    } else if (commandwords.indexOf(token) >= 0) {
                        if (rhs === false) {
                            logError("Commands should only appear at the end of rules, not in or before the pattern-detection/-replacement sections.", lineNumber);
                        } else if (incellrow || rightBracketToRightOf(tokens, i)) {//only a warning for legacy support reasons.
                            logWarning("Commands should only appear at the end of rules, not in or before the pattern-detection/-replacement sections.", lineNumber);
                        }
                        if (token === 'message') {
                            let messageIndex = findIndexAfterToken(origLine, tokens, i);
                            let messageStr = origLine.substring(messageIndex).trim();
                            if (messageStr === "") {
                                messageStr = " ";
                                //needs to be nonempty or the system gets confused and thinks it's a whole level message rather than an interstitial.
                            }
                            commands.push([token, messageStr]);
                            i = tokens.length;
                        } else {
                            if (commandwords_sfx.indexOf(token) >= 0) {
                                //check defined
                                let found = false;
                                for (let j = 0; j < state.sounds.length; j++) {
                                    let sound = state.sounds[j];
                                    if (sound[0][0] === token) {
                                        found = true;
                                    }
                                }
                                if (!found) {
                                    logWarning('Sound effect "' + token + '" not defined.', lineNumber);
                                }
                            }
                            commands.push([token]);
                        }
                    } else {
                        logError('Error, malformed cell rule - was looking for cell contents, but found "' + token + '".  What am I supposed to do with this, eh, please tell me that.', lineNumber);
                    }
                }

        }
    }

    if (late && rigid) {
        logError("Late rules cannot be marked as rigid (rigid rules are all about dealing with the consequences of unresolvable movements, and late rules can't even have movements).", lineNumber);
    }

    if (lhs_cells.length != rhs_cells.length) {
        if (commands.length > 0 && rhs_cells.length === 0) {
            //ok
        } else {
            logWarning('Error, when specifying a rule, the number of matches (square bracketed bits) on the left hand side of the arrow must equal the number on the right', lineNumber);
        }
    } else {
        for (let i = 0; i < lhs_cells.length; i++) {
            if (lhs_cells[i].length != rhs_cells[i].length) {
                logError('In a rule, each pattern to match on the left must have a corresponding pattern on the right of equal length (number of cells).', lineNumber);
                state.invalid = true;
            }
            if (lhs_cells[i].length === 0) {
                logError("You have an totally empty pattern on the left-hand side.  This will match *everything*.  You certainly don't want this.");
            }
        }
    }

    if (lhs_cells.length === 0) {
        logError('This rule refers to nothing.  What the heck? :O', lineNumber);
    }

    let rule_line = {
        directions: directions,
        lhs: lhs_cells,
        rhs: rhs_cells,
        lineNumber: lineNumber,
        late: late,
        rigid: rigid,
        groupNumber: groupNumber,
        commands: commands,
        randomRule: randomRule
    };

    if (directionalRule(rule_line) === false && rule_line.directions.length > 1) {
        rule_line.directions.splice(1);
    }

    //next up - replace relative directions with absolute direction

    return rule_line;
}

function deepCloneHS(HS) {
    let cloneHS = HS.map(function (arr) { return arr.map(function (deepArr) { return deepArr.slice(); }); });
    return cloneHS;
}

function deepCloneRule(rule) {
    let clonedRule = {
        direction: rule.direction,
        lhs: deepCloneHS(rule.lhs),
        rhs: deepCloneHS(rule.rhs),
        lineNumber: rule.lineNumber,
        late: rule.late,
        rigid: rule.rigid,
        groupNumber: rule.groupNumber,
        commands: rule.commands,
        randomRule: rule.randomRule
    };
    return clonedRule;
}

function checkSuperfluousCoincidences(state,rules){

    /*
First, let's check for 'X no X' on the RHS.
    */
// check that that we don't have an object on one layer required, and at the same time
// 'no X' where x is also on that layer - it's   "no wall" and player in the same cell - for then "no wall" is
// superfluous.
// for each rule

    //first, find a list of layers where we *know* something has to be
    let required_layers = new BitVec(Math.ceil(LAYER_COUNT/32)|0);
    let required_objects = new BitVec(STRIDE_OBJ);
    
    const rules_l = rules.length;
    for (let i=0;i<rules_l;i++){
        let rule = rules[i];

        // First do a RHS check - you shouldn't have something amounting to
        // X no X on the RHS. (even if the engine does it internally a lot later)
        const rhs_len = rule.rhs.length;
        for (let j=0;j<rhs_len;j++){
            let rhs_group = rule.rhs[j];
            const rhs_group_len = rhs_group.length;
            for (let k=0;k<rhs_group_len;k++){
                let cell = rhs_group[k];
                var objects_present = [];
                var objects_present_mask = new BitVec(STRIDE_OBJ);
                for (let l=0;l<cell.length;l+=2){
                    let item = cell[l];
                    if (!item.startsWith("no")){
                        let no_name = cell[l+1];
                        if (state.objects.hasOwnProperty(no_name)){
                            objects_present.push(no_name);
                            objects_present_mask.ibitset(state.objects[no_name].id);
                        } else if (state.propertiesSingleLayer.hasOwnProperty(no_name)){
                            // objects_present.push(no_name);
                            // let property_obs = state.propertiesDict[no_name];
                            // for (let m=0;m<property_obs.length;m++){
                            //     let ob_data = state.objects[property_obs[m]];
                            //     objects_present_mask.ibitset(ob_data.id);
                            // }
                        } else if (state.propertiesDict.hasOwnProperty(no_name)){
                            // this is more complicated a case, right?
                            // let property_obs = state.propertiesDict[no_name];
                            // for (let m=0;m<property_obs.length;m++){
                            //     let ob_data = state.objects[property_obs[m]];
                            //     objects_present_mask.ibitset(ob_data.id);
                            // }
                        }
                    }
                }
                //for each 'no' object
                for (let l=0;l<cell.length;l+=2){
                    let item = cell[l];
                    if (item.startsWith("no")){
                        let no_name = cell[l+1];
                        var no_name_mask = state.objectMasks[no_name];

                        //if no_name overlaps with any objects_present, then we have a problem.
                        if (no_name_mask.anyBitsInCommon(objects_present_mask)){
                            logError(`You have specified that there should be NO ${no_name.toUpperCase()} but there is also a requirement that ${objects_present.join(", ").toUpperCase()} be here.  This is a mistake right?`, rule.lineNumber);
                        }
                    }
                }

            }
        }

        //secondly, for all 'no X' on the LHS, can remove any corresponding verbatim 'no X' on the RHS.
        for (let j=0;j<rhs_len;j++){
            let rhs_group = rule.rhs[j];
            const rhs_group_len = rhs_group.length;
            for (let k=0;k<rhs_group_len;k++){
                let cell = rhs_group[k];
                for (let l=0;l<cell.length;l+=2){
                    let item = cell[l];
                    if (item.startsWith("no")){
                        let no_name = cell[l+1];
                        //look for a 'no X' on the LHS in the same position
                        const lhs_cell = rule.lhs[j][k];
                        for (let m=0;m<lhs_cell.length;m+=2){
                            if (lhs_cell[m].startsWith("no") && lhs_cell[m+1] === no_name){
                                //we have a match - remove the 'no X' from the LHS
                                cell.splice(l,2);
                                break;
                            }
                        }

                    }
                }
            }
        }
    


        // thirdly, trim unnecessary 'no X's on the LHS - e.g. [ player no wall ]

        const lhs_len = rule.lhs.length;
        for (let j=0;j<lhs_len;j++){
            let lhs_group = rule.lhs[j];
            const lhs_group_len = lhs_group.length; 
            for (let k=0;k<lhs_group_len;k++){
                let cell = lhs_group[k];
                // cell is an array of pairs - it looks like:
                // ["", "player", "no", "wall", "", "target"]

                required_layers.setZero();
                required_objects.setZero();

                let occupier={};
                for (let l=0;l<cell.length;l+=2){
                    let entity_modifier = cell[l];
                    if (entity_modifier==="no"){
                        continue;
                    }
                    let entity_name = cell[l+1]
                    let layer=[];
                    //if it's a single-layer property
                    if (state.propertiesSingleLayer.hasOwnProperty(entity_name)){
                        let layer = state.propertiesSingleLayer[entity_name];
                        required_layers.ibitset(layer);
                        let property_obs = state.propertiesDict[entity_name];
                        const property_obs_len = property_obs.length;
                        for (let m=0;m<property_obs_len;m++){
                            const object_name = property_obs[m];
                            const object_data = state.objects[object_name];
                            required_objects.ibitset(object_data.id);
                        }
                        occupier[layer]=entity_name;
                    } else if (state.objects.hasOwnProperty(entity_name)){
                        let layer = state.objects[entity_name].layer;
                        let ob_id = state.objects[entity_name].id;
                        required_layers.ibitset(layer);
                        required_objects.ibitset(ob_id);
                        occupier[layer]=entity_name;
                    } else if (state.aggregatesDict.hasOwnProperty(entity_name)){
                        let aggregate_obs = state.aggregatesDict[entity_name];
                        for (let m=0;m<aggregate_obs.length;m++){
                            let object_info = state.objects[aggregate_obs[m]];
                            let layer = object_info.layer;
                            let ob_id = object_info.id;
                            required_layers.ibitset(layer);
                            required_objects.ibitset(ob_id);
                            occupier[layer]=entity_name;
                        }
                    }
                }

                
                //find all objects qualified by 'no'
                for (let l=0;l<cell.length;l+=2){
                    let item = cell[l];
                    if (item.startsWith("no")){
                        let no_name = cell[l+1]
                        let remove = false;
                        if (!state.objectMasks.hasOwnProperty(no_name)){
                            continue;//error, should have been caught earlier - e.g. You cannot use 'no' to exclude the aggregate objec
                        }
                        let no_object_mask = state.objectMasks[no_name];
                        let no_object_layer_mask = new BitVec(Math.ceil(LAYER_COUNT/32)|0);                        
                        for (let m=0;m<state.layerMasks.length;m++){
                            if (state.layerMasks[m].anyBitsInCommon(no_object_mask)){
                                no_object_layer_mask.ibitset(m);
                            }
                        }                        

                        const object_layers_disjoint = !no_object_mask.anyBitsInCommon(required_objects);
                        const no_object_covered_by_required_layers = no_object_layer_mask.bitsSetInArray(required_layers.data);      

                        if (no_object_covered_by_required_layers && object_layers_disjoint){

                            const obs_present = [];
                            const layers_present = [];
                            for (let m=0;m<state.layerMasks.length;m++){
                                if (occupier[m]){
                                    obs_present.push(occupier[m]);
                                    layers_present.push(m);
                                }
                            }
                            logWarning(`You have specified that there should be NO ${no_name.toUpperCase()} but there is also a requirement that ${obs_present.join(", ").toUpperCase()} be there, which collectively occupies the same layers (Layers ${layers_present.map(l=>l+1).join(", ")}), so you can leave this out.`, rule.lineNumber);
                            cell.splice(l,2);
                            l-=2;
                        }
                    }
                }                
            }
        }
    }


}

function rulesToArray(state) {
    let oldrules = state.rules;
    let rules = [];
    let loops = [];
    for (let i = 0; i < oldrules.length; i++) {
        let lineNumber = oldrules[i][1];
        let newrule = processRuleString(oldrules[i], state, rules);
        if (newrule === null) {
            continue;//error in processing string.
        }
        if (newrule.bracket !== undefined) {
            loops.push([lineNumber, newrule.bracket]);
            continue;
        }
        rules.push(newrule);
    }
    state.loops = loops;

    checkSuperfluousCoincidences(state,rules);

    //now expand out rules with multiple directions
    let rules2 = [];
    for (let i = 0; i < rules.length; i++) {
        let rule = rules[i];
        let ruledirs = rule.directions;
        for (let j = 0; j < ruledirs.length; j++) {
            let dir = ruledirs[j];
            // The following block is never getting hit by any tests. 
            // Presumably in the past it was used to expand out rules with
            // multiple directions, but now that's done somewhere else.
            if (dir in directionaggregates && directionalRule(rule)) {
                let dirs = directionaggregates[dir];
                for (let k = 0; k < dirs.length; k++) {
                    let modifiedrule = deepCloneRule(rule);
                    modifiedrule.direction = dirs[k];
                    rules2.push(modifiedrule);
                }
            } else {
                let modifiedrule = deepCloneRule(rule);
                modifiedrule.direction = dir;
                rules2.push(modifiedrule);
            }
        }
    }

    for (let i = 0; i < rules2.length; i++) {
        let rule = rules2[i];
        //remove relative directions
        convertRelativeDirsToAbsolute(rule);
        //optional: replace up/left rules with their down/right equivalents
        rewriteUpLeftRules(rule);
        //replace aggregates with what they mean
        atomizeAggregates(state, rule);

        if (state.invalid) {
            return;
        }

        //replace synonyms with what they mean
        rephraseSynonyms(state, rule);
    }

    let rules3 = [];
    //expand property rules
    for (let i = 0; i < rules2.length; i++) {
        let rule = rules2[i];
        rules3 = rules3.concat(concretizeMovingRule(state, rule, rule.lineNumber));
    }

    let rules4 = [];
    for (let i = 0; i < rules3.length; i++) {
        let rule = rules3[i];
        rules4 = rules4.concat(concretizePropertyRule(state, rule, rule.lineNumber));

    }

    for (let i = 0; i < rules4.length; i++) {
        let rule = rules4[i];
        makeSpawnedObjectsStationary(state, rule, rule.lineNumber);
    }
    state.rules = rules4;
}

function containsEllipsis(rule) {
    for (let i = 0; i < rule.lhs.length; i++) {
        for (let j = 0; j < rule.lhs[i].length; j++) {
            if (rule.lhs[i][j][1] === '...')
                return true;
        }
    }
    return false;
}

function rewriteUpLeftRules(rule) {
    if (containsEllipsis(rule)) {
        return;
    }

    if (rule.direction === 'up') {
        rule.direction = 'down';
    } else if (rule.direction === 'left') {
        rule.direction = 'right';
    } else {
        return;
    }

    for (let i = 0; i < rule.lhs.length; i++) {
        rule.lhs[i].reverse();
        if (rule.rhs.length > 0) {
            rule.rhs[i].reverse();
        }
    }
}

//expands all properties to list of all things it could be, filterio
function getPossibleObjectsFromCell(state, cell) {
    const result = [];
    for (let j = 0; j < cell.length; j += 2) {
        const dir = cell[j];
        const name = cell[j + 1];
        if (name in state.objects) {
            result.push(name);
        }
        else if (name in state.propertiesDict) {
            const aliases = state.propertiesDict[name];
            for (let k = 0; k < aliases.length; k++) {
                const alias = aliases[k];
                result.push(alias);
            }
        }
    }
    return result;
}

function getPropertiesFromCell(state, cell) {
    let result = [];
    for (let j = 0; j < cell.length; j += 2) {
        let dir = cell[j];
        let name = cell[j + 1];
        if (dir === "random") {
            continue;
        }
        if (name in state.propertiesDict) {
            result.push(name);
        }
    }
    return result;
}

//returns you a list of object names in that cell that're moving
function getMovings(state, cell) {
    let result = [];
    for (let j = 0; j < cell.length; j += 2) {
        let dir = cell[j];
        let name = cell[j + 1];
        if (dir in directionaggregates) {
            result.push([name, dir]);
        }
    }
    return result;
}

function concretizePropertyInCell(cell, property, concreteType) {
    for (let j = 0; j < cell.length; j += 2) {
        if (cell[j + 1] === property && cell[j] !== "random") {
            cell[j + 1] = concreteType;
        }
    }
}

function concretizeMovingInCell(cell, ambiguousMovement, nameToMove, concreteDirection) {
    for (let j = 0; j < cell.length; j += 2) {
        if (cell[j] === ambiguousMovement && cell[j + 1] === nameToMove) {
            cell[j] = concreteDirection;
        }
    }
}

function concretizeMovingInCellByAmbiguousMovementName(cell, ambiguousMovement, concreteDirection) {
    for (let j = 0; j < cell.length; j += 2) {
        if (cell[j] === ambiguousMovement) {
            cell[j] = concreteDirection;
        }
    }
}

function expandNoPrefixedProperties(state, cell) {
    let expanded = [];
    for (let i = 0; i < cell.length; i += 2) {
        let dir = cell[i];
        let name = cell[i + 1];

        if (dir === 'no' && (name in state.propertiesDict)) {
            let aliases = state.propertiesDict[name];
            for (let j = 0; j < aliases.length; j++) {
                let alias = aliases[j];
                expanded.push(dir);
                expanded.push(alias);
            }
        } else {
            expanded.push(dir);
            expanded.push(name);
        }
    }
    return expanded;
}

function concretizePropertyRule(state, rule, lineNumber) {

    //step 1, rephrase rule to change "no flying" to "no cat no bat"
    for (let i = 0; i < rule.lhs.length; i++) {
        let cur_cellrow_l = rule.lhs[i];
        for (let j = 0; j < cur_cellrow_l.length; j++) {
            cur_cellrow_l[j] = expandNoPrefixedProperties(state, cur_cellrow_l[j]);
            if (rule.rhs.length > 0)
                rule.rhs[i][j] = expandNoPrefixedProperties(state, rule.rhs[i][j]);
        }
    }

    //are there any properties we could avoid processing?
    // e.g. [> player | movable] -> [> player | > movable],
    // 		doesn't need to be split up (assuming single-layer player/block aggregates)

    // we can't manage this if they're being used to disambiguate
    let ambiguousProperties = {};

    for (let j = 0; j < rule.rhs.length; j++) {
        let row_l = rule.lhs[j];
        let row_r = rule.rhs[j];
        for (let k = 0; k < row_r.length; k++) {
            let properties_l = getPropertiesFromCell(state, row_l[k]);
            let properties_r = getPropertiesFromCell(state, row_r[k]);
            for (let prop_n = 0; prop_n < properties_r.length; prop_n++) {
                let property = properties_r[prop_n];
                if (properties_l.indexOf(property) === -1) {
                    ambiguousProperties[property] = true;
                }
            }
        }
    }

    let shouldremove;
    let result = [rule];
    let modified = true;
    while (modified) {
        modified = false;
        for (let i = 0; i < result.length; i++) {
            //only need to iterate through lhs
            let cur_rule = result[i];
            shouldremove = false;
            for (let j = 0; j < cur_rule.lhs.length && !shouldremove; j++) {
                let cur_rulerow = cur_rule.lhs[j];
                for (let k = 0; k < cur_rulerow.length && !shouldremove; k++) {
                    let cur_cell = cur_rulerow[k];
                    let properties = getPropertiesFromCell(state, cur_cell);
                    for (let prop_n = 0; prop_n < properties.length; ++prop_n) {
                        let property = properties[prop_n];

                        if (state.propertiesSingleLayer.hasOwnProperty(property) &&
                            ambiguousProperties[property] !== true) {
                            // we don't need to explode this property
                            continue;
                        }

                        let aliases = state.propertiesDict[property];

                        shouldremove = true;
                        modified = true;

                        //just do the base property, let future iterations take care of the others

                        for (let l = 0; l < aliases.length; l++) {
                            let concreteType = aliases[l];
                            let newrule = deepCloneRule(cur_rule);
                            newrule.propertyReplacement = {};
                            if (cur_rule.propertyReplacement){
                                const cur_rule_propertyReplacement_keys = Object.keys(cur_rule.propertyReplacement);
                                const cur_rule_propertyReplacement_keys_l = cur_rule_propertyReplacement_keys.length;
                                for (let k_i = 0; k_i < cur_rule_propertyReplacement_keys_l; k_i++) {
                                    const prop = cur_rule_propertyReplacement_keys[k_i];
                                    const propDat = cur_rule.propertyReplacement[prop];
                                    newrule.propertyReplacement[prop] = [propDat[0], propDat[1]];                                
                                }
                            }

                            concretizePropertyInCell(newrule.lhs[j][k], property, concreteType);
                            if (newrule.rhs.length > 0) {
                                concretizePropertyInCell(newrule.rhs[j][k], property, concreteType); //do for the corresponding rhs cell as well
                            }

                            if (newrule.propertyReplacement[property] === undefined) {
                                newrule.propertyReplacement[property] = [concreteType, 1];
                            } else {
                                newrule.propertyReplacement[property][1] = newrule.propertyReplacement[property][1] + 1;
                            }

                            result.push(newrule);
                        }

                        break;
                    }
                }
            }
            if (shouldremove) {
                result.splice(i, 1);
                i--;
            }
        }
    }


    for (let i = 0; i < result.length; i++) {
        //for each rule
        let cur_rule = result[i];
        if (cur_rule.propertyReplacement === undefined) {
            continue;
        }

        //for each property replacement in that rule
        for (let property of Object.keys(cur_rule.propertyReplacement)) {
            let replacementInfo = cur_rule.propertyReplacement[property];
            let concreteType = replacementInfo[0];
            let occurrenceCount = replacementInfo[1];
            if (occurrenceCount === 1) {
                //do the replacement
                for (let j = 0; j < cur_rule.rhs.length; j++) {
                    let cellRow_rhs = cur_rule.rhs[j];
                    for (let k = 0; k < cellRow_rhs.length; k++) {
                        let cell = cellRow_rhs[k];
                        concretizePropertyInCell(cell, property, concreteType);
                    }
                }
            }
        }
    }

    //if any properties remain on the RHSes, bleep loudly
    let rhsPropertyRemains = '';
    for (let i = 0; i < result.length; i++) {
        let cur_rule = result[i];
        delete cur_rule.propertyReplacement;
        for (let j = 0; j < cur_rule.rhs.length; j++) {
            let cur_rulerow = cur_rule.rhs[j];
            for (let k = 0; k < cur_rulerow.length; k++) {
                let cur_cell = cur_rulerow[k];
                let properties = getPropertiesFromCell(state, cur_cell);
                for (let prop_n = 0; prop_n < properties.length; prop_n++) {
                    if (ambiguousProperties.hasOwnProperty(properties[prop_n])) {
                        rhsPropertyRemains = properties[prop_n];
                    }
                }
            }
        }
    }


    if (rhsPropertyRemains.length > 0) {
        logError('This rule has a property on the right-hand side, "' + rhsPropertyRemains.toUpperCase() + "\", that can't be inferred from the left-hand side.  (either for every property on the right there has to be a corresponding one on the left in the same cell, OR, if there's a single occurrence of a particular property name on the left, all properties of the same name on the right are assumed to be the same).", lineNumber);
        return [];
    }

    return result;
}

function makeSpawnedObjectsStationary(state, rule, lineNumber) {
    //movement not getting correctly cleared from tile #492
    //[ > Player | ] -> [ Crate | Player ] if there was a player already in the second cell, it's not replaced with a stationary player.
    //if there are properties remaining by this stage, just ignore them ( c.f. "[ >  Moveable | Moveable ] -> [ > Moveable | > Moveable ]" in block faker, what's left in this form) - this only happens IIRC when the properties span a single layer so it's)
    //if am object without moving-annotations appears on the RHS, and that object is not present on the lhs (either explicitly as an object, or implicitly in a property), add a 'stationary'
    if (rule.late) {
        return;
    }

    for (let j = 0; j < rule.rhs.length; j++) {
        let row_l = rule.lhs[j];
        let row_r = rule.rhs[j];
        for (let k = 0; k < row_r.length; k++) {
            let cell = row_r[k];

            //this is super intricate. uff. 
            let objects_l = getPossibleObjectsFromCell(state, row_l[k]);
            let layers = objects_l.map(n => state.objects[n].layer);
            for (let l = 0; l < cell.length; l += 2) {
                let dir = cell[l];
                if (dir !== "") {
                    continue;
                }
                let name = cell[l + 1];
                if (name in state.propertiesDict || objects_l.indexOf(name) >= 0) {
                    continue;
                }
                let r_layer = state.objects[name].layer;
                if (layers.indexOf(r_layer) === -1) {
                    cell[l] = 'stationary';
                }
            }
        }
    }

}

function concretizeMovingRule(state, rule, lineNumber) {

    let shouldremove;
    let result = [rule];
    let modified = true;
    while (modified) {
        modified = false;
        for (let i = 0; i < result.length; i++) {
            //only need to iterate through lhs
            let cur_rule = result[i];
            shouldremove = false;
            for (let j = 0; j < cur_rule.lhs.length; j++) {
                let cur_rulerow = cur_rule.lhs[j];
                for (let k = 0; k < cur_rulerow.length; k++) {
                    let cur_cell = cur_rulerow[k];
                    let movings = getMovings(state, cur_cell); //finds aggregate directions
                    if (movings.length > 0) {
                        shouldremove = true;
                        modified = true;

                        //just do the base property, let future iterations take care of the others
                        let cand_name = movings[0][0];
                        let ambiguous_dir = movings[0][1];
                        let concreteDirs = directionaggregates[ambiguous_dir];
                        for (let l = 0; l < concreteDirs.length; l++) {
                            let concreteDirection = concreteDirs[l];
                            let newrule = deepCloneRule(cur_rule);

                            //deep copy replacements
                            newrule.movingReplacement = {};

                            if(cur_rule.movingReplacement){
                                const cur_rule_movingReplacement_keys = Object.keys(cur_rule.movingReplacement);
                                const cur_rule_movingReplacement_keys_l = cur_rule_movingReplacement_keys.length;
                                for (let k_i = 0; k_i < cur_rule_movingReplacement_keys_l; k_i++) {
                                    const moveTerm = cur_rule_movingReplacement_keys[k_i];
                                    let moveDat = cur_rule.movingReplacement[moveTerm];
                                    newrule.movingReplacement[moveTerm] = [moveDat[0], moveDat[1], moveDat[2], moveDat[3], moveDat[4], moveDat[5]];                            
                                }
                            }

                            newrule.aggregateDirReplacement = {};
                            if (cur_rule.aggregateDirReplacement){
                                const cur_rule_aggregateDirReplacement_keys = Object.keys(cur_rule.aggregateDirReplacement);
                                const cur_rule_aggregateDirReplacement_keys_l = cur_rule_aggregateDirReplacement_keys.length;
                                for (let k_i = 0; k_i < cur_rule_aggregateDirReplacement_keys_l; k_i++) {
                                    const moveTerm = cur_rule_aggregateDirReplacement_keys[k_i];
                                    let moveDat = cur_rule.aggregateDirReplacement[moveTerm];
                                    newrule.aggregateDirReplacement[moveTerm] = [moveDat[0], moveDat[1], moveDat[2]];                            
                                }
                            }

                            concretizeMovingInCell(newrule.lhs[j][k], ambiguous_dir, cand_name, concreteDirection);
                            if (newrule.rhs.length > 0) {
                                concretizeMovingInCell(newrule.rhs[j][k], ambiguous_dir, cand_name, concreteDirection); //do for the corresponding rhs cell as well
                            }

                            if (newrule.movingReplacement[cand_name + ambiguous_dir] === undefined) {
                                newrule.movingReplacement[cand_name + ambiguous_dir] = [concreteDirection, 1, ambiguous_dir, cand_name, j, k];
                            } else {
                                let mr = newrule.movingReplacement[cand_name + ambiguous_dir];
                                if (j !== mr[4] || k !== mr[5]) {
                                    mr[1] = mr[1] + 1;
                                }
                            }
                            if (newrule.aggregateDirReplacement[ambiguous_dir] === undefined) {
                                newrule.aggregateDirReplacement[ambiguous_dir] = [concreteDirection, 1, ambiguous_dir];
                            } else {
                                newrule.aggregateDirReplacement[ambiguous_dir][1] = newrule.aggregateDirReplacement[ambiguous_dir][1] + 1;
                            }

                            result.push(newrule);
                        }
                    }
                }
            }
            if (shouldremove) {
                result.splice(i, 1);
                i--;
            }
        }
    }


    for (let i = 0; i < result.length; i++) {
        //for each rule
        let cur_rule = result[i];
        if (cur_rule.movingReplacement === undefined) {
            continue;
        }
        let ambiguous_movement_dict = {};
        //strict first - matches movement direction to objects
        //for each property replacement in that rule

        const cur_rule_movingReplacement_keys = Object.keys(cur_rule.movingReplacement);
        if (cur_rule.movingReplacement){
            const cur_rule_movingReplacement_keys_l = cur_rule_movingReplacement_keys.length;
            for (let k_i = 0; k_i < cur_rule_movingReplacement_keys_l; k_i++) {
                const moveTerm = cur_rule_movingReplacement_keys[k_i];
                let replacementInfo = cur_rule.movingReplacement[moveTerm];
                let concreteMovement = replacementInfo[0];
                let occurrenceCount = replacementInfo[1];
                let ambiguousMovement = replacementInfo[2];
                let ambiguousMovement_attachedObject = replacementInfo[3];

                if (occurrenceCount === 1) {
                    //do the replacement
                    for (let j = 0; j < cur_rule.rhs.length; j++) {
                        let cellRow_rhs = cur_rule.rhs[j];
                        for (let k = 0; k < cellRow_rhs.length; k++) {
                            let cell = cellRow_rhs[k];
                            concretizeMovingInCell(cell, ambiguousMovement, ambiguousMovement_attachedObject, concreteMovement);
                        }
                    }
                }        
            }
        }

        //I don't fully understand why the following part is needed (and I wrote this yesterday), but it's not obviously malicious.
        let ambiguous_movement_names_dict = {};

        const cur_rule_aggregateDirReplacement_keys = Object.keys(cur_rule.aggregateDirReplacement);
        const cur_rule_aggregateDirReplacement_keys_l = cur_rule_aggregateDirReplacement_keys.length;
        for (let k_i = 0; k_i < cur_rule_aggregateDirReplacement_keys_l; k_i++) {
            const moveTerm = cur_rule_aggregateDirReplacement_keys[k_i];
            let replacementInfo = cur_rule.aggregateDirReplacement[moveTerm];
            let concreteMovement = replacementInfo[0];
            let occurrenceCount = replacementInfo[1];
            let ambiguousMovement = replacementInfo[2];
            //are both the following boolean bits necessary, or just the latter? ah well, no harm it seems.
            if ((ambiguousMovement in ambiguous_movement_names_dict) || (occurrenceCount !== 1)) {
                ambiguous_movement_names_dict[ambiguousMovement] = "INVALID";
            } else {
                ambiguous_movement_names_dict[ambiguousMovement] = concreteMovement
            }        
        }

        const ambiguous_movement_dict_keys = Object.keys(ambiguous_movement_dict);
        const ambiguous_movement_dict_keys_l = ambiguous_movement_dict_keys.length;
        for (let k_i = 0; k_i < ambiguous_movement_dict_keys_l; k_i++) {
            const ambiguousMovement = ambiguous_movement_dict_keys[k_i];
        //for each ambiguous word, if there's a single ambiguous movement specified in the whole lhs, then replace that wholesale
            if (ambiguousMovement !== "INVALID") {
                concreteMovement = ambiguous_movement_dict[ambiguousMovement];
                if (concreteMovement === "INVALID") {
                    continue;
                }
                for (let j = 0; j < cur_rule.rhs.length; j++) {
                    let cellRow_rhs = cur_rule.rhs[j];
                    for (let k = 0; k < cellRow_rhs.length; k++) {
                        let cell = cellRow_rhs[k];
                        concretizeMovingInCellByAmbiguousMovementName(cell, ambiguousMovement, concreteMovement);
                    }
                }
            }
        }

        const ambiguous_movement_names_dict_keys = Object.keys(ambiguous_movement_names_dict);
        const ambiguous_movement_names_dict_keys_l = ambiguous_movement_names_dict_keys.length;
        for (let k_i = 0; k_i < ambiguous_movement_names_dict_keys_l; k_i++) {
            const ambiguousMovement = ambiguous_movement_names_dict_keys[k_i];
            //further replacements - if a movement word appears once on the left, can use to disambiguate remaining ones on the right
            if (ambiguousMovement !== "INVALID") {
                let concreteMovement = ambiguous_movement_names_dict[ambiguousMovement];
                if (concreteMovement === "INVALID") {
                    continue;
                }
                for (let j = 0; j < cur_rule.rhs.length; j++) {
                    let cellRow_rhs = cur_rule.rhs[j];
                    for (let k = 0; k < cellRow_rhs.length; k++) {
                        let cell = cellRow_rhs[k];
                        concretizeMovingInCellByAmbiguousMovementName(cell, ambiguousMovement, concreteMovement);
                    }
                }
            }
        }
    }

    //if any properties remain on the RHSes, bleep loudly
    let rhsAmbiguousMovementsRemain = '';
    
    outerloop: for (const currentRule of result) {
        delete currentRule.movingReplacement;        
        for (const ruleRow of currentRule.rhs) {
            for (const cell of ruleRow) {
                const movings = getMovings(state, cell);
                if (movings.length > 0) {
                    rhsAmbiguousMovementsRemain = movings[0][1];
                    break outerloop;
                }
            }
        }
    }


    if (rhsAmbiguousMovementsRemain.length > 0) {
        logError('This rule has an ambiguous movement on the right-hand side, "' + rhsAmbiguousMovementsRemain + "\", that can't be inferred from the left-hand side.  (either for every ambiguous movement associated to an entity on the right there has to be a corresponding one on the left attached to the same entity, OR, if there's a single occurrence of a particular ambiguous movement on the left, all properties of the same movement attached to the same object on the right are assumed to be the same (or something like that)).", lineNumber);
        state.invalid = true;
    }

    return result;
}

function rephraseSynonyms(state, rule) {
    const processCell = (cell) => {
        for (let i = 1; i < cell.length; i += 2) {
            const name = cell[i];
            if (name in state.synonymsDict) {
                cell[i] = state.synonymsDict[name];
            }
        }
    };

    for (let i = 0; i < rule.lhs.length; i++) {
        const cellrow_l = rule.lhs[i];
        const cellrow_r = rule.rhs[i];
        
        for (let j = 0; j < cellrow_l.length; j++) {
            processCell(cellrow_l[j]);
            if (rule.rhs.length > 0) {
                processCell(cellrow_r[j]);
            }
        }
    }
}

function atomizeAggregates(state, rule) {
    const processCellRow = (cellrow) => {
        for (let j = 0; j < cellrow.length; j++) {
            atomizeCellAggregates(state, cellrow[j], rule.lineNumber);
        }
    };

    for (let i = 0; i < rule.lhs.length; i++) {
        processCellRow(rule.lhs[i]);
    }
    for (let i = 0; i < rule.rhs.length; i++) {
        processCellRow(rule.rhs[i]);
    }
}

function atomizeCellAggregates(state, cell, lineNumber) {
    for (let i = 0; i < cell.length; i += 2) {
        const dir = cell[i];
        const name = cell[i + 1];
        if (name in state.aggregatesDict) {
            if (dir === 'no') {
                logError("You cannot use 'no' to exclude the aggregate object " + name.toUpperCase() + " (defined using 'AND'), only regular objects, or properties (objects defined using 'OR').  If you want to do this, you'll have to write it out yourself the long way.", lineNumber);
            }
            const equivs = state.aggregatesDict[name];
            cell[i + 1] = equivs[0];
            for (let j = 1; j < equivs.length; j++) {
                cell.push(dir); //push the direction
                cell.push(equivs[j]);
            }
        }
    }
}

function convertRelativeDirsToAbsolute(rule) {
    const forward = rule.direction;
    for (let i = 0; i < rule.lhs.length; i++) {
        const cellrow = rule.lhs[i];
        for (let j = 0; j < cellrow.length; j++) {
            const cell = cellrow[j];
            absolutifyRuleCell(forward, cell);
        }
    }
    for (let i = 0; i < rule.rhs.length; i++) {
        const cellrow = rule.rhs[i];
        for (let j = 0; j < cellrow.length; j++) {
            const cell = cellrow[j];
            absolutifyRuleCell(forward, cell);
        }
    }
}

const relativeDirs = ['^', 'v', '<', '>', 'parallel', 'perpendicular']; //used to index the following
//I use _par/_perp just to keep track of providence for replacement purposes later.
const relativeDict = {
    'right': ['up', 'down', 'left', 'right', 'horizontal_par', 'vertical_perp'],
    'up': ['left', 'right', 'down', 'up', 'vertical_par', 'horizontal_perp'],
    'down': ['right', 'left', 'up', 'down', 'vertical_par', 'horizontal_perp'],
    'left': ['down', 'up', 'right', 'left', 'horizontal_par', 'vertical_perp']
};

function absolutifyRuleCell(forward, cell) {
    for (let i = 0; i < cell.length; i += 2) {
        const c = cell[i];
        const index = relativeDirs.indexOf(c);
        if (index >= 0) {
            cell[i] = relativeDict[forward][index];
        }
    }
}
/*
    direction mask
    UP parseInt('%1', 2);
    DOWN parseInt('0', 2);
    LEFT parseInt('0', 2);
    RIGHT parseInt('0', 2);
    ?  parseInt('', 2);

*/

const dirMasks = {
    'up': parseInt('00001', 2),
    'down': parseInt('00010', 2),
    'left': parseInt('00100', 2),
    'right': parseInt('01000', 2),
    'moving': parseInt('01111', 2),
    'no': parseInt('00011', 2),
    'randomdir': parseInt('00101', 2),
    'random': parseInt('10010', 2),
    'action': parseInt('10000', 2),
    '': parseInt('00000', 2)
};

function getOverlapObjectNames(state, objects1,objects2){
    //given two bitvecs, return an array of object names that are present in both
    let result=[];
    for (let i=0;i<state.objectCount;i++){
        if (objects1.get(i) && objects2.get(i)){
            result.push(state.idDict[i]);
        }
    }
    return result;
}

function rulesToMask(state) {
    const layerCount = state.collisionLayers.length;
    const layerTemplate = Array(layerCount).fill(null);
    const STRIDE_5 = 5; // Magic number for bit shifting

    outerloop: for (let ruleIndex = 0; ruleIndex < state.rules.length; ruleIndex++) {
        const rule = state.rules[ruleIndex];
        
        for (let rowIndex = 0; rowIndex < rule.lhs.length; rowIndex++) {
            const [cellrow_l, cellrow_r] = [rule.lhs[rowIndex], rule.rhs[rowIndex]];
            
            for (let colIndex = 0; colIndex < cellrow_l.length; colIndex++) {
                const cell_l = cellrow_l[colIndex];
                const layersUsed_l = [...layerTemplate];
                
                // Initialize bit vectors for the current cell
                const bitVectors = {
                    objectsPresent: new BitVec(STRIDE_OBJ),
                    objectsMissing: new BitVec(STRIDE_OBJ),
                    movementsPresent: new BitVec(STRIDE_MOV),
                    movementsMissing: new BitVec(STRIDE_MOV),
                    objectlayers_l: new BitVec(STRIDE_MOV)
                };
                
                const anyObjectsPresent = [];

                // Process left-hand side cell
                for (let i = 0; i < cell_l.length; i += 2) {
                    const [object_dir, object_name] = [cell_l[i], cell_l[i + 1]];
                    
                    // Handle special cases
                    if (object_dir === '...') {
                        if (cell_l.length !== 2) {
                            logError("You can't have anything in with an ellipsis. Sorry.", rule.lineNumber);
                            state.rules.splice(ruleIndex, 1);
                            ruleIndex--;
                            continue outerloop;
                        }
                        if (colIndex === 0 || colIndex === cellrow_l.length - 1) {
                            logError("There's no point in putting an ellipsis at the very start or the end of a rule", rule.lineNumber);
                        }
                        if (rule.rhs.length > 0) {
                            const rhscell = cellrow_r[colIndex];
                            if (rhscell.length !== 2 || rhscell[0] !== '...') {
                                logError("An ellipsis on the left must be matched by one in the corresponding place on the right.", rule.lineNumber);
                            }
                        }
                        bitVectors.objectsPresent = ellipsisPattern;
                        break;
                    }
                    
                    if (object_dir === 'random') {
                        logError("RANDOM cannot be matched on the left-hand side, it can only appear on the right", rule.lineNumber);
                        continue;
                    }

                    // Process regular object
                    const object = state.objects[object_name];
                    const objectMask = state.objectMasks[object_name];
                    const layerIndex = object ? (object.layer | 0) : state.propertiesSingleLayer[object_name];

                    if (typeof layerIndex === "undefined") {
                        logError(`Oops! ${object_name.toUpperCase()} not assigned to a layer.`, rule.lineNumber);
                    }

                    if (object_dir === 'no') {
                        bitVectors.objectsMissing.ior(objectMask);
                    } else {
                        const existingname = layersUsed_l[layerIndex];
                        if (existingname !== null) {
                            rule.discard = [object_name.toUpperCase(), existingname.toUpperCase()];
                        }

                        layersUsed_l[layerIndex] = object_name;

                        if (object) {
                            bitVectors.objectsPresent.ior(objectMask);
                            bitVectors.objectlayers_l.ishiftor(0x1f, STRIDE_5 * layerIndex);
                        } else {
                            anyObjectsPresent.push(objectMask);
                        }

                        const movementMask = object_dir === 'stationary' ? 
                            bitVectors.movementsMissing : bitVectors.movementsPresent;
                        movementMask.ishiftor(object_dir === 'stationary' ? 0x1f : dirMasks[object_dir], 
                                           STRIDE_5 * layerIndex);
                    }
                }

                // Handle ellipsis pattern
                if (bitVectors.objectsPresent === ellipsisPattern) {
                    cellrow_l[colIndex] = ellipsisPattern;
                    continue;
                }

                // Create cell pattern
                cellrow_l[colIndex] = new CellPattern([
                    bitVectors.objectsPresent,
                    bitVectors.objectsMissing,
                    anyObjectsPresent,
                    bitVectors.movementsPresent,
                    bitVectors.movementsMissing,
                    null
                ]);

                // Check for invalid patterns
                if (!bitVectors.objectsPresent.iszero()) {
                    if (bitVectors.objectsPresent.anyBitsInCommon(bitVectors.objectsMissing)) {
                        const ln = rule.lineNumber;

                        const overlap = getOverlapObjectNames(state, bitVectors.objectsPresent, bitVectors.objectsMissing);
                        var x_no_x_list = overlap.map(x => x+" NO "+x).join(', ').toUpperCase();
                        logWarning(`This rule has something amounting to "${x_no_x_list}" on the left-hand-side,which can never match, so the rule is getting removed during compilation.`, rule.lineNumber);

                        state.rules.splice(ruleIndex, 1);
                        ruleIndex--;
                        continue;
                    }
                }

                if (rule.rhs.length === 0) continue;
                const cell_r = cellrow_r[colIndex];

                // Check for mismatched ellipsis
                if (cell_r[0] === '...' && cell_l[0] !== '...') {
                    logError("An ellipsis on the right must be matched by one in the corresponding place on the left.", rule.lineNumber);
                }
                
                // Validate ellipsis in right-hand side
                for (let i = 0; i < cell_r.length; i += 2) {
                    if (cell_r[i] === '...' && cell_r.length !== 2) {
                        logError("You can't have anything in with an ellipsis. Sorry.", rule.lineNumber);
                    }
                }

                const layersUsed_r = [...layerTemplate];
                const layersUsedRand_r = [...layerTemplate];

                const rhsBitVectors = {
                    objectsClear: new BitVec(STRIDE_OBJ),
                    objectsSet: new BitVec(STRIDE_OBJ),
                    movementsClear: new BitVec(STRIDE_MOV),
                    movementsSet: new BitVec(STRIDE_MOV),
                    objectlayers_r: new BitVec(STRIDE_MOV),
                    randomMask_r: new BitVec(STRIDE_OBJ),
                    postMovementsLayerMask_r: new BitVec(STRIDE_MOV),
                    randomDirMask_r: new BitVec(STRIDE_MOV)
                };


                // Process right-hand side cell
                for (let i = 0; i < cell_r.length; i += 2) {
                    const [object_dir, object_name] = [cell_r[i], cell_r[i + 1]];

                    if (object_dir === '...') break;
                    
                    if (object_dir === 'random') {
                        if (object_name in state.objectMasks) {
                            const mask = state.objectMasks[object_name];
                            rhsBitVectors.randomMask_r.ior(mask);
                            
                            const values = state.propertiesDict.hasOwnProperty(object_name) ? 
                                state.propertiesDict[object_name] : [object_name];
                            
                            if (values.length === 1) {
                                logWarning(`In this rule you're asking me to spawn a random ${object_name.toUpperCase()} for you, but that's already a concrete single object. You wanna be using random with properties (things defined in terms of OR in the legend) so there's some things to select between.`, rule.lineNumber);
                            }

                            for (const subobject of values) {
                                const layerIndex = state.objects[subobject].layer | 0;
                                const existingname = layersUsed_r[layerIndex];
                                
                                if (existingname !== null) {
                                    const [o1, o2] = [subobject.toUpperCase(), existingname.toUpperCase()];
                                    if (o1 !== o2) {
                                        logWarning(`This rule may try to spawn a ${o1} with random, but also requires a ${o2} be here, which is on the same layer - they shouldn't be able to coexist!`, rule.lineNumber);
                                    }
                                }
                                layersUsedRand_r[layerIndex] = subobject;
                            }
                        } else {
                            logError(`You want to spawn a random "${object_name.toUpperCase()}", but I don't know how to do that`, rule.lineNumber);
                        }
                        continue;
                    }

                    const object = state.objects[object_name];
                    const objectMask = state.objectMasks[object_name];
                    const layerIndex = object ? (object.layer | 0) : state.propertiesSingleLayer[object_name];

                    if (object_dir === 'no') {
                        rhsBitVectors.objectsClear.ior(objectMask);
                    } else {
                        const existingname = layersUsed_r[layerIndex] || layersUsedRand_r[layerIndex];
                        if (existingname !== null && !rule.hasOwnProperty('discard')) {
                            logError(`Rule matches object types that can't overlap: "${object_name.toUpperCase()}" and "${existingname.toUpperCase()}".`, rule.lineNumber);
                        }

                        layersUsed_r[layerIndex] = object_name;

                        if (object_dir.length > 0) {
                            rhsBitVectors.postMovementsLayerMask_r.ishiftor(0x1f, STRIDE_5 * layerIndex);
                        }

                        const layerMask = state.layerMasks[layerIndex];

                        if (object) {
                            rhsBitVectors.objectsSet.ibitset(object.id);
                            rhsBitVectors.objectsClear.ior(layerMask);
                            rhsBitVectors.objectlayers_r.ishiftor(0x1f, STRIDE_5 * layerIndex);
                        }

                        if (object_dir === 'stationary') {
                            rhsBitVectors.movementsClear.ishiftor(0x1f, STRIDE_5 * layerIndex);
                        } else if (object_dir === 'randomdir') {
                            rhsBitVectors.randomDirMask_r.ishiftor(dirMasks[object_dir], STRIDE_5 * layerIndex);
                        } else {
                            rhsBitVectors.movementsSet.ishiftor(dirMasks[object_dir], STRIDE_5 * layerIndex);
                        }
                    }
                }
        
                // Clear old objects and movements if needed
                if (!bitVectors.objectsPresent.bitsSetInArray(rhsBitVectors.objectsSet.data)) {
                    rhsBitVectors.objectsClear.ior(bitVectors.objectsPresent);
                }
                if (!bitVectors.movementsPresent.bitsSetInArray(rhsBitVectors.movementsSet.data)) {
                    rhsBitVectors.movementsClear.ior(bitVectors.movementsPresent);
                }

                // Handle layer-specific clearing
                for (let layerIndex = 0; layerIndex < layerCount; layerIndex++) {
                    if (layersUsed_l[layerIndex] !== null && layersUsed_r[layerIndex] === null) {
                        rhsBitVectors.objectsClear.ior(state.layerMasks[layerIndex]);
                        rhsBitVectors.postMovementsLayerMask_r.ishiftor(0x1f, STRIDE_5 * layerIndex);
                    }
                }

                bitVectors.objectlayers_l.iclear(rhsBitVectors.objectlayers_r);
                rhsBitVectors.postMovementsLayerMask_r.ior(bitVectors.objectlayers_l);

                // Set replacement if any changes would occur
                const hasChanges = !rhsBitVectors.objectsClear.iszero() || 
                                 !rhsBitVectors.objectsSet.iszero() || 
                                 !rhsBitVectors.movementsClear.iszero() || 
                                 !rhsBitVectors.movementsSet.iszero() || 
                                 !rhsBitVectors.postMovementsLayerMask_r.iszero() || 
                                 !rhsBitVectors.randomMask_r.iszero() || 
                                 !rhsBitVectors.randomDirMask_r.iszero();

                if (hasChanges) {
                    const target_cell_pattern = cellrow_l[colIndex];
                    target_cell_pattern.replacement = new CellReplacement([
                        rhsBitVectors.objectsClear,
                        rhsBitVectors.objectsSet,
                        rhsBitVectors.movementsClear,
                        rhsBitVectors.movementsSet,
                        rhsBitVectors.postMovementsLayerMask_r,
                        rhsBitVectors.randomMask_r,
                        rhsBitVectors.randomDirMask_r
                    ]);
                }
            }
        }
    }
}

function cellRowMasks(rule) {
    const ruleMasks = [];
    const lhs = rule[1];
    for (let i = 0; i < lhs.length; i++) {
        const cellRow = lhs[i];
        const rowMask = new BitVec(STRIDE_OBJ);
        for (let j = 0; j < cellRow.length; j++) {
            if (cellRow[j] === ellipsisPattern)
                continue;
            rowMask.ior(cellRow[j].objectsPresent);
        }
        ruleMasks.push(rowMask);
    }
    return ruleMasks;
}

function cellRowMasks_Movements(rule) {
    const ruleMasks_mov = [];
    const lhs = rule[1];
    for (let i = 0; i < lhs.length; i++) {
        const cellRow = lhs[i];
        const rowMask = new BitVec(STRIDE_MOV);
        for (let j = 0; j < cellRow.length; j++) {
            if (cellRow[j] === ellipsisPattern)
                continue;
            rowMask.ior(cellRow[j].movementsPresent);
        }
        ruleMasks_mov.push(rowMask);
    }
    return ruleMasks_mov;
}

function collapseRules(groups) {
    for (let gn = 0; gn < groups.length; gn++) {
        const rules = groups[gn];
        for (let i = 0; i < rules.length; i++) {
            const oldrule = rules[i];
            const newrule = [0, [], oldrule.rhs.length > 0, oldrule.lineNumber /*ellipses,group number,rigid,commands,randomrule,[cellrowmasks]*/];
            const ellipses = [];
            for (let j = 0; j < oldrule.lhs.length; j++) {
                ellipses.push(0);
            }

            newrule[0] = dirMasks[oldrule.direction];
            for (let j = 0; j < oldrule.lhs.length; j++) {
                const cellrow_l = oldrule.lhs[j];
                for (let k = 0; k < cellrow_l.length; k++) {
                    if (cellrow_l[k] === ellipsisPattern) {
                        ellipses[j]++;
                        if (ellipses[j] > 2) {
                            logError("You can't use more than two ellipses in a single cell match pattern.", oldrule.lineNumber);
                        } else {
                            if (k > 0 && cellrow_l[k - 1] === ellipsisPattern) {
                                logWarning("Why would you go and have two ellipses in a row like that? It's exactly the same as just having a single ellipsis, right?", oldrule.lineNumber);
                            }
                        }
                    }
                }
                newrule[1][j] = cellrow_l;
            }
            newrule.push(ellipses);
            newrule.push(oldrule.groupNumber);
            newrule.push(oldrule.rigid);
            newrule.push(oldrule.commands);
            newrule.push(oldrule.randomRule);
            newrule.push(cellRowMasks(newrule));
            newrule.push(cellRowMasks_Movements(newrule));
            rules[i] = new Rule(newrule);
        }
    }
}



function ruleGroupDiscardOverlappingTest(ruleGroup) {
    if (ruleGroup.length === 0)
        return;

    let discards = [];

    for (let i = 0; i < ruleGroup.length; i++) {
        let rule = ruleGroup[i];
        if (rule.hasOwnProperty('discard')) {

            let beforesame = i === 0 ? false : ruleGroup[i - 1].lineNumber === rule.lineNumber;
            let aftersame = i === (ruleGroup.length - 1) ? false : ruleGroup[i + 1].lineNumber === rule.lineNumber;

            ruleGroup.splice(i, 1);

            let found = false;
            for (let j = 0; j < discards.length; j++) {
                let discard = discards[j];
                if (discard[0] === rule.discard[0] && discard[1] === rule.discard[1]) {
                    found = true;
                    break;
                }
            }
            if (!found) {
                discards.push(rule.discard)
            }

            //if rule before isn't of same linenumber, and rule after isn't of same linenumber, 
            //then a rule has been totally erased and you should throw an error!
            if (!(beforesame || aftersame) || ruleGroup.length === 0) {

                const example = discards[0];

                let parenthetical = "";
                if (discards.length > 1) {
                    parenthetical = " (ditto for ";
                    for (let j = 1; j < discards.length; j++) {
                        if (j > 1) {
                            parenthetical += ", "

                            if (j === discards.length - 1) {
                                parenthetical += "and ";
                            }
                        }

                        const thisdiscard = discards[j];
                        const p1 = thisdiscard[0];
                        const p2 = thisdiscard[1];
                        parenthetical += `${p1}/${p2}`;

                        if (j === 3 && discards.length > 4) {
                            parenthetical += " etc.";
                            break;
                        }
                    }
                    parenthetical += ")";
                }

                logError(`${example[0]} and ${example[1]} can never overlap${parenthetical}, but this rule requires that to happen, so it's being culled.`, rule.lineNumber);
            }
            i--;
        }
    }
}

function arrangeRulesByGroupNumber(state) {
    let aggregates = {};
    let aggregates_late = {};
    for (let i = 0; i < state.rules.length; i++) {
        let rule = state.rules[i];
        let targetArray = aggregates;
        if (rule.late) {
            targetArray = aggregates_late;
        }

        if (targetArray[rule.groupNumber] === undefined) {
            targetArray[rule.groupNumber] = [];
        }
        targetArray[rule.groupNumber].push(rule);
    }

    let result = [];

    const aggregate_keys = Object.keys(aggregates);
    const aggregate_keys_l = aggregate_keys.length;
    for (let k_i = 0; k_i < aggregate_keys_l; k_i++) {
        const groupNumber = aggregate_keys[k_i];
        let ruleGroup = aggregates[groupNumber];
        ruleGroupDiscardOverlappingTest(ruleGroup);
        if (ruleGroup.length > 0) {
            result.push(ruleGroup);
        }        
    }

    let result_late = [];

    const aggregate_keys_late = Object.keys(aggregates_late);
    const aggregate_keys_late_l = aggregate_keys_late.length;
    for (let k_i = 0; k_i < aggregate_keys_late_l; k_i++) {
        const groupNumber = aggregate_keys_late[k_i];
        let ruleGroup = aggregates_late[groupNumber];
        ruleGroupDiscardOverlappingTest(ruleGroup);
        if (ruleGroup.length > 0) {
            result_late.push(ruleGroup);
        }        
    }
    state.rules = result;

    //check that there're no late movements with direction requirements on the lhs
    state.lateRules = result_late;
}

function generateRigidGroupList(state) {
    let rigidGroupIndex_to_GroupIndex = [];
    let groupIndex_to_RigidGroupIndex = [];
    let groupNumber_to_GroupIndex = [];
    let groupNumber_to_RigidGroupIndex = [];
    let rigidGroups = [];
    for (let i = 0; i < state.rules.length; i++) {
        let ruleset = state.rules[i];
        let rigidFound = false;
        for (let j = 0; j < ruleset.length; j++) {
            let rule = ruleset[j];
            if (rule.rigid) {
                rigidFound = true;
            }
        }
        rigidGroups[i] = rigidFound;
        if (rigidFound) {
            let groupNumber = ruleset[0].groupNumber;
            groupNumber_to_GroupIndex[groupNumber] = i;
            let rigid_group_index = rigidGroupIndex_to_GroupIndex.length;
            groupIndex_to_RigidGroupIndex[i] = rigid_group_index;
            groupNumber_to_RigidGroupIndex[groupNumber] = rigid_group_index;
            rigidGroupIndex_to_GroupIndex.push(i);
        }
    }
    if (rigidGroupIndex_to_GroupIndex.length > 30) {
        let group_index = rigidGroupIndex_to_GroupIndex[30];
        logError("There can't be more than 30 rigid groups (rule groups containing rigid members).", state.rules[group_index][0].lineNumber);
    }
    state.rigid = groupIndex_to_RigidGroupIndex.length > 0;
    state.rigidGroups = rigidGroups;
    state.rigidGroupIndex_to_GroupIndex = rigidGroupIndex_to_GroupIndex;
    state.groupNumber_to_RigidGroupIndex = groupNumber_to_RigidGroupIndex;
    state.groupIndex_to_RigidGroupIndex = groupIndex_to_RigidGroupIndex;
}

function isObjectDefined(state, name) {

    let result = name in state.objects ||
        (state.aggregatesDict !== undefined && (name in state.aggregatesDict)) ||
        (state.propertiesDict !== undefined && (name in state.propertiesDict)) ||
        (state.synonymsDict !== undefined && (name in state.synonymsDict));

    if (state.legend_aggregates !== undefined) {
        for (let i = 0; i < state.legend_aggregates.length; i++) {
            if (state.legend_aggregates[i][0] === name) {
                result = true;
                break;
            }
        }
    }
    if (state.legend_properties !== undefined) {
        for (let i = 0; i < state.legend_properties.length; i++) {
            if (state.legend_properties[i][0] === name) {
                result = true;
                break;
            }
        }
    }
    if (state.legend_synonyms !== undefined) {
        for (let i = 0; i < state.legend_synonyms.length; i++) {
            if (state.legend_synonyms[i][0] === name) {
                result = true;
                break;
            }
        }
    }
    return result;
}

function getMaskFromName(state, name) {
    const objectMask = new BitVec(STRIDE_OBJ);
    let aggregate = false;
    if (name in state.objects) {
        const o = state.objects[name];
        objectMask.ibitset(o.id);
    }

    if (name in state.aggregatesDict) {
        const objectnames = state.aggregatesDict[name];
        aggregate = true;
        for (let i = 0; i < objectnames.length; i++) {
            const n = objectnames[i];
            const o = state.objects[n];
            objectMask.ibitset(o.id);
        }
    }

    if (name in state.propertiesDict) {
        const objectnames = state.propertiesDict[name];
        for (let i = 0; i < objectnames.length; i++) {
            const n = objectnames[i];
            const o = state.objects[n];
            objectMask.ibitset(o.id);
        }
    }

    if (name in state.synonymsDict) {
        const n = state.synonymsDict[name];
        const o = state.objects[n];
        objectMask.ibitset(o.id);
    }

    if (objectMask.iszero()) {
        logErrorNoLine(`Error, didn't find any object called ${name}, either in the objects section, or the legends section.`);
    }
    return [aggregate,objectMask];
}

function generateMasks(state) {
    state.playerMask = getMaskFromName(state, 'player');

    let layerMasks = [];
    let layerCount = state.collisionLayers.length;
    for (let layer = 0; layer < layerCount; layer++) {
        let layerMask = new BitVec(STRIDE_OBJ);
        for (let j = 0; j < state.objectCount; j++) {
            let n = state.idDict[j];
            let o = state.objects[n];
            if (o.layer === layer) {
                layerMask.ibitset(o.id);
            }
        }
        layerMasks.push(layerMask);
    }
    state.layerMasks = layerMasks;

    let objectMask = {};

    const object_keys = Object.keys(state.objects);
    const object_keys_l = object_keys.length;
    for (let k_i = 0; k_i < object_keys_l; k_i++) {
        const n = object_keys[k_i];
        let o = state.objects[n];
        objectMask[n] = new BitVec(STRIDE_OBJ);
        objectMask[n].ibitset(o.id);    
    }

    // Synonyms can depend on properties, and properties can depend on synonyms.
    // Process them in order by combining & sorting by linenumber.

    let synonyms_and_properties = state.legend_synonyms.concat(state.legend_properties);
    synonyms_and_properties.sort(function (a, b) {
        return a.lineNumber - b.lineNumber;
    });

    for (let i = 0; i < synonyms_and_properties.length; i++) {
        let synprop = synonyms_and_properties[i];
        if (synprop.length === 2) {
            // synonym (a = b)
            objectMask[synprop[0]] = objectMask[synprop[1]];
        } else {
            // property (a = b or c)
            let val = new BitVec(STRIDE_OBJ);
            for (let j = 1; j < synprop.length; j++) {
                let n = synprop[j];
                val.ior(objectMask[n]);
            }
            objectMask[synprop[0]] = val;
        }
    }

    //use \n as a delimeter for internal-only objects
    let all_obj = new BitVec(STRIDE_OBJ);
    all_obj.inot();
    objectMask["\nall\n"] = all_obj;

    state.objectMasks = objectMask;


    state.aggregateMasks = {};

    //set aggregate masks similarly
    for (let aggregateName of Object.keys(state.aggregatesDict)) {
        let objectnames = state.aggregatesDict[aggregateName];

        let aggregateMask = new BitVec(STRIDE_OBJ);
        for (let i = 0; i < objectnames.length; i++) {
            let n = objectnames[i];
            let o = state.objects[n];
            aggregateMask.ior(objectMask[n]);
        }
        state.aggregateMasks[aggregateName] = aggregateMask;
    }
}

function checkObjectsAreLayered(state) {
    const object_keys = Object.keys(state.objects);
    const object_keys_l = object_keys.length;
    outer: for (let k_i = 0; k_i < object_keys_l; k_i++) {
        const n = object_keys[k_i];
        let found = false;
        for (let i = 0; i < state.collisionLayers.length; i++) {
            const layer = state.collisionLayers[i];
            for (let j = 0; j < layer.length; j++) {
                if (layer[j] === n) {
                    found = true;
                    continue outer;
                }
            }
        }
        if (found === false) {
            const o = state.objects[n];
            logError('Object "' + n.toUpperCase() + '" has been defined, but not assigned to a layer.', o.lineNumber);
        }
    }
    
}

function isInt(value) {
    return !isNaN(value) && (function (x) { return (x | 0) === x; })(parseFloat(value))
}

function twiddleMetaData(state) {
    const newmetadata = {};
    for (let i = 0; i < state.metadata.length; i += 2) {
        const key = state.metadata[i];
        const val = state.metadata[i + 1];
        newmetadata[key] = val;
    }

    const getIntCheckedPositive = function (s, lineNumber) {
        if (!isFinite(s) || !isInt(s)) {
            logWarning(`Wasn't able to make sense of "${s}" as a (whole number) dimension.`, lineNumber);
            return NaN;
        }
        const result = parseInt(s);
        if (isNaN(result)) {
            logWarning(`Wasn't able to make sense of "${s}" as a dimension.`, lineNumber);
        }
        if (result <= 0) {
            logWarning(`The dimension given to me (you gave "${s}") is baad - it should be greater than 0.`, lineNumber);
        }
        return result;
    }

    const getCoords = function (val, lineNumber) {
        const coords = val.split('x');
        if (coords.length !== 2) {
            logWarning("Dimensions must be of the form AxB.", lineNumber);
            return null;
        } else {
            const intcoords = [getIntCheckedPositive(coords[0], lineNumber), getIntCheckedPositive(coords[1], lineNumber)];
            if (!isFinite(coords[0]) || !isFinite(coords[1]) || isNaN(intcoords[0]) || isNaN(intcoords[1])) {
                logWarning(`Couldn't understand the dimensions given to me (you gave "${val}") - should be of the form AxB.`, lineNumber);
                return null;
            } else {
                if (intcoords[0] <= 0 || intcoords[1] <= 0) {
                    logWarning(`The dimensions given to me (you gave "${val}") are baad - they should be > 0.`, lineNumber);
                }
                return intcoords;
            }
        }
    }

    if (newmetadata.flickscreen !== undefined) {
        const val = newmetadata.flickscreen;
        newmetadata.flickscreen = getCoords(val, state.metadata_lines.flickscreen);
        if (newmetadata.flickscreen === null) {
            delete newmetadata.flickscreen;
        }
    }
    if (newmetadata.zoomscreen !== undefined) {
        const val = newmetadata.zoomscreen;
        newmetadata.zoomscreen = getCoords(val, state.metadata_lines.zoomscreen);
        if (newmetadata.zoomscreen === null) {
            delete newmetadata.zoomscreen;
        }
    }

    state.metadata = newmetadata;
}

function processWinConditions(state) {
    //	[-1/0/1 (no,some,all),ob1,ob2] (ob2 is background by default)
    let newconditions = [];
    for (let i = 0; i < state.winconditions.length; i++) {
        let wincondition = state.winconditions[i];
        if (wincondition.length === 0) {
            //I feel like here should never be reached, right? Not sure if it warrants an error though.
            return;
        }
        let num = 0;
        switch (wincondition[0]) {
            case 'no':
                { num = -1; break; }
            case 'all':
                { num = 1; break; }
        }

        let lineNumber = wincondition[wincondition.length - 1];

        let n1 = wincondition[1];
        let n2;
        if (wincondition.length === 5) {
            n2 = wincondition[3];
        } else {
            n2 = '\nall\n';
        }

        let mask1 = 0;
        let mask2 = 0;
        let aggr1 = false;
        let aggr2 = false;

        if (wincondition.length <= 2) {
            logError('Win conditions is badly formatted - needs to look something like "No Fruit", "All Target On Crate", "Some Fruit", "Some Gold on Chest", "No Gold on Chest", or the like.', lineNumber);
        }
        else if (n1 in state.objectMasks) {
            aggr1 = false;
            mask1 = state.objectMasks[n1];
        } else if (n1 in state.aggregateMasks) {
            aggr1 = true;
            mask1 = state.aggregateMasks[n1];
        } else {
            logError('Unwelcome term "' + n1 + '" found in win condition. I don\'t know what I\'m supposed to do with this. ', lineNumber);
        }
        if (n2 in state.objectMasks) {
            aggr2 = false;
            mask2 = state.objectMasks[n2];
        } else if (n2 in state.aggregateMasks) {
            aggr2 = true;
            mask2 = state.aggregateMasks[n2];
        } else {
            logError('Unwelcome term "' + n1 + '" found in win condition. I don\'t know what I\'m supposed to do with this. ', lineNumber);
        }
        let newcondition = [num, mask1, mask2, lineNumber, aggr1, aggr2];
        newconditions.push(newcondition);
    }
    state.winconditions = newconditions;
}

function printCellRow(cellRow) {
    let result = "[ ";
    for (let i = 0; i < cellRow.length; i++) {
        if (i > 0) {
            result += "| ";
        }
        let cell = cellRow[i];
        for (let j = 0; j < cell.length; j += 2) {
            let direction = cell[j];
            let object = cell[j + 1]
            if (direction === "...") {
                result += direction + " ";
            } else {
                result += direction + " " + object + " ";
            }
        }
    }
    result += "] ";
    return result;
}

function cacheRuleStringRep(rule) {
    let result = "(<a onclick=\"jumpToLine('" + rule.lineNumber.toString() + "');\"  href=\"javascript:void(0);\">" + rule.lineNumber + "</a>) ";

    //only print rule-direction if some lhs cellrow has length>1
    let directed=false;
    for (let i=0;i<rule.lhs.length;i++){
        let cellRow = rule.lhs[i];
        if (cellRow.length>1){
            directed=true;
            break;
        }
    }

    if (directed){
        result += rule.direction.toString().toUpperCase() + " ";
    }
    if (rule.rigid) {
        result = "RIGID " + result + " ";
    }
    if (rule.randomRule) {
        result = "RANDOM " + result + " ";
    }
    if (rule.late) {
        result = "LATE " + result + " ";
    }
    for (let i = 0; i < rule.lhs.length; i++) {
        let cellRow = rule.lhs[i];
        result = result + printCellRow(cellRow);
    }
    result = result + "-> ";
    for (let i = 0; i < rule.rhs.length; i++) {
        let cellRow = rule.rhs[i];
        result = result + printCellRow(cellRow);
    }
    for (let i = 0; i < rule.commands.length; i++) {
        let command = rule.commands[i];
        if (command.length === 1) {
            result = result + command[0].toString();
        } else {
            result = result + '(' + command[0].toString() + ", " + command[1].toString() + ') ';
        }
    }
    //print commands next
    rule.stringRep = result;
}

function cacheAllRuleNames(state) {

    for (let i = 0; i < state.rules.length; i++) {
        let rule = state.rules[i];
        cacheRuleStringRep(rule);
    }
}

function printRules(state) {
    let output = "";
    let loopIndex = -1;
    let outsideLoop = true
    let discardcount = 0;
    for (let i = 0; i < state.rules.length; i++) {
        let rule = state.rules[i];

        if (!outsideLoop) {
            //decide if we print ENDLOOP
            if (loopIndex + 1 < state.loops.length) {
                let nextLoop = state.loops[loopIndex + 1];
                if (nextLoop[0] < rule.lineNumber) {
                    output += "ENDLOOP<br>";
                    outsideLoop = true;
                    loopIndex++
                }
            }
        }
        // We *don't* have an else here because we might have 
        // two loops side-by-side.
        // ( cf  https://github.com/increpare/PuzzleScript/issues/1048 )
        if (outsideLoop) {

            // if there are multiple empty startloop/endloop pairs in a row,
            // we should skip past them
            // (e.g. https://www.puzzlescript.net/editor.html?hack=7e521a3c8d22f5dc5643ad5852f6cd22)
            if (loopIndex + 1 < state.loops.length) {
                let nextLoop = state.loops[loopIndex + 1];
                let loopEnd = state.loops[loopIndex + 2];
                while (loopIndex + 1 < state.loops.length && loopEnd[0] < rule.lineNumber) {
                    loopIndex += 2;
                    nextLoop = state.loops[loopIndex + 1];
                    loopEnd = state.loops[loopIndex + 2];
                }
            }

            //trying to decide if we print STARTLOOP
            if (loopIndex + 1 < state.loops.length) {
                let nextLoop = state.loops[loopIndex + 1];
                if (nextLoop[0] < rule.lineNumber) {
                    output += "STARTLOOP<br>";
                    outsideLoop = false;
                    loopIndex++;
                }
            }
        }

        if (rule.hasOwnProperty('discard')) {
            discardcount++;
        } else {
            let sameGroupAsPrevious = i > 0 && state.rules[i - 1].groupNumber === rule.groupNumber;
            if (sameGroupAsPrevious) {
                output += '+ ';
            } else {
                output += '&nbsp;&nbsp;';
            }
            output += rule.stringRep + "<br>";
        }
    }
    if (!outsideLoop) {
        output += "ENDLOOP<br>";
    }

    output += "===========<br>";
    output = "<br>Rule Assembly : (" + (state.rules.length - discardcount) + " rules)<br>===========<br>" + output;
    consolePrint(output);
}

function removeDuplicateRules(state) {
    let record = {};
    let newrules = [];
    let lastgroupnumber = -1;
    for (let i = state.rules.length - 1; i >= 0; i--) {
        let r = state.rules[i];
        let groupnumber = r.groupNumber;
        if (groupnumber !== lastgroupnumber) {
            record = {};
        }
        let r_string = r.stringRep;
        if (record.hasOwnProperty(r_string)) {
            state.rules.splice(i, 1);
        } else {
            record[r_string] = true;
        }
        lastgroupnumber = groupnumber;
    }
}

function calculateLoopPoints(state, rulegroup_collection) {
    let loopPoint = {};
    for (let j = 0; j < state.loops.length; j += 2) {
        let loop_start_line = state.loops[j][0]; //for each startloop/endloop
        let loop_end_line = state.loops[j + 1][0];
        let init_group_index = -1
        for (let group_i = 0; group_i < rulegroup_collection.length; group_i++) {
            let ruleGroup = rulegroup_collection[group_i];

            let firstRule = ruleGroup[0];
            let lastRule = ruleGroup[ruleGroup.length - 1];

            let firstRuleLine = firstRule.lineNumber;
            let lastRuleLine = lastRule.lineNumber;

            if (firstRuleLine <= loop_start_line && loop_start_line <= lastRuleLine) {
                logError("Found a loop point in the middle of a rule. You probably don't want to do this, right?", loop_start_line)
            } else if (firstRuleLine <= loop_end_line && loop_end_line <= lastRuleLine) {
                logError("Found a loop point in the middle of a rule. You probably don't want to do this, right?", loop_start_line)
            }

            let rule_before_loop = loop_start_line > firstRuleLine;
            let rule_in_loop = loop_start_line <= firstRuleLine && firstRuleLine <= loop_end_line;
            let rule_after_loop = loop_end_line < firstRuleLine;

            if (rule_after_loop)
                break;


            if (rule_in_loop) {
                if (init_group_index === -1) {
                    init_group_index = group_i
                }
                // only the last rulegroup in a loop should be the loop point - 
                // this is a bit lazy, but basically we look back, and if the 
                // previous rule-group has the same loop point, we remove it.
                if (group_i > 0 && loopPoint[group_i - 1] !== undefined && loopPoint[group_i - 1] === init_group_index) {
                    loopPoint[group_i - 1] = undefined;
                }
                loopPoint[group_i] = init_group_index;
            }
        }
    }
    return loopPoint;
}

function generateLoopPoints(state) {
    //run through to check loops aren't nested and are properly closed
    for (let group_i = 0; group_i < state.loops.length; group_i++) {
        let loop = state.loops[group_i];
        if (group_i % 2 === 0) {
            if (loop[1] === -1) {
                logError("Found an ENDLOOP, but I'm not in a loop?", loop[0]);
            }
        } else {
            if (loop[1] === 1) {
                logError("Found a STARTLOOP, but I'm already inside a loop? (Puzzlescript can't nest loops, FWIW).", loop[0]);
            }
        }
    }
    if ((state.loops.length % 2) !== 0) {
        logError("Yo I found a STARTLOOP without a corresponding ENDLOOP.", state.loops[state.loops.length - 1][0]);
        //patch up by adding an ENDLOOP
        state.loops.push([state.loops[state.loops.length - 1][0], -1]);
    }


    state.loopPoint = calculateLoopPoints(state, state.rules);
    state.lateLoopPoint = calculateLoopPoints(state, state.lateRules);

}

let soundDirectionIndicatorMasks = {
    'up': parseInt('00001', 2),
    'down': parseInt('00010', 2),
    'left': parseInt('00100', 2),
    'right': parseInt('01000', 2),
    'horizontal': parseInt('01100', 2),
    'vertical': parseInt('00011', 2),
    'orthogonal': parseInt('01111', 2),
    '___action____': parseInt('10000', 2)
};

let soundDirectionIndicators = ["up", "down", "left", "right", "horizontal", "vertical", "orthogonal", "___action____"];


function generateSoundData(state) {
    let sfx_Events = {};
    let sfx_CreationMasks = [];
    let sfx_DestructionMasks = [];
    let sfx_MovementMasks = state.collisionLayers.map(x => []);
    let sfx_MovementFailureMasks = [];

    for (let i = 0; i < state.sounds.length; i++) {
        let sound = state.sounds[i];
        if (sound.length <= 1) {
            //don't see that this would ever be triggered
            continue;
        }
        let lineNumber = sound[sound.length - 1];

        if (sound.length === 2) {
            logWarning('incorrect sound declaration.', lineNumber);
            continue;
        }

        const v0 = sound[0][0].trim();
        const t0 = sound[0][1].trim();
        const v1 = sound[1][0].trim();
        const t1 = sound[1][1].trim();

        let seed = sound[sound.length - 2][0];
        let seed_t = sound[sound.length - 2][1];
        if (seed_t !== 'SOUND') {
            // unreachable?
            // seems to be pre-empted by "Was expecting a soundverb here 
            // (MOVE, DESTROY, CANTMOVE, or the like), but found something else" message
            logError("Expecting sfx data, instead found \"" + seed + "\".", lineNumber);
        }

        if (t0 === "SOUNDEVENT") {

            //pretty sure neither of the following are reachable, they're caught by the parser before.
            if (sound.length > 4) {
                logError("too much stuff to define a sound event.", lineNumber);
            } else {
                //out of an abundance of caution, doing a fallback warning rather than expanding the scope of the error #779
                if (sound.length > 3) {
                    logWarning("too much stuff to define a sound event.", lineNumber);
                }
            }

            if (sfx_Events[v0] !== undefined) {
                logWarning(v0.toUpperCase() + " already declared.", lineNumber);
            }
            sfx_Events[v0] = seed;

        } else {
            let target = v0;
            let verb = v1;
            let directions = [];
            for (let j = 2; j < sound.length - 2; j++) {//avoid last sound declaration as well as the linenumber element at the end
                if (sound[j][1] === 'DIRECTION') {
                    directions.push(sound[j][0]);
                } else {
                    //Don't think I can get here, but just in case
                    logError(`Expected a direction here, but found instead "$(sound[j][0])".`, lineNumber);
                }
            }
            if (directions.length > 0 && (verb !== 'move' && verb !== 'cantmove')) {
                //this is probably unreachable, as the parser catches it before it gets here
                logError('Incorrect sound declaration - cannot have directions (UP/DOWN/etc.) attached to non-directional sound verbs (CREATE is not directional, but MOVE is directional).', lineNumber);
            }

            if (verb === 'action') {
                verb = 'move';
                directions = ['___action____'];
            }

            if (directions.length === 0) {
                directions = ["orthogonal"];
            }


            if (target in state.aggregatesDict) {
                logError('cannot assign sound events to aggregate objects (declared with "and"), only to regular objects, or properties, things defined in terms of "or" ("' + target + '").', lineNumber);
            } else if (target in state.objectMasks) {

            } else {
                //probably unreachable
                logError('Object "' + target + '" not found.', lineNumber);
            }

            let objectMask = state.objectMasks[target];

            let directionMask = 0;
            for (let j = 0; j < directions.length; j++) {
                directions[j] = directions[j].trim();
                let direction = directions[j];
                if (soundDirectionIndicators.indexOf(direction) === -1) {
                    //pre-emted by parser
                    logError('Was expecting a direction, instead found "' + direction + '".', lineNumber);
                } else {
                    let soundDirectionMask = soundDirectionIndicatorMasks[direction];
                    directionMask |= soundDirectionMask;
                }
            }


            let targets = [target];
            let modified = true;
            while (modified) {
                modified = false;
                for (let k = 0; k < targets.length; k++) {
                    let t = targets[k];
                    if (t in state.synonymsDict) {
                        targets[k] = state.synonymsDict[t];
                        modified = true;
                    } else if (t in state.propertiesDict) {
                        modified = true;
                        let props = state.propertiesDict[t];
                        targets.splice(k, 1);
                        k--;
                        for (let l = 0; l < props.length; l++) {
                            targets.push(props[l]);
                        }
                    }
                }
            }

            //if verb in soundverbs_directional
            if (verb === 'move' || verb === 'cantmove') {
                for (let j = 0; j < targets.length; j++) {
                    let targetName = targets[j];
                    let targetDat = state.objects[targetName];
                    let targetLayer = targetDat.layer;
                    let this_object_mask = new BitVec(STRIDE_OBJ);
                    this_object_mask.ibitset(targetDat.id)

                    //if not found, continue - probably from the error ""aggr" is an aggregate (defined using "and"), and cannot be added to a single layer because its constituent objects must be able to coexist."
                    if (targetLayer === undefined) {
                        continue;
                    }
                    let shiftedDirectionMask = new BitVec(STRIDE_MOV);
                    shiftedDirectionMask.ishiftor(directionMask, 5 * targetLayer);

                    let o = {
                        objectMask: this_object_mask,
                        directionMask: shiftedDirectionMask,
                        layer: targetLayer,
                        seed: seed
                    };

                    if (verb === 'move') {
                        sfx_MovementMasks[targetLayer].push(o);
                    } else {
                        sfx_MovementFailureMasks.push(o);
                    }
                }
            }



            let targetArray;
            switch (verb) {
                case "create":
                    {
                        let o = {
                            objectMask: objectMask,
                            seed: seed
                        }
                        sfx_CreationMasks.push(o);
                        break;
                    }
                case "destroy":
                    {
                        let o = {
                            objectMask: objectMask,
                            seed: seed
                        }
                        sfx_DestructionMasks.push(o);
                        break;
                    }
            }
        }
    }

    state.sfx_Events = sfx_Events;
    state.sfx_CreationMasks = sfx_CreationMasks;
    state.sfx_DestructionMasks = sfx_DestructionMasks;
    state.sfx_MovementMasks = sfx_MovementMasks;
    state.sfx_MovementFailureMasks = sfx_MovementFailureMasks;
}


function formatHomePage(state) {
    if ('background_color' in state.metadata) {
        state.bgcolor = colorToHex(colorPalette, state.metadata.background_color);
    } else {
        state.bgcolor = "#000000";
    }
    if ('text_color' in state.metadata) {
        state.fgcolor = colorToHex(colorPalette, state.metadata.text_color);
    } else {
        state.fgcolor = "#FFFFFF";
    }

    if (isColor(state.fgcolor) === false) {
        logError("text_color in incorrect format - found " + state.fgcolor + ", but I expect a color name (like 'pink') or hex-formatted color (like '#1412FA').  Defaulting to white.", state.metadata_lines.text_color)
        state.fgcolor = "#FFFFFF";
    }
    if (isColor(state.bgcolor) === false) {
        logError("background_color in incorrect format - found " + state.bgcolor + ", but I expect a color name (like 'pink') or hex-formatted color (like '#1412FA').  Defaulting to black.", state.metadata_lines.background_color)
        state.bgcolor = "#000000";
    }

    if (canSetHTMLColors) {

        if ('background_color' in state.metadata) {
            document.body.style.backgroundColor = state.bgcolor;
        }

        if ('text_color' in state.metadata) {
            let separator = document.getElementById("separator");
            if (separator != null) {
                separator.style.color = state.fgcolor;
            }

            let aElements = document.getElementsByTagName("a");
            for (let i = 0; i < aElements.length; i++) {
                aElements[i].style.color = state.fgcolor;
            }

            let h1Elements = document.getElementsByTagName("h1");
            for (let i = 0; i < h1Elements.length; i++) {
                h1Elements[i].style.color = state.fgcolor;
            }
        }
    }

    if ('homepage' in state.metadata) {
        let url = state.metadata['homepage'];
        url = url.replace("http://", "");
        url = url.replace("https://", "");
        state.metadata['homepage'] = url;
    }
}

let MAX_ERRORS = 5;

function loadFile(str) {
    let processor = new codeMirrorFn();
    let state = processor.startState();

    let lines = str.split('\n');
    for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        let ss = new CodeMirror.StringStream(line, 4);
        do {
            processor.token(ss, state);

            if (errorCount > MAX_ERRORS) {
                consolePrint("too many errors, aborting compilation");
                return;
            }
        }
        while (ss.eol() === false);
    }

    //check if player defined
    if (!isObjectDefined(state, "player")) {
        logErrorNoLine("Error, didn't find any object called player, either in the objects section, or the legends section. There must be a player!");
    }
    //check if background
    if (!isObjectDefined(state, "background")) {
        logErrorNoLine("Error, didn't find any object called background, either in the objects section, or the legends section. There must be a background!");
    }

    if (state.collisionLayers.length === 0) {
        logError("No collision layers defined.  All objects need to be in collision layers.");
        return null;
    }

    generateExtraMembers(state);
    generateMasks(state);
    levelsToArray(state);
    rulesToArray(state);
    if (state.invalid > 0) {
        return null;
    }

    cacheAllRuleNames(state);
    removeDuplicateRules(state);
    rulesToMask(state);

    if (debugMode) {
        printRules(state);
    }

    arrangeRulesByGroupNumber(state);
    collapseRules(state.rules);
    collapseRules(state.lateRules);

    generateRigidGroupList(state);

    processWinConditions(state);
    checkObjectsAreLayered(state);

    twiddleMetaData(state);

    generateLoopPoints(state);

    generateSoundData(state);

    formatHomePage(state);

    addSpecializedFunctions(state);

    //delete intermediate representations
    delete state.commentLevel;
    delete state.line_should_end;
    delete state.line_should_end_because;
    delete state.sol_after_comment;
    delete state.names;
    delete state.abbrevNames;
    delete state.objects_candname;
    delete state.objects_section;
    delete state.objects_spritematrix;
    delete state.section;
    delete state.subsection;
    delete state.tokenIndex;
    delete state.current_line_wip_array;
    delete state.visitedSections;
    delete state.loops;
    /*
    let lines = stripComments(str);
    window.console.log(lines);
    let sections = generateSections(lines);
    window.console.log(sections);
    let sss = generateSemiStructuredSections(sections);*/
    return state;
}


function addSpecializedFunctions(state) {
    const OBJECT_SIZE = Math.ceil(state.objectCount / 32);
    const MOVEMENT_SIZE = Math.ceil(state.collisionLayers.length / 5);
    state.moveEntitiesAtIndex = generate_moveEntitiesAtIndex(OBJECT_SIZE, MOVEMENT_SIZE);
    state.calculateRowColMasks = generate_calculateRowColMasks(OBJECT_SIZE, MOVEMENT_SIZE);
    state.resolveMovements = generate_resolveMovements(OBJECT_SIZE, MOVEMENT_SIZE,state);
    state.matchCellRow = generateMatchCellRow(OBJECT_SIZE, MOVEMENT_SIZE);
    state.matchCellRowWildCard = generateMatchCellRowWildCard(OBJECT_SIZE, MOVEMENT_SIZE);
    state.repositionEntitiesAtCell = generate_repositionEntitiesAtCell(OBJECT_SIZE, MOVEMENT_SIZE);
}


// function diffLevelStates(basis, current){
//     const diff = []
//     for (let i = 0; i < basis.length; i++) {
//         if (basis[i] !== current[i]) {
//             diff.push(i);
//             diff.push(current[i]);
//         }
//     }
//     return diff.toString();
// }

// function simulation_tickInput(val){
//     processInput(val);
//     while (againing) {
//         againing=false;
//         processInput(-1,false);			
//     }
// }

// function solveLevel(state){
//     //disable sfx
//     let oldmuted=muted;
//     muted = true;
//     /* this is a pathfinding algorithm that will try to solve the level - it does a depth first search of the level */
//     const visited_states = new Set();
//     const states_to_leave = [];
//     const MOVE_COUNT=5;//up down left right action  

//     const desired_level = curlevel;
//     loadLevelFromState(state,curlevel,null);
// 	while (againing) {//in case some stuff to do at the start
// 		againing=false;
// 		processInput(-1);			
// 	}

//     const initial_level_state = new Int32Array(level.objects);
//     const initial_state_key = diffLevelStates(initial_level_state, initial_level_state);
//     visited_states.add(initial_state_key);
//     states_to_leave.push({
//             state:initial_level_state,
//             input_sequence:""
//         });


//     let won = false;
//     let solution = "";

//     while (states_to_leave.length > 0){
//         let o = states_to_leave.shift();
//         let level_state = o.state;
//         let input_sequence = o.input_sequence;
//         for (let input=0; input<MOVE_COUNT; input++){
//             level.objects.set(level_state);            
//             simulation_tickInput(input);
//             const new_state = level.objects;
//             const new_state_key = diffLevelStates(initial_level_state,new_state);
//             if (visited_states.has(new_state_key)){
//                 continue;
//             }
//             let new_input_sequence = input_sequence + input;
//             visited_states.add(new_state_key);
//             states_to_leave.push({
//                 state:new Int32Array(new_state),
//                 input_sequence:new_input_sequence
//             });
//             if (winning){
//                 won = true;
//                 solution = new_input_sequence;
//                 break;
//             }
//         }
//     }
//     if (won){
//         consolePrint("Solution found");
//         consolePrint("States Visited: " + visited_states.size);
//         consolePrint(pretty_print_solution(solution));
//     } else {
//         consolePrint("No solution found");
//         consolePrint("States Visited: " + visited_states.size);
//     }

//     curlevel=desired_level;
//     winning=false;
//     loadLevelFromState(state,curlevel,null);
//     consolePrint("loaded level"+curlevel);
//     muted = oldmuted;
// }

// function pretty_print_solution(solution){
//     const move_names = ["U","L","D","R","A"];
//     let result=""
//     //group in fives
//     for (let i = 0; i < solution.length; i ++) {
//         const move_name = move_names[solution[i]];
//         result += move_name;
//         if ((i + 1) % 5 === 0) {
//             result += " ";
//         }
//     }
//     return result;
// }

function compile(command, text, randomseed) {



    lazy_function_generation_clear_backlog();

    forceRegenImages = true;
    if (command === undefined) {
        command = ["restart"];
    }
    if (randomseed === undefined) {
        randomseed = null;
    }
    lastDownTarget = canvas;

    //if the editor is opened, we should print the contents
    if ( command[0] === "restart" && levelEditorOpened){
        //print the contents of the level before recompiling
        printLevel();
    }

    if (text === undefined) {
        let code = window.form1.code;

        let editor = code.editorreference;

        text = editor.getValue() + "\n";
    }
    if (canDump === true) {
        compiledText = text;
    }

    errorCount = 0;
    compiling = true;
    errorStrings = [];
    consolePrint('=================================');
    let state;
    try {
        state = loadFile(text);
    } catch (error) {
        consoleError(error.message+"\n"+error.stack,true);
        console.error(error);
        UnitTestingThrow(error);
    } finally {
        compiling = false;
    }

    if (state && state.levels && state.levels.length === 0) {
        logError('No levels found.  Add some levels!', undefined, true);
    }



    if (errorCount > 0) {
        if (IDE === false) {
            if (state === null) {
                consoleError('<span class="systemMessage">Errors detected during compilation; I can\'t salvage anything playable from it.  If this is an older game, and you think it just broke because of recent changes in the puzzlescript engine, please consider dropping an email to analytic@gmail.com with a link to the game and I\'ll try make sure it\'s back working ASAP.</span>');
            } else {
                consoleError('<span class="systemMessage">Errors detected during compilation; the game may not work correctly. If this is an older game, and you think it just broke because of recent changes in the puzzlescript engine, please consider dropping an email to analytic@gmail.com with a link to the game and I\'ll try make sure it\'s back working ASAP.</span>');
            }
        } else {
            if (state === null) {
                consoleError('<span class="systemMessage">Errors detected during compilation; I can\'t salvage anything playable from it.</span>');
            } else {
                consoleError('<span class="systemMessage">Errors detected during compilation; the game may not work correctly.</span>');
            }
        }
        if (errorCount > MAX_ERRORS) {
            return;
        }
    } else {
        let ruleCount = 0;
        for (let i = 0; i < state.rules.length; i++) {
            ruleCount += state.rules[i].length;
        }
        for (let i = 0; i < state.lateRules.length; i++) {
            ruleCount += state.lateRules[i].length;
        }
        if (command[0] === "restart") {
            consolePrint('<span class="systemMessage">Successful Compilation, generated ' + ruleCount + ' instructions.</span>');
        } else {
            consolePrint('<span class="systemMessage">Successful live recompilation, generated ' + ruleCount + ' instructions.</span>');
        }



        if (IDE) {
            if (state.metadata.title !== undefined) {
                document.title = "PuzzleScript - " + state.metadata.title;
            }
        }
    }

    if (state !== null) {//otherwise error
        setGameState(state, command, randomseed);
    }

    clearInputHistory();

    consoleCacheDump();

    manage_compilation_caches();

}

const cache_CHECK_RATE=20;
let cache_checkCount=0;
function manage_compilation_caches() {    
    cache_checkCount = (cache_checkCount + 1) % cache_CHECK_RATE;
    if (cache_checkCount !== 0) {
        return;
    }
    // console.log("CACHE_CELLPATTERN_MATCHFUNCTION size: " + Object.keys(CACHE_CELLPATTERN_MATCHFUNCTION).length);
    // console.log("CACHE_MOVEENTITIESATINDEX size: " + Object.keys(CACHE_MOVEENTITIESATINDEX).length);
    // console.log("CACHE_CALCULATEROWCOLMASKS size: " + Object.keys(CACHE_CALCULATEROWCOLMASKS).length);
    // console.log("CACHE_RULE_CELLROWMATCHESFUNCTION size: " + Object.keys(CACHE_RULE_CELLROWMATCHESFUNCTION).length);
    // console.log("CACHE_CELLPATTERN_REPLACEFUNCTION size: " + Object.keys(CACHE_CELLPATTERN_REPLACEFUNCTION).length);
    // console.log("CACHE_MATCHCELLROW size: " + Object.keys(CACHE_MATCHCELLROW).length);
    // console.log("CACHE_MATCHCELLROWWILDCARD size: " + Object.keys(CACHE_MATCHCELLROWWILDCARD).length);
    // console.log("CACHE_RULE_APPLYAT size: " + Object.keys(CACHE_RULE_APPLYAT).length);
    // console.log("CACHE_RESOLVEMOVEMENTS size: " + Object.keys(CACHE_RESOLVEMOVEMENTS).length);
    // console.log("CACHE_RULE_FINDMATCHES size: " + Object.keys(CACHE_RULE_FINDMATCHES).length);



    //CACHE_CELLPATTERN_MATCHFUNCTION>10000, reset, for the others the limit is say 200
    if (Object.keys(CACHE_CELLPATTERN_MATCHFUNCTION).length > 10000) {
        CACHE_CELLPATTERN_MATCHFUNCTION = {};
    }
    if (Object.keys(CACHE_MOVEENTITIESATINDEX).length > 200) {
        CACHE_MOVEENTITIESATINDEX = {};
    }
    if (Object.keys(CACHE_CALCULATEROWCOLMASKS).length > 200) {
        CACHE_CALCULATEROWCOLMASKS = {};
    }
    if (Object.keys(CACHE_RULE_CELLROWMATCHESFUNCTION).length > 1000) {
        CACHE_RULE_CELLROWMATCHESFUNCTION = {};
    }
    if (Object.keys(CACHE_CELLPATTERN_REPLACEFUNCTION).length > 200) {
        CACHE_CELLPATTERN_REPLACEFUNCTION = {};
    }
    if (Object.keys(CACHE_MATCHCELLROW).length > 200) {
        CACHE_MATCHCELLROW = {};
    }
    if (Object.keys(CACHE_MATCHCELLROWWILDCARD).length > 200) {
        CACHE_MATCHCELLROWWILDCARD = {};
    }
    if (Object.keys(CACHE_RULE_APPLYAT).length > 200) {
        CACHE_RULE_APPLYAT = {};
    }
    if (Object.keys(CACHE_RESOLVEMOVEMENTS).length > 200) {
        CACHE_RESOLVEMOVEMENTS = {};
    }
    if (Object.keys(CACHE_RULE_FINDMATCHES).length > 200) {
        CACHE_RULE_FINDMATCHES = {};
    }
}



function qualifyURL(url) {
    let a = document.createElement('a');
    a.href = url;
    return a.href;
}



</script>
<script>
'use strict';

let keyRepeatTimer = 0;
let keyRepeatIndex = 0;
let input_throttle_timer = 0.0;
let lastinput = -100;

let dragging = false;
let rightdragging = false;
let columnAdded = false;

function selectText(containerid, e) {
	e = e || window.event;
	let myspan = document.getElementById(containerid);
	if (e && (e.ctrlKey || e.metaKey)) {
		const levelarr = ["console"].concat(myspan.innerText.split("\n"));
		const leveldat = levelFromString(state, levelarr);
		loadLevelFromLevelDat(state, leveldat, null);
		canvasResize();
	} else {
		if (document.selection) {
			const range = document.body.createTextRange();
			range.moveToElementText(myspan);
			range.select();
		} else if (window.getSelection) {
			const range = document.createRange();
			range.selectNode(myspan);
			const selection = window.getSelection();
			//why removeallranges? https://stackoverflow.com/a/43443101 whatever...
			selection.removeAllRanges();
			selection.addRange(range);
		}
	}
}

function recalcLevelBounds() {
}

function arrCopy(from, fromoffset, to, tooffset, len) {
	while (len--)
		to[tooffset++] = from[fromoffset]++;
}

function adjustLevel(level, widthdelta, heightdelta) {
	backups.push(backupLevel());
	const oldlevel = level.clone();
	level.width += widthdelta;
	level.height += heightdelta;
	level.n_tiles = level.width * level.height;
	level.objects = new Int32Array(level.n_tiles * STRIDE_OBJ);
	const bgMask = new BitVec(STRIDE_OBJ);
	bgMask.ibitset(state.backgroundid);
	for (let i = 0; i < level.n_tiles; ++i)
		level.setCell(i, bgMask);
	level.movements = new Int32Array(level.objects.length);
	columnAdded = true;
	RebuildLevelArrays();
	return oldlevel;
}

function addLeftColumn() {
	const oldlevel = adjustLevel(level, 1, 0);
	for (let x = 1; x < level.width; ++x) {
		for (let y = 0; y < level.height; ++y) {
			const index = x * level.height + y;
			level.setCell(index, oldlevel.getCell(index - level.height))
		}
	}
}

function addRightColumn() {
	const oldlevel = adjustLevel(level, 1, 0);
	for (let x = 0; x < level.width - 1; ++x) {
		for (let y = 0; y < level.height; ++y) {
			const index = x * level.height + y;
			level.setCell(index, oldlevel.getCell(index))
		}
	}
}

function addTopRow() {
	const oldlevel = adjustLevel(level, 0, 1);
	for (let x = 0; x < level.width; ++x) {
		for (let y = 1; y < level.height; ++y) {
			const index = x * level.height + y;
			level.setCell(index, oldlevel.getCell(index - x - 1))
		}
	}
}

function addBottomRow() {
	const oldlevel = adjustLevel(level, 0, 1);
	for (let x = 0; x < level.width; ++x) {
		for (let y = 0; y < level.height - 1; ++y) {
			const index = x * level.height + y;
			level.setCell(index, oldlevel.getCell(index - x));
		}
	}
}

function removeLeftColumn() {
	if (level.width <= 1) {
		return;
	}
	const oldlevel = adjustLevel(level, -1, 0);
	for (let x = 0; x < level.width; ++x) {
		for (let y = 0; y < level.height; ++y) {
			const index = x * level.height + y;
			level.setCell(index, oldlevel.getCell(index + level.height))
		}
	}
}

function removeRightColumn() {
	if (level.width <= 1) {
		return;
	}
	const oldlevel = adjustLevel(level, -1, 0);
	for (let x = 0; x < level.width; ++x) {
		for (let y = 0; y < level.height; ++y) {
			const index = x * level.height + y;
			level.setCell(index, oldlevel.getCell(index))
		}
	}
}

function removeTopRow() {
	if (level.height <= 1) {
		return;
	}
	const oldlevel = adjustLevel(level, 0, -1);
	for (let x = 0; x < level.width; ++x) {
		for (let y = 0; y < level.height; ++y) {
			const index = x * level.height + y;
			level.setCell(index, oldlevel.getCell(index + x + 1))
		}
	}
}
function removeBottomRow() {
	if (level.height <= 1) {
		return;
	}
	const oldlevel = adjustLevel(level, 0, -1);
	for (let x = 0; x < level.width; ++x) {
		for (let y = 0; y < level.height; ++y) {
			const index = x * level.height + y;
			level.setCell(index, oldlevel.getCell(index + x))
		}
	}
}

function matchGlyph(inputmask, glyphAndMask) {
	// find mask with closest match
	let highestbitcount = -1;
	let highestmask;
	for (let i = 0; i < glyphAndMask.length; ++i) {
		const glyphname = glyphAndMask[i][0];
		const glyphmask = glyphAndMask[i][1];
		const glyphbits = glyphAndMask[i][2];
		//require all bits of glyph to be in input
		if (glyphmask.bitsSetInArray(inputmask.data)) {
			let bitcount = 0;
			for (let bit = 0; bit < 32 * STRIDE_OBJ; ++bit) {
				if (glyphbits.get(bit) && inputmask.get(bit))
					bitcount++;
				if (glyphmask.get(bit) && inputmask.get(bit))
					bitcount++;
			}
			if (bitcount > highestbitcount) {
				highestbitcount = bitcount;
				highestmask = glyphname;
			}
		}
	}
	if (highestbitcount > 0) {
		return highestmask;
	}

	compiling = true; //i'm so sorry cf #999 "can't print level to console if too many approximations lol"
	logWarningNoLine("Wasn't able to approximate glyph values for some tiles, using '.' as a placeholder.", false);
	compiling = false;
	return '.';
}

let htmlEntityMap = {
	"&": "&amp;",
	"<": "&lt;",
	">": "&gt;",
	'"': '&quot;',
	"'": '&#39;',
	"/": '&#x2F;'
};

let selectableint = 0;

function printLevel() {
	try {
		errorCount = 0;
		errorStrings = [];
		const glyphMasks = [];

		for (const glyphName in state.glyphDict) {
			if (state.glyphDict.hasOwnProperty(glyphName) && glyphName.length === 1) {
				const glyph = state.glyphDict[glyphName];
				const glyphmask = new BitVec(STRIDE_OBJ);
				for (let i = 0; i < glyph.length; i++) {
					const id = glyph[i];
					if (id >= 0) {
						glyphmask.ibitset(id);
					}
				}
				const glyphbits = glyphmask.clone();
				//register the same - backgroundmask with the same name
				const bgMask = state.layerMasks[state.backgroundlayer];
				glyphmask.iclear(bgMask);
				glyphMasks.push([glyphName, glyphmask, glyphbits]);
			}
		}
		selectableint++;
		const tag = 'selectable' + selectableint;
		let output = "Printing level contents:<br><br><span id=\"" + tag + "\" onclick=\"selectText('" + tag + "',event)\">";
		for (let j = 0; j < level.height; j++) {
			for (let i = 0; i < level.width; i++) {
				const cellIndex = j + i * level.height;
				const cellMask = level.getCell(cellIndex);
				let glyph = matchGlyph(cellMask, glyphMasks);
				if (glyph in htmlEntityMap) {
					glyph = htmlEntityMap[glyph];
				}
				output = output + glyph;
			}
			if (j < level.height - 1) {
				output = output + "<br>";
			}
		}
		output += "</span><br><br>"
		consolePrint(output, true);
	} catch (e) {
		console.error(e);
		consolePrint("unable to print level contents because of errors", true);
	}
}

function levelEditorClick(event, click) {
	if (mouseCoordY <= -2) {
		const ypos = editorRowCount - (-mouseCoordY - 2) - 1;
		const newindex = mouseCoordX + (screenwidth - 1) * ypos;
		if (mouseCoordX === -1) {
			printLevel();
		} else if (mouseCoordX >= 0 && newindex < glyphImages.length) {
			glyphSelectedIndex = newindex;
			redraw();
		}

	} else if (mouseCoordX > -1 && mouseCoordY > -1 && mouseCoordX < screenwidth - 2 && mouseCoordY < screenheight - 2 - editorRowCount) {
		const glyphname = glyphImagesCorrespondance[glyphSelectedIndex];
		const glyph = state.glyphDict[glyphname];
		const glyphmask = new BitVec(STRIDE_OBJ);
		for (let i = 0; i < glyph.length; i++) {
			const id = glyph[i];
			if (id >= 0) {
				glyphmask.ibitset(id);
			}
		}

		const backgroundMask = state.layerMasks[state.backgroundlayer];
		if (glyphmask.bitsClearInArray(backgroundMask.data)) {
			// If we don't already have a background layer, mix in
			// the default one.
			glyphmask.ibitset(state.backgroundid);
		}

		const coordIndex = mouseCoordY + mouseCoordX * level.height;
		const getcell = level.getCell(coordIndex);
		if (getcell.equals(glyphmask)) {
			return;
		} else {
			if (anyEditsSinceMouseDown === false) {
				anyEditsSinceMouseDown = true;
				backups.push(backupLevel());
			}
			level.setCell(coordIndex, glyphmask);
			redraw();
		}
	}
	else if (click) {
		if (mouseCoordX === -1) {
			//add a left row to the map
			addLeftColumn();
			canvasResize();
		} else if (mouseCoordX === screenwidth - 2) {
			addRightColumn();
			canvasResize();
		}
		if (mouseCoordY === -1) {
			addTopRow();
			canvasResize();
		} else if (mouseCoordY === screenheight - 2 - editorRowCount) {
			addBottomRow();
			canvasResize();
		}
	}
}

function levelEditorRightClick(event, click) {
	if (mouseCoordY === -2) {
		if (mouseCoordX <= glyphImages.length) {
			glyphSelectedIndex = mouseCoordX;
			redraw();
		}
	} else if (mouseCoordX > -1 && mouseCoordY > -1 && mouseCoordX < screenwidth - 2 && mouseCoordY < screenheight - 2 - editorRowCount) {
		const coordIndex = mouseCoordY + mouseCoordX * level.height;
		const glyphmask = new BitVec(STRIDE_OBJ);
		glyphmask.ibitset(state.backgroundid);
		level.setCell(coordIndex, glyphmask);
		redraw();
	}
	else if (click) {
		if (mouseCoordX === -1) {
			//add a left row to the map
			removeLeftColumn();
			canvasResize();
		} else if (mouseCoordX === screenwidth - 2) {
			removeRightColumn();
			canvasResize();
		}
		if (mouseCoordY === -1) {
			removeTopRow();
			canvasResize();
		} else if (mouseCoordY === screenheight - 2 - editorRowCount) {
			removeBottomRow();
			canvasResize();
		}
	}
}

let anyEditsSinceMouseDown = false;

function onMouseDown(event) {

	if (event.handled) {
		return;
	}

	ULBS();

	let lmb = event.button === 0;
	let rmb = event.button === 2;
	if (event.type == "touchstart") {
		lmb = true;
	}
	if (lmb && (event.ctrlKey || event.metaKey)) {
		lmb = false;
		rmb = true;
	}

	if (lmb) {
		lastDownTarget = event.target;
		keybuffer = [];
		if (event.target === canvas || event.target.className === "tapFocusIndicator") {
			setMouseCoord(event);
			dragging = true;
			rightdragging = false;
			if (levelEditorOpened) {
				anyEditsSinceMouseDown = false;
				return levelEditorClick(event, true);
			}
		}
		dragging = false;
		rightdragging = false;
		event.handled = true;
	} else if (rmb) {
		if (event.target === canvas || event.target.className === "tapFocusIndicator") {
			setMouseCoord(event);
			dragging = false;
			rightdragging = true;
			if (levelEditorOpened) {
				event.handled = true;
				return levelEditorRightClick(event, true);
			}
		}
	}


}

function rightClickCanvas(event) {
	if (levelEditorOpened){
		return prevent(event);
	} else {
		return true;
	}
}

function onMouseUp(event) {
	if (event.handled) {
		return;
	}

	dragging = false;
	rightdragging = false;

	event.handled = true;
}

function onKeyDown(event) {

	ULBS();

	event = event || window.event;

	// Prevent arrows/space from scrolling page
	if ((!IDE) && ([32, 37, 38, 39, 40].indexOf(event.keyCode) > -1)) {
		if (event && (event.ctrlKey || event.metaKey)) {
		} else {
			prevent(event);
		}
	}

	if ((!IDE) && event.keyCode === 77) {//m
		toggleMute();
	}


	if (keybuffer.indexOf(event.keyCode) >= 0) {
		return;
	}

	if (lastDownTarget === canvas || (window.Mobile && (lastDownTarget === window.Mobile.focusIndicator))) {
		if (keybuffer.indexOf(event.keyCode) === -1) {
			if (event && ((event.ctrlKey&&event.keyCode!==90) || event.metaKey)) {
			} else {
				keybuffer.splice(keyRepeatIndex, 0, event.keyCode);
				keyRepeatTimer = 0;
				checkKey(event, !event.repeat);
			}
		}
	}


	if (canDump === true) {
		if (event.keyCode === 74 && (event.ctrlKey || event.metaKey)) {//ctrl+j
			dumpTestCase();
			prevent(event);
		} else if (event.keyCode === 75 && (event.ctrlKey || event.metaKey)) {//ctrl+k
			makeGIF();
			prevent(event);
		} else if (event.keyCode === 83 && (event.ctrlKey || event.metaKey)) {//ctrl+s
			saveClick();
			prevent(event);
		} else if (event.keyCode === 13 && (event.ctrlKey || event.metaKey)) {//ctrl+enter
			canvas.focus();
			editor.display.input.blur();
			if (event.shiftKey) {
				runClick();
			} else {
				rebuildClick();
			}
			prevent(event);
		}
	}
}

function relMouseCoords(event) {
	let totalOffsetX = 0;
	let totalOffsetY = 0;
	let canvasX = 0;
	let canvasY = 0;
	let currentElement = this;

	do {
		totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
		totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
	}
	while (currentElement = currentElement.offsetParent)

	if (event.touches == null) {
		canvasX = event.pageX - totalOffsetX;
		canvasY = event.pageY - totalOffsetY;
	} else {
		canvasX = event.touches[0].pageX - totalOffsetX;
		canvasY = event.touches[0].pageY - totalOffsetY;

	}

	return { x: canvasX, y: canvasY }
}
HTMLCanvasElement.prototype.relMouseCoords = relMouseCoords;

function onKeyUp(event) {
	event = event || window.event;
	let index = keybuffer.indexOf(event.keyCode);
	if (index >= 0) {
		keybuffer.splice(index, 1);
		if (keyRepeatIndex >= index) {
			keyRepeatIndex--;
		}
	}
}

function onMyFocus(event) {
	keybuffer = [];
	keyRepeatIndex = 0;
	keyRepeatTimer = 0;
}

function onMyBlur(event) {
	keybuffer = [];
	keyRepeatIndex = 0;
	keyRepeatTimer = 0;
}

let mouseCoordX = 0;
let mouseCoordY = 0;

function setMouseCoord(e) {
	const coords = canvas.relMouseCoords(e);
	mouseCoordX = coords.x - xoffset;
	mouseCoordY = coords.y - yoffset;
	mouseCoordX = Math.floor(mouseCoordX / cellwidth);
	mouseCoordY = Math.floor(mouseCoordY / cellheight);
}

function mouseMove(event) {

	if (event.handled) {
		return;
	}

	if (levelEditorOpened) {
		setMouseCoord(event);
		if (dragging) {
			levelEditorClick(event, false);
		} else if (rightdragging) {
			levelEditorRightClick(event, false);
		}
		redraw();
	}

	event.handled = true;
	//window.console.log("showcoord ("+ canvas.width+","+canvas.height+") ("+x+","+y+")");
}

function mouseOut() {
	//  window.console.log("clear");
}

document.addEventListener('touchstart', onMouseDown, false);
document.addEventListener('touchmove', mouseMove, false);
document.addEventListener('touchend', onMouseUp, false);

document.addEventListener('mousedown', onMouseDown, false);
document.addEventListener('mouseup', onMouseUp, false);

document.addEventListener('keydown', onKeyDown, false);
document.addEventListener('keyup', onKeyUp, false);

window.addEventListener('focus', onMyFocus, false);
window.addEventListener('blur', onMyBlur, false);


function prevent(e) {
	if (e.preventDefault) e.preventDefault();
	if (e.stopImmediatePropagation) e.stopImmediatePropagation();
	if (e.stopPropagation) e.stopPropagation();
	e.returnValue = false;
	return false;
}

var gamepadKeys = []; // used to store keys held at previous frame

function pollGamepads() {
	function buttonCheck(buttons, i) {
		if(buttons.length <= i) {
			return false;
		}
		
		if(typeof(buttons[i]) == "object") {
			return buttons[i].pressed;
		}
	
		return buttons[i] == 1.0;
	}
	function axisCheck(axes, i, dir) {
		if(axes.length <= i) {
			return false;
		}
		
		return axes[i] * dir > 0.5;
	}

	var newGamepadKeys = [];

	function keyPressed(keycode) {
    	if(keybuffer.indexOf(keycode) === -1) {
    		keybuffer.splice(keyRepeatIndex, 0, keycode);
	    	keyRepeatTimer = 0;
	    	checkKey({keyCode: keycode}, true);
		}

		newGamepadKeys.splice(0, 0, keycode);
	}

	// clear any keys previously pressed but no longer held:
	function clear() {
		for(var k = 0; k < gamepadKeys.length; k++) {
			if(newGamepadKeys.indexOf(gamepadKeys[k]) >= 0) {
				continue;
			}

			var index = keybuffer.indexOf(gamepadKeys[k]);
			if(index >= 0) {
				keybuffer.splice(index, 1);
				if(keyRepeatIndex >= index) {
					keyRepeatIndex--;
				}
			}
		}

		gamepadKeys = newGamepadKeys;
	}

	var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);
	if(gamepads == null || gamepads.length == 0) {
		clear();
		return;
	}

	for(var i = 0; i < gamepads.length; i++) {
		var gamepad = gamepads[i];
		
		if(!gamepad || !gamepad.connected) {
			continue;
		}
		if(buttonCheck(gamepad.buttons, 3) // Y
			|| buttonCheck(gamepad.buttons, 4)) { // LB
			
			keyPressed(82); // restart
		}
		if(buttonCheck(gamepad.buttons, 1) // B
			|| axisCheck(gamepad.axes, 2, 1)) { // LT
			
			keyPressed(90); // undo
		}
		if(buttonCheck(gamepad.buttons, 2) // X
			|| buttonCheck(gamepad.buttons, 0) // A
			|| buttonCheck(gamepad.buttons, 5) // RB
			|| axisCheck(gamepad.axes, 1, 1)) { // RT
			
			keyPressed(88); // action
		}
		if(buttonCheck(gamepad.buttons, 7)||buttonCheck(gamepad.buttons, 8)) { // menu button
			keyPressed(27); // exit
		}
		if(buttonCheck(gamepad.buttons, 6)) { // change view button
			keyPressed(69); // edit
		}
		if(axisCheck(gamepad.axes, 1, -1) // up
			|| axisCheck(gamepad.axes, 7, -1) || buttonCheck(gamepad.buttons, 12)) { // D-pad up
			
			keyPressed(38); // up
		}
		if(axisCheck(gamepad.axes, 1, 1) // down
			|| axisCheck(gamepad.axes, 7, 1) || buttonCheck(gamepad.buttons, 13)) { // D-pad down
			
			keyPressed(40); // down
		}
		if(axisCheck(gamepad.axes, 0, -1) // left
			|| axisCheck(gamepad.axes, 6, -1) || buttonCheck(gamepad.buttons, 14)) { // D-pad left
			
			keyPressed(37); // left
		}
		if(axisCheck(gamepad.axes, 0, 1) // right
			|| axisCheck(gamepad.axes, 6, 1) || buttonCheck(gamepad.buttons, 15)) { // D-pad right
			
			keyPressed(39); // right
		}
	}

	clear();
}

function checkKey(e, justPressed) {
	ULBS();

	if (winning) {
		return;
	}
	if (e && ( (e.ctrlKey&&e.keyCode!==90) || e.metaKey || e.altKey)) {
		return;
	}

	let inputdir = -1;
	switch (e.keyCode) {
		case 65://a
		case 37: //left
			{
				inputdir = 1;
				break;
			}
		case 38: //up
		case 87: //w
			{
				inputdir = 0;
				break;
			}
		case 68://d
		case 39: //right
			{
				inputdir = 3;
				break;
			}
		case 83://s
		case 40: //down
			{

				inputdir = 2;
				break;
			}
		case 80://p
			{
				printLevel();
				break;
			}
		case 13://enter
		case 32://space
		case 67://c
		case 88://x
			{
				//            window.console.log("ACTION");
				if (justPressed && ignoreNotJustPressedAction) {
					ignoreNotJustPressedAction = false;
				}
				if (justPressed === false && ignoreNotJustPressedAction) {
					return;
				}
				if (norepeat_action === false || justPressed) {
					inputdir = 4;
				} else {
					return;
				}
				break;
			}
		case 85://u
		case 90://z
			{
				//undo
				if (textMode === false) {
					pushInput("undo");
					DoUndo(false, true);
					canvasResize(); // calls redraw
					return prevent(e);
				}
				break;
			}
		case 82://r
			{
				if (textMode === false) {
					if (justPressed) {
						pushInput("restart");
						DoRestart();
						canvasResize(); // calls redraw
						return prevent(e);
					}
				}
				break;
			}
		case 27://escape
			{
				if (titleScreen === false) {
					goToTitleScreen();
					tryPlayTitleSound();
					canvasResize();
					return prevent(e)
				}
				break;
			}
		case 69: {//e
			if (canOpenEditor) {
				if (justPressed) {
					if (titleScreen) {
						if (state.title === "EMPTY GAME") {
							compile(["loadFirstNonMessageLevel"]);
						} else {
							nextLevel();
						}
					}
					levelEditorOpened = !levelEditorOpened;
					if (levelEditorOpened === false) {
						printLevel();
					}
					restartTarget = backupLevel();
					canvasResize();
				}
				return prevent(e);
			}
			break;
		}
		case 48://0
		case 49://1
		case 50://2
		case 51://3
		case 52://4
		case 53://5
		case 54://6
		case 55://7
		case 56://8
		case 57://9
			{
				if (levelEditorOpened && justPressed) {
					let num = 9;
					if (e.keyCode >= 49) {
						num = e.keyCode - 49;
					}

					if (num < glyphImages.length) {
						glyphSelectedIndex = num;
					} else {
						consolePrint("Trying to select tile outside of range in level editor.", true)
					}

					canvasResize();
					return prevent(e);
				}
				break;
			}
		case 189://-
		case 109://numpad -		
			{
				if (levelEditorOpened && justPressed) {
					if (glyphSelectedIndex > 0) {
						glyphSelectedIndex--;
						canvasResize();
						return prevent(e);
					}
				}
				break;
			}
		case 187://+
		case 107://numpad +
			{
				if (levelEditorOpened && justPressed) {
					if (glyphSelectedIndex + 1 < glyphImages.length) {
						glyphSelectedIndex++;
						canvasResize();
						return prevent(e);
					}
				}
				break;
			}
	}
	if (throttle_movement && inputdir >= 0 && inputdir <= 3) {
		if (lastinput == inputdir && input_throttle_timer < repeatinterval) {
			return;
		} else {
			lastinput = inputdir;
			input_throttle_timer = 0;
		}
	}
	if (textMode) {
		if (state.levels.length === 0) {
			//do nothing
		} else if (titleScreen) {
			if (quittingTitleScreen === false) {
				if (titleMode === 0) {
					if (inputdir === 4 && justPressed) {
						if (titleSelected === false) {
							tryPlayStartGameSound();
							titleSelected = true;
							messageselected = false;
							timer = 0;
							quittingTitleScreen = true;
							generateTitleScreen();
							canvasResize();
							clearInputHistory();
						}
					}
				} else {
					if (inputdir == 4 && justPressed) {
						if (titleSelected === false) {
							tryPlayStartGameSound();
							titleSelected = true;
							messageselected = false;
							timer = 0;
							quittingTitleScreen = true;
							generateTitleScreen();
							redraw();
						}
					}
					else if (inputdir === 0 || inputdir === 2) {
						if (inputdir === 0) {
							titleSelection = 0;
						} else {
							titleSelection = 1;
						}
						generateTitleScreen();
						redraw();
					}
				}
			}
		} else {
			if (inputdir == 4 && justPressed) {
				if (unitTesting) {
					nextLevel();
					return;
				} else if (messageselected === false) {
					messageselected = true;
					timer = 0;
					quittingMessageScreen = true;
					tryPlayCloseMessageSound();
					titleScreen = false;
					drawMessageScreen();
				}
			}
		}
	} else {
		if (!againing && inputdir >= 0) {
			if (inputdir === 4 && ('noaction' in state.metadata)) {

			} else {
				pushInput(inputdir);
				if (processInput(inputdir)) {
					redraw();
				}
			}
		}
	}

	return prevent(e);
}

function update() {
	const iterative_generation = textMode && !unitTesting;
	tick_lazy_function_generation(iterative_generation);
	const lastframe = get_title_animation_frame();
	timer += deltatime;
	input_throttle_timer += deltatime;
	if (quittingTitleScreen) {
		const thisFrame = get_title_animation_frame();
		if ((timer / 1000 > 0.3) && WORKLIST_OBJECTS_TO_GENERATE_FUNCTIONS_FOR.length === 0) {
			quittingTitleScreen = false;
			nextLevel();
		} else if (thisFrame > lastframe) {
			generateTitleScreen();
			redraw();
		}
	}
	if (againing) {
		if (timer > againinterval && messagetext.length == 0) {
			if (processInput(-1)) {
				redraw();
				keyRepeatTimer = 0;
				autotick = 0;
			}
		}
	}
	if (quittingMessageScreen) {
		if (timer / 1000 > 0.15) {
			quittingMessageScreen = false;
			if (messagetext === "") {
				nextLevel();
			} else {
				messagetext = "";
				textMode = false;
				titleScreen = false;
				titleMode = (curlevel > 0 || curlevelTarget !== null) ? 1 : 0;
				titleSelected = false;
				ignoreNotJustPressedAction = true;
				titleSelection = 0;
				canvasResize();
				checkWin();
			}
		}
	}
	if (winning) {
		if (timer / 1000 > 0.5) {
			winning = false;
			nextLevel();
		}
	}
	
	pollGamepads();
	
	if (keybuffer.length > 0) {
		keyRepeatTimer += deltatime;
		const ticklength = throttle_movement ? repeatinterval : repeatinterval / (Math.sqrt(keybuffer.length));
		if (keyRepeatTimer > ticklength) {
			keyRepeatTimer = 0;
			keyRepeatIndex = (keyRepeatIndex + 1) % keybuffer.length;
			const key = keybuffer[keyRepeatIndex];
			checkKey({ keyCode: key }, false);
		}
	}

	if (autotickinterval > 0 && !textMode && !levelEditorOpened && !againing && !winning) {
		autotick += deltatime;
		if (autotick > autotickinterval) {
			autotick = 0;
			pushInput("tick");
			if (processInput(-1)) {
				redraw();
			}
		}
	}
}

let prevTimestamp;
// Lights, camera…function!
function loop(timestamp) {
	if (prevTimestamp !== undefined) {
		deltatime = timestamp - prevTimestamp
	}
	prevTimestamp = timestamp
	update();
	// requestAnimationFrame will call loop() at the 
	// browser's refresh rate (generally 60fps)
	// and will auto pause/unpause when the window is minimized
	window.requestAnimationFrame(loop);
}

window.requestAnimationFrame(loop);

</script>
<script>
'use strict';

/*
 * Add gesture support for mobile devices.
 */

window.Mobile = {};

//stolen from https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
Mobile.hasTouch = function () {
    var bool;
    if (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch) {
        bool = true;
    } else {
        /*
        //don't know what's happening with this, so commented it out
        var query = ['@media (',prefixes.join('touch-enabled),    ('),'heartz',')','{#modernizr{top:9px;position:absolute}}'].join('');
        testStyles(query, function( node ) {
          bool = node.offsetTop === 9;
        });*/
    }
    return bool;
}

Mobile.enable = function (force) {
    if (force || Mobile.hasTouch() && !Mobile._instance) {
        Mobile._instance = new Mobile.GestureHandler();
        Mobile._instance.bindEvents();
        Mobile._instance.bootstrap();
    }
    return Mobile._instance;
};

window.Mobile.GestureHandler = function () {
    this.initialize.apply(this, arguments);
};

Mobile.log = function (message) {
    var h1;
    h1 = document.getElementsByTagName('h1')[0];
    h1.innerHTML = "" + Math.random().toString().substring(4, 1) + "-" + message;
};

Mobile.debugDot = function (event) {
    var dot, body, style

    style = 'border-radius: 50px;' +
        'width: 5px;' +
        'height: 5px;' +
        'background: red;' +
        'position: absolute;' +
        'left: ' + event.touches[0].clientX + 'px;' +
        'top: ' + event.touches[0].clientY + 'px;';
    dot = document.createElement('div');
    dot.setAttribute('style', style);
    body = document.getElementsByTagName('body')[0];
    body.appendChild(dot);
};

(function (proto) {
    'use strict';

    // Minimum range to begin looking at the swipe direction, in pixels
    var SWIPE_THRESHOLD = 10;
    // Distance in pixels required to complete a swipe gesture.
    var SWIPE_DISTANCE = 50;
    // Time in milliseconds to complete the gesture.
    var SWIPE_TIMEOUT = 1000;
    // Time in milliseconds to repeat a motion if still holding down,
    // ... and not specified in state.metadata.key_repeat_interval.
    var DEFAULT_REPEAT_INTERVAL = 150;

    // Lookup table mapping action to keyCode.
    var CODE = {
        action: 88, // x
        left: 37, // left arrow
        right: 39, // right arrow
        up: 38, // up arrow
        down: 40, // down arrow
        undo: 85, // u
        restart: 82, // r
        quit: 27 // escape
    }

    var TAB_STRING = [
        '<div class="tab">',
        '  <div class="tab-affordance"></div>',
        '  <div class="tab-icon">',
        '    <div class="slice"></div>',
        '    <div class="slice"></div>',
        '  </div>',
        '</div>'
    ].join("\n");

    /** Bootstrap Methods **/

    proto.initialize = function () {
        this.firstPos = { x: 0, y: 0 };
        this.setTabAnimationRatio = this.setTabAnimationRatio.bind(this);
        this.setMenuAnimationRatio = this.setMenuAnimationRatio.bind(this);
        this.repeatTick = this.repeatTick.bind(this);
        this.isFocused = true;
    };

    // assign the element that will allow tapping to toggle focus.
    proto.setFocusElement = function (focusElement) {
        this.focusElement = focusElement;
        this.isFocused = false;
        this.buildFocusIndicator();
    };

    proto.bindEvents = function () {
        window.addEventListener('touchstart', this.onTouchStart.bind(this));
        window.addEventListener('touchend', this.onTouchEnd.bind(this));
        window.addEventListener('touchmove', this.onTouchMove.bind(this));
    };

    proto.bootstrap = function () {
        this.showTab();
        this.disableScrolling();
        if (!this.isAudioSupported()) {
            this.disableAudio();
        }
        this.disableSelection();
    };

    /** Event Handlers **/

    proto.onTouchStart = function (event) {
        if (this.isTouching) {
            return;
        }

        // Handle focus changes used in editor.
        this.handleFocusChange(event);
        if (!this.isFocused) {
            return;
        }

        if (event.target.tagName.toUpperCase() === 'A') {
            return;
        }
        this.isTouching = true;

        this.mayBeSwiping = true;
        this.gestured = false;

        this.swipeDirection = undefined;
        this.swipeDistance = 0;
        this.startTime = new Date().getTime();

        this.firstPos.x = event.touches[0].clientX;
        this.firstPos.y = event.touches[0].clientY;
    };

    proto.onTouchEnd = function (event) {
        if (!this.isFocused) {
            return;
        }
        if (!this.isTouching) {
            // If we're here, the menu event handlers had probably
            // canceled the touchstart event.
            return;
        }
        if (!this.gestured) {
            if (event.touches.length === 0 && event.target.id !== "unMuteButton" && event.target.id !== "muteButton") {
                this.handleTap();
            }
        }

        // The last finger to be removed from the screen lets us know
        // we aren't tracking anything.
        if (event.touches.length === 0) {
            this.isTouching = false;
            this.endRepeatWatcher();
        }
    };

    proto.onTouchMove = function (event) {
        if (!this.isFocused) {
            return;
        }
        if (levelEditorOpened) {
            return;
        }
        if (this.isSuccessfulSwipe()) {
            this.handleSwipe(this.swipeDirection, this.touchCount);
            this.gestured = true;
            this.mayBeSwiping = false;
            this.beginRepeatWatcher(event);
        } else if (this.mayBeSwiping) {
            this.swipeStep(event);
        } else if (this.isRepeating) {
            this.repeatStep(event);
        }

        prevent(event);
        return false;
    };

    proto.handleFocusChange = function (event) {
        if (!this.focusElement) {
            return;
        }

        this.isFocused = this.isTouchInsideFocusElement(event);
        this.setFocusIndicatorVisibility(this.isFocused);

        canvas.focus();
        editor.display.input.blur();
    };

    proto.isTouchInsideFocusElement = function (event) {
        var canvasPosition;

        if (!event.touches || !event.touches[0]) {
            return false;
        }
        canvasPosition = this.absoluteElementPosition(this.focusElement);

        if (event.touches[0].clientX < canvasPosition.left ||
            event.touches[0].clientY < canvasPosition.top) {
            return false;
        }

        if (event.touches[0].clientX > canvasPosition.left + this.focusElement.clientWidth ||
            event.touches[0].clientY > canvasPosition.top + this.focusElement.clientHeight) {
            return false;
        }

        return true;
    };

    proto.setFocusIndicatorVisibility = function (isVisible) {
        var visibility;

        visibility = 'visible';
        if (!isVisible) {
            visibility = 'hidden';
        }
        // this.focusIndicator.setAttribute('style', 'visibility: ' + visibility + ';');
    };

    proto.absoluteElementPosition = function (element) {
        var position, body;

        position = {
            top: element.offsetTop || 0,
            left: element.offsetLeft || 0
        };
        body = document.getElementsByTagName('body')[0];
        position.top -= body.scrollTop || 0;

        while (true) {
            element = element.offsetParent;
            if (!element) {
                break;
            }
            position.top += element.offsetTop || 0;
            position.left += element.offsetLeft || 0;
        }

        return position;
    };

    proto.beginRepeatWatcher = function (event) {
        var repeatIntervalMilliseconds;
        if (this.repeatInterval) {
            return;
        }
        this.isRepeating = true;
        repeatIntervalMilliseconds = state.metadata.key_repeat_interval * 1000;
        if (isNaN(repeatIntervalMilliseconds) || !repeatIntervalMilliseconds) {
            repeatIntervalMilliseconds = DEFAULT_REPEAT_INTERVAL;
        }
        this.repeatInterval = setInterval(this.repeatTick, repeatIntervalMilliseconds);
        this.recenter(event);
    };

    proto.endRepeatWatcher = function () {
        if (this.repeatInterval) {
            clearInterval(this.repeatInterval);
            delete this.repeatInterval;
            this.isRepeating = false;
        }
    };

    proto.repeatTick = function () {
        if (this.isTouching) {
            this.handleSwipe(this.direction, this.touchCount);
        }
    };

    // Capture the location to consider the gamepad center.
    proto.recenter = function (event) {
        this.firstPos.x = event.touches[0].clientX;
        this.firstPos.y = event.touches[0].clientY;
    }

    /** Detection Helper Methods **/

    proto.isSuccessfulSwipe = function () {
        var isSuccessful;

        if (this.mayBeSwiping &&
            this.swipeDirection !== undefined &&
            this.swipeDistance >= SWIPE_DISTANCE) {
            isSuccessful = true;
        }

        return isSuccessful;
    };

    // Examine the current state to see what direction they're swiping and
    // if the gesture can still be considered a swipe.
    proto.swipeStep = function (event) {
        var currentPos, distance, currentTime;
        var touchCount;

        if (!this.mayBeSwiping) {
            return;
        }

        currentPos = {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY
        };
        currentTime = new Date().getTime();
        touchCount = event.touches.length;

        this.swipeDistance = this.cardinalDistance(this.firstPos, currentPos);
        if (!this.swipeDirection) {
            if (this.swipeDistance > SWIPE_THRESHOLD) {
                // We've swiped far enough to decide what direction we're swiping in.
                this.swipeDirection = this.dominantDirection(this.firstPos, currentPos);
                this.touchCount = touchCount;
            }
        } else if (distance < SWIPE_DISTANCE) {
            // Now that they've committed to the swipe, look for misfires...

            direction = this.dominantDirection(this.firstPos, currentPos);
            // Cancel the swipe if the direction changes.
            if (direction !== this.swipeDirection) {
                this.mayBeSwiping = false;
            }
            // If they're changing touch count at this point, it's a misfire.
            if (touchCount < this.touchCount) {
                this.mayBeSwiping = false;
            }
        } else if (currentTime - this.startTime > SWIPE_TIMEOUT) {
            // Cancel the swipe if they took too long to finish.
            this.mayBeSwiping = false;
        }
    };

    proto.repeatStep = function (event) {
        var currentPos, distance, currentTime;
        var newDistance, direction;

        currentPos = {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY
        };

        newDistance = this.cardinalDistance(this.firstPos, currentPos);

        if (newDistance >= SWIPE_DISTANCE) {
            this.swipeDirection = this.dominantDirection(this.firstPos, currentPos);
            this.recenter(event);
        }
    };

    // Find the distance traveled by the swipe along compass directions.
    proto.cardinalDistance = function (firstPos, currentPos) {
        var xDist, yDist;

        xDist = Math.abs(firstPos.x - currentPos.x);
        yDist = Math.abs(firstPos.y - currentPos.y);

        return Math.max(xDist, yDist);
    };

    // Decide which direction the touch has moved farthest.
    proto.dominantDirection = function (firstPos, currentPos) {
        var dx, dy;
        var dominantAxis, dominantDirection;

        dx = currentPos.x - firstPos.x;
        dy = currentPos.y - firstPos.y;

        dominantAxis = 'x';
        if (Math.abs(dy) > Math.abs(dx)) {
            dominantAxis = 'y';
        }

        if (dominantAxis === 'x') {
            if (dx > 0) {
                dominantDirection = 'right';
            } else {
                dominantDirection = 'left';
            }
        } else {
            if (dy > 0) {
                dominantDirection = 'down';
            } else {
                dominantDirection = 'up';
            }
        }

        return dominantDirection;
    };

    /** Action Methods **/

    // Method to be called when we've detected a swipe and some action
    // is called for.
    proto.handleSwipe = function (direction, touchCount) {
        if (touchCount === 1) {
            this.emitKeydown(this.swipeDirection);
        } else if (touchCount > 1) {
            // Since this was a multitouch gesture, open the menu.
            this.toggleMenu();
        }
    };

    proto.handleTap = function () {
        this.emitKeydown('action');
    };

    // Fake out keypresses to acheive the desired effect.
    proto.emitKeydown = function (input) {
        var event;

        event = { keyCode: CODE[input] };

        this.fakeCanvasFocus();
        // Press, then release key.
        onKeyDown(event);
        onKeyUp(event);
    };

    proto.fakeCanvasFocus = function () {
        var canvas;

        canvas = document.getElementById('gameCanvas');
        onMouseDown({
            button: 0,
            target: canvas
        });
    };

    proto.toggleMenu = function () {
        if (this.isMenuVisible) {
            this.hideMenu();
        } else {
            this.showMenu();
        }
    };

    proto.showMenu = function () {
        if (!this.menuElem) {
            this.buildMenu();
        }
        this.getAnimatables().menu.animateUp();
        this.isMenuVisible = true;
        this.hideTab();
    };

    proto.hideMenu = function () {
        if (this.menuElem) {
            this.getAnimatables().menu.animateDown();
        }
        this.isMenuVisible = false;
        this.showTab();
    };

    proto.getAnimatables = function () {
        var self = this;
        if (!this._animatables) {
            this._animatables = {
                tab: Animatable('tab', 0.1, self.setTabAnimationRatio),
                menu: Animatable('menu', 0.1, self.setMenuAnimationRatio)
            }
        }
        return this._animatables;
    };

    proto.showTab = function () {
        if (!this.tabElem) {
            this.buildTab();
        }
        this.getAnimatables().tab.animateDown();
    };

    proto.hideTab = function () {
        if (this.tabElem) {
            this.tabElem.setAttribute('style', 'display: none;');
        }
        this.getAnimatables().tab.animateUp();
    };

    proto.buildTab = function () {
        var self = this;
        var tempElem, body;
        var openCallback;
        var tabElem;
        var assemblyElem;

        tempElem = document.createElement('div');
        tempElem.innerHTML = TAB_STRING;
        assemblyElem = tempElem.children[0];

        openCallback = function (event) {
            event.stopPropagation();
            self.showMenu();
        };
        this.tabAffordance = assemblyElem.getElementsByClassName('tab-affordance')[0];
        this.tabElem = assemblyElem.getElementsByClassName('tab-icon')[0];

        //the reason I'm adding all these empty click events is on safari to disable double-tap to zoom (also needs some other css settings. cf https://github.com/increpare/PuzzleScript/issues/599 SMGDH)
        this.tabAffordance.addEventListener('touchstart', openCallback);
        this.tabAffordance.addEventListener("click", event => { });
        this.tabElem.addEventListener('touchstart', openCallback);
        this.tabElem.addEventListener("click", event => { });

        body = document.getElementsByTagName('body')[0];
        body.appendChild(assemblyElem);
    };

    proto.buildMenu = function () {
        var self = this;
        var tempElem, body;
        var undo, restart, quit;
        var closeTab;
        var closeCallback;

        tempElem = document.createElement('div');
        tempElem.innerHTML = this.buildMenuString(state);
        this.menuElem = tempElem.children[0];
        this.closeElem = this.menuElem.getElementsByClassName('close')[0];

        closeCallback = function (event) {
            event.stopPropagation();
            self.hideMenu();
        };
        this.closeAffordance = this.menuElem.getElementsByClassName('close-affordance')[0];
        closeTab = this.menuElem.getElementsByClassName('close')[0];
        this.closeAffordance.addEventListener('touchstart', closeCallback);
        this.closeAffordance.addEventListener("click", event => { });
        closeTab.addEventListener('touchstart', closeCallback);
        closeTab.addEventListener("click", event => { });

        undo = this.menuElem.getElementsByClassName('undo')[0];
        if (undo) {
            undo.addEventListener('touchstart', function (event) {
                event.stopPropagation();
                self.emitKeydown('undo');
            });
            undo.addEventListener("click", event => { });
        }
        restart = this.menuElem.getElementsByClassName('restart')[0];
        if (restart) {
            restart.addEventListener('touchstart', function (event) {
                event.stopPropagation();
                self.emitKeydown('restart');
            });
            restart.addEventListener("click", event => { });
        }

        quit = this.menuElem.getElementsByClassName('quit')[0];
        quit.addEventListener('touchstart', function (event) {
            event.stopPropagation();
            self.emitKeydown('quit');
        });
        quit.addEventListener("click", event => { });

        body = document.getElementsByTagName('body')[0];
        body.appendChild(this.menuElem);
    };

    proto.buildMenuString = function (state) {
        // Template for the menu.
        var itemCount, menuLines;
        var noUndo, noRestart;

        noUndo = state.metadata.noundo;
        noRestart = state.metadata.norestart;

        itemCount = 3;
        if (noUndo) {
            itemCount -= 1;
        }
        if (noRestart) {
            itemCount -= 1;
        }

        menuLines = [
            '<div class="mobile-menu item-count-' + itemCount + '">',
            '  <div class="close-affordance"></div>',
            '  <div class="close">',
            '    <div class="slice"></div>',
            '    <div class="slice"></div>',
            '  </div>'
        ];

        if (!noUndo) {
            menuLines.push('  <div class="undo button">Undo</div>');
        }
        if (!noRestart) {
            menuLines.push('  <div class="restart button">Restart</div>');
        }
        menuLines = menuLines.concat([
            '  <div class="quit button">Quit to Menu</div>',
            '  <div class="clear"></div>',
            '</div>'
        ]);

        return menuLines.join("\n");
    };

    proto.buildFocusIndicator = function () {
        var focusElementParent;
        this.focusIndicator = document.createElement('DIV');
        this.focusIndicator.setAttribute('class', 'tapFocusIndicator');
        this.focusIndicator.setAttribute('style', 'visibility: hidden;');

        focusElementParent = this.focusElement.parentNode;
        focusElementParent.appendChild(this.focusIndicator);
    };

    proto.setTabAnimationRatio = function (ratio) {
        var LEFT = 18;
        var RIGHT = 48 + 18;
        var size, opacityString;
        var style;

        // Round away any exponents that might appear.
        ratio = Math.round((ratio) * 1000) / 1000;
        if (ratio >= 0.999) {
            this.tabAffordance.setAttribute('style', 'display: none;');
        } else {
            this.tabAffordance.setAttribute('style', 'display: block;');
        }
        size = RIGHT * ratio + LEFT * (1 - ratio);
        opacityString = 'opacity: ' + (1 - ratio) + ';';
        style = opacityString + ' ' +
            'width: ' + size + 'px;';
        this.tabElem.setAttribute('style', style);
    };

    proto.setMenuAnimationRatio = function (ratio) {
        var LEFT = -48 - 18;
        var RIGHT = -18;
        var size, opacityString;
        var style;

        // Round away any exponents that might appear.
        ratio = Math.round((ratio) * 1000) / 1000;

        size = RIGHT * ratio + LEFT * (1 - ratio);
        opacityString = 'opacity: ' + ratio + ';';
        style = 'left: ' + (size - 4) + 'px; ' +
            opacityString + ' ' +
            'width: ' + (-size) + 'px;';
        ratio = Math.round((ratio) * 1000) / 1000;

        if (ratio <= 0.001) {
            this.closeAffordance.setAttribute('style', 'display: none;');
            opacityString = "display:none;"
        } else {
            this.closeAffordance.setAttribute('style', 'display: block;');
        }

        this.closeElem.setAttribute('style', style);

        this.menuElem.setAttribute('style', opacityString);
    };

    proto.disableScrolling = function () {
        var style = {
            height: "100%",
            overflow: "hidden",
            position: "fixed",
            width: "100%",
            margin: 0
        }

        var styleString = "";
        for (var key in style) {
            styleString += key + ": " + style[key] + "; ";
        }

        document.body.setAttribute('style', styleString)
    }

    /** Audio Methods **/

    proto.disableAudio = function () {
        // Overwrite the playseed function to disable it.
        window.playSeed = function () { };
    };

    proto.isAudioSupported = function () {
        var isAudioSupported = true;

        if (typeof webkitAudioContext !== 'undefined') {
            // We may be on Mobile Safari, which throws up
            // 'Operation not Supported' alerts when we attempt to
            // play Audio elements with "data:audio/wav;base64"
            // encoded HTML5 Audio elements.
            //
            // Switching to MP3 encoded audio may be the way we have
            // to go to get Audio working on mobile devices.
            //
            // e.g. https://github.com/rioleo/webaudio-api-synthesizer
            isAudioSupported = false;
        }

        return isAudioSupported;
    };

    /** Other HTML5 Stuff **/

    proto.disableSelection = function () {
        var body;
        body = document.getElementsByTagName('body')[0];
        body.setAttribute('class', body.getAttribute('class') + ' disable-select');
    };

}(window.Mobile.GestureHandler.prototype));

window.Animator = function () {
    this.initialize.apply(this, arguments);
};

(function (proto) {
    proto.initialize = function () {
        this._animations = {};
        this.tick = this.tick.bind(this);
    };

    proto.animate = function (key, tick) {
        this._animations[key] = tick;
        this.wakeup();
    };

    proto.wakeup = function () {
        if (this._isAnimating) {
            return;
        }
        this._isAnimating = true;
        this.tick();
    };

    proto.tick = function () {
        var key;
        var isFinished, allFinished;
        var toRemove, index;

        toRemove = [];
        allFinished = true;
        for (key in this._animations) {
            if (!this._animations.hasOwnProperty(key)) {
                return;
            }
            isFinished = this._animations[key]();
            if (!isFinished) {
                allFinished = false;
            } else {
                toRemove.push(key);
            }
        }

        if (!allFinished) {
            requestAnimationFrame(this.tick);
        } else {
            for (index = 0; index < toRemove.length; toRemove++) {
                delete this._isAnimating[toRemove[index]];
            }
            this._isAnimating = false;
        }
    };

}(window.Animator.prototype));

window.Animator.getInstance = function () {
    if (!window.Animator._instance) {
        window.Animator._instance = new window.Animator();
    }
    return window.Animator._instance;
};

function Animatable(key, increment, update) {
    var ratio;
    var handles;

    handles = {
        animateUp: function () {
            Animator.getInstance().animate(key, tickUp);
        },
        animateDown: function () {
            Animator.getInstance().animate(key, tickDown);
        }
    };

    ratio = 0;

    function tickUp() {
        var isFinished;
        ratio += increment;
        if (ratio >= 1.0) {
            isFinished = true;
            ratio = 1;
        }
        update(ratio);
        return isFinished;
    };

    function tickDown() {
        var isFinished;
        ratio -= increment;
        if (ratio <= 0.0) {
            isFinished = true;
            ratio = 0;
        }
        update(ratio);
        return isFinished;
    };

    return handles;
};


// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel

// MIT license

(function () {
    'use strict';

    var VENDORS = ['ms', 'moz', 'webkit', 'o'];
    var index, lastTime;

    for (index = 0; index < VENDORS.length && !window.requestAnimationFrame; index++) {
        window.requestAnimationFrame = window[VENDORS[index] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[VENDORS[index] + 'CancelAnimationFrame'];
        if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = window[VENDORS[index] + 'CancelRequestAnimationFrame'];
        }
    }

    if (!window.requestAnimationFrame) {
        lastTime = 0;
        window.requestAnimationFrame = function (callback, element) {
            var currTime, timeToCall, id;

            currTime = new Date().getTime();
            timeToCall = Math.max(0, 16 - (currTime - lastTime));
            id = window.setTimeout(function () {
                callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;

            return id;
        };
    }

    if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
    }

    Mobile.enable();
}());

</script>

<div style = "z-index: 2; background: transparent; position: absolute; top: 0.5em; right: 1em;">
    <img alt="mute" id="muteButton" width=32px height=32px onClick="muteAudio()" style="display:none" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABl0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC4xOdTWsmQAAAIGSURBVFhH3ZchcsJAGIURiApEBbIH6BEqOQASWYHoESoQFcwgOAaiEsEBKip6BERlBQJRwQEqtu/tvj+TLMnAJpntTL+ZP/De7p/9k102YUCcc0tEbpbx4MHIAMcKQ2LM4ktmOCYH9gXIawXzQasLYGKnAphryErC53VJLiPvhNgjtog54tZ3bgDt7QpgTkyD/42Y+aQa2CG5APYvMdGnFTBC3COeEG8IY4M4uxtsSCqAfQ1ZhSdZATangdNCvhCVImheVQC6FFdKZHtkeQ8fB8QOsUCM5N0hPhBkQ8+gEQ5BXLUb+swSsu0cZXjFE/kswu7ElB6hCAeJS/isCDXZOcaIKeKdHvhBPKiN00F4l+zu1BaQtKkop1Ic5BCx8g3OfSJu5Fthj9LnBfB7Ckqzc/Dq1oihtA34LP0SpHuV7r0AYyXN6SC7SO+ley9gFpQ7SHNNkFifpP9fAcZaOvsUNC3ChbQtwq30eQGg88+QwLKNjRuS/e6toLl0bQGNsF+MmuwcdRuR7Ya2EfEJ6Z8JFOEQRK6tuHg8U4TDBdClr4eRn3uDRjhcCfsasgpPsgLs8uP4iBiryUMzqQDC/iXiFxJbA1zttg4IX9EqgxM2JBdAmBPT4Pf/SmYwr4y8PC+lBnMNWUn4vLbJBvNBtz8m4E//mtkGlK0IjhWG1Jj8EnRWMPhg8AvjeqPLyfe3igAAAABJRU5ErkJggg==" />
    <img alt="unmute" id="unMuteButton" width=32px height=32px onClick="unMuteAudio()" style="display:none" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTnU1rJkAAABqElEQVRYR72XW3LDMAwDc7QerTdPRWjBoW1aedXZGUYUAIlqP9LpLbjf77+jvs3vfvgUvkDMmiPHzGxg9HTXEjNjsB6A0Nar+MxYg+UPFoH5ccLCauE+3Wmqvke+Pk5YWAl3sJuXGiSx3wfSOsMsrKRm4i6DJJAEktB+L1YW1oG4xyAJJIGUSOsMs7A2xB0GSSAJpA3Sz8xgYYnh/8R5g+ZKFG6Q9yAQ9dS3JEcEkkBqkb8K2X8EcYEkkE5RxkH6rkz7VT10uu3wwcbrcOipB+hEg62ZmlR9hbL1wEkJndgRMpVgif1+j3yH6LsSOtGALZAE0rUPwBJICfJ1D0A2ylamfDxXke8QfVfCGdak6pXpNkZBvkP0XeUl3hvkFiKfP8CwT5BPIfavD0iQBNJhEPJnDzCjr6Q31sMfI4P0/gPM6BP20ivTnSClxrZFvkP0WQ4YCQuImfzNYLfId4i+VqL0ExDfgNUi3yF6V6LkC3AsQW6R7xB9rZeHmzhrkFrkO0R/qHcZZ4Plv3sROARHv1mvImbG4GxixbucmDVHMjOauf8qY/jt9gdOODPsYZA1BAAAAABJRU5ErkJggg==" />
</div>

<script>const sourceCode="__GAMEDAT__";compile(["restart"],sourceCode);</script>
</body>
</html>
