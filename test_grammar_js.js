function id(x) {
  return x[0]
}

/* eslint-disable */
// Disable all linting because the file is autogenerated (& out of our control)
import * as ast from "./astTypes"
const debugBlackList = new Set([])
const debugWhiteList = new Set([])

const toDebug = (name, fn) => {
  if (process.env.NODE_ENV == "debug-parser" || debugWhiteList.has(name)) {
    // Skip debug mode for any items on the blacklist
    if (debugBlackList.has(name)) {
      return null
    }
    // return either the custom function provided, or the default one for debugging
    return (
      fn ||
      function(args) {
        return { type: name, args: args }
      }
    )
  } else {
    return null // use the non-debug function
  }
}

const nuller = a => null
// const debugRule = (msg) => (a) => { debugger; console.log(msg, a); return a }
const concatChars = ([a]) => a.join("")
const extractFirst = ary =>
  ary.map(subArray => {
    if (subArray.length !== 1) {
      throw new Error(
        `BUG: Expected items to only have one element (usually used in listOf[...])`
      )
    } else {
      return subArray[0]
    }
  })
const extractSecond = ary =>
  ary.map(subArray => {
    if (subArray.length < 2) {
      throw new Error(
        `BUG: Expected items to have at least 2 elements (usually used in listOf[...])`
      )
    } else {
      return subArray[1]
    }
  })
const extractThird = ary =>
  ary.map(subArray => {
    if (subArray.length < 3) {
      throw new Error(
        `BUG: Expected items to have at least 3 elements (usually used in listOf[...])`
      )
    } else {
      return subArray[2]
    }
  })

function nonemptyListOf([first, rest] /*[T, T[][]]*/) {
  const f = first
  const r = rest
  return [f].concat(r.map(([_1, child]) => child))
}
const upperId = ([id]) => id.toUpperCase()

const TILE_MODIFIERS = new Set([
  "...", // This one isn't a modifier but we do not allow it so that we match ellipsis rules in a different rule
  "AGAIN", // This is another hack. Some people write `[]->[AGAIN]` rather than `[]->[]AGAIN`
  "DEBUGGER", // Another hack. Ensure that this is not accidentally used as a tile name
  "NO",
  "LEFT",
  "RIGHT",
  "UP",
  "DOWN",
  "RANDOMDIR",
  "RANDOM",
  "STATIONARY",
  "MOVING",
  "ACTION",
  "VERTICAL",
  "HORIZONTAL",
  "PERPENDICULAR",
  "PARALLEL",
  "ORTHOGONAL",
  "^",
  "<",
  ">",
  "V"
])

alias_0 =
  toDebug("Section") ||
  function([
    _0,
    _1,
    title,
    _2,
    metadata,
    sprites,
    legendItems,
    sounds,
    collisionLayers,
    rules,
    winConditions,
    levelsAsSingleArray
  ]) {
    const levels = []
    let currentMapLevel = null
    for (const levelRowItem of levelsAsSingleArray || []) {
      switch (levelRowItem.type) {
        case "LEVEL_ROW":
          if (currentMapLevel) {
            currentMapLevel.push(levelRowItem)
          } else {
            currentMapLevel = [levelRowItem]
          }
          break
        case "LEVEL_MESSAGE":
          if (currentMapLevel) {
            levels.push({
              type: "LEVEL_MAP",
              cells: currentMapLevel.map(row => row.cells),
              _sourceOffset: currentMapLevel[0]._sourceOffset
            })
            currentMapLevel = null
          }
          levels.push(levelRowItem)
          break
        case "LEVEL_SEPARATOR":
          if (currentMapLevel) {
            levels.push({
              type: "LEVEL_MAP",
              cells: currentMapLevel.map(row => row.cells),
              _sourceOffset: currentMapLevel[0]._sourceOffset
            })
            currentMapLevel = null
          }
          break
        default:
          throw new Error(
            `BUG: Unsupported level row type "${levelRowItem.type}"`
          )
      }
    }
    // add the last level
    if (currentMapLevel) {
      levels.push({
        type: "LEVEL_MAP",
        cells: currentMapLevel.map(row => row.cells),
        _sourceOffset: currentMapLevel[0]._sourceOffset
      })
      currentMapLevel = null
    }
    return {
      title: title.value,
      metadata: metadata.value,
      sprites: sprites || [],
      legendItems: legendItems || [],
      sounds: sounds || [],
      collisionLayers: collisionLayers || [],
      rules: rules || [],
      winConditions: winConditions || [],
      levels: levels
    }
  }
alias_1 = toDebug("whitespace") || nuller
alias_2 = toDebug("whitespace") || nuller
alias_3 = toDebug("multiLineComment") || nuller
alias_4 = nuller
alias_5 = nuller
alias_6 = id
alias_7 = id
alias_8 = id
alias_9 = ([chars]) => parseInt(chars.join(""), 10)
alias_10 = toDebug("WORD") || concatChars
alias_11 =
  toDebug("WORDS") ||
  function([a]) {
    return extractFirst(a).join(" ")
  }
alias_12 = toDebug("lineTerminator") || nuller
alias_13 = ([firstDigit, rest]) => {
  if (rest) {
    return Number.parseFloat(`${firstDigit[0]}.${rest[1].join("")}`)
  } else {
    return Number.parseInt(firstDigit[0], 10)
  }
}
alias_14 = ([_1, digits]) => {
  return Number.parseInt(digits.join(""), 10)
}
alias_15 = (a, _sourceOffset) => {
  return { type: ast.COLOR_TYPE.HEX8, value: a.join(""), _sourceOffset }
}
alias_16 = (a, _sourceOffset) => {
  return { type: ast.COLOR_TYPE.HEX6, value: a.join(""), _sourceOffset }
}
alias_17 = ([hash, c1, c2, c3, c4], _sourceOffset) => {
  return {
    type: ast.COLOR_TYPE.HEX8,
    value: `#${c1}${c1}${c2}${c2}${c3}${c3}${c4}${c4}`,
    _sourceOffset
  }
}
alias_18 = ([hash, c1, c2, c3], _sourceOffset) => {
  return {
    type: ast.COLOR_TYPE.HEX6,
    value: `#${c1}${c1}${c2}${c2}${c3}${c3}`,
    _sourceOffset
  }
}
alias_19 = id
alias_20 = id
alias_21 = id
alias_22 = id
alias_23 = id
alias_24 =
  toDebug("COLOR_NAME") ||
  function([first, rest], _sourceOffset) {
    return {
      type: ast.COLOR_TYPE.NAME,
      value: [first].concat(rest).join(""),
      _sourceOffset
    }
  }
alias_25 = concatChars
alias_26 = ([a], offset, reject) => {
  const str = a.join("")
  if (TILE_MODIFIERS.has(str.toUpperCase())) {
    return reject
  } else {
    return str
  }
}
alias_27 = concatChars
alias_28 = id
alias_29 = id
alias_30 = id
alias_31 = id
alias_32 = upperId
alias_33 = upperId
alias_34 = upperId
alias_35 = upperId
alias_36 = upperId
alias_37 = upperId
alias_38 = upperId
alias_39 = upperId
alias_40 = upperId
alias_41 = upperId
alias_42 = upperId
alias_43 = upperId
alias_44 = upperId
alias_45 = upperId
alias_46 = upperId
alias_47 = upperId
alias_48 = upperId
alias_49 = upperId
alias_50 = upperId
alias_51 = upperId
alias_52 = upperId
alias_53 = upperId
alias_54 = upperId
alias_55 = upperId
alias_56 = upperId
alias_57 = upperId
alias_58 = upperId
alias_59 = upperId
alias_60 = upperId
alias_61 = upperId
alias_62 = upperId
alias_63 = upperId
alias_64 = upperId
alias_65 = upperId
alias_66 = upperId
alias_67 = upperId
alias_68 = upperId
alias_69 = upperId
alias_70 = upperId
alias_71 = upperId
alias_72 = upperId
alias_73 = upperId
alias_74 = upperId
alias_75 = upperId
alias_76 = upperId
alias_77 = upperId
alias_78 = upperId
alias_79 = upperId
alias_80 = upperId
alias_81 = upperId
alias_82 = upperId
alias_83 = upperId
alias_84 = upperId
alias_85 = upperId
alias_86 = upperId
alias_87 = upperId
alias_88 = upperId
alias_89 = (a, _sourceOffset) => {
  return a.join("")
}
alias_90 = upperId
alias_91 = upperId
alias_92 = upperId
alias_93 = upperId
alias_94 = upperId
alias_95 = upperId
alias_96 = upperId
alias_97 = upperId
alias_98 = upperId
alias_99 = upperId
alias_100 = upperId
alias_101 = upperId
alias_102 = upperId
alias_103 = upperId
alias_104 = upperId
alias_105 = upperId
alias_106 = upperId
alias_107 = upperId
alias_108 = upperId
alias_109 = upperId
alias_110 = upperId
alias_111 = upperId
alias_112 = upperId
alias_113 = upperId
alias_114 = upperId
alias_115 = upperId
alias_116 = upperId
alias_117 = upperId
alias_118 = upperId
alias_119 = upperId
alias_120 = upperId
alias_121 = upperId
alias_122 = upperId
alias_123 = upperId
alias_124 = upperId
alias_125 = upperId
alias_126 = upperId
alias_127 = upperId
alias_128 = upperId
alias_129 = upperId
alias_130 = upperId
alias_131 = upperId
alias_132 = upperId
alias_133 = upperId
alias_134 = upperId
alias_135 = upperId
alias_136 = upperId
alias_137 = upperId
alias_138 = upperId
alias_139 = upperId
alias_140 = upperId
alias_141 = ([_1, _2, value], _sourceOffset) => {
  return { type: "TITLE", value, _sourceOffset }
}
alias_142 = ([vals]) => {
  return { type: "METADATA", value: extractSecond(vals) }
}
alias_143 = ([_1, _2, value], _sourceOffset) => {
  return { type: "AUTHOR", value, _sourceOffset }
}
alias_144 = ([_1, _2, value], _sourceOffset) => {
  return { type: "HOMEPAGE", value, _sourceOffset }
}
alias_145 = ([_1, _2, value], _sourceOffset) => {
  return { type: "YOUTUBE", value, _sourceOffset }
}
alias_146 = ([_1, _2, value], _sourceOffset) => {
  return { type: "ZOOMSCREEN", value, _sourceOffset }
}
alias_147 = ([_1, _2, value], _sourceOffset) => {
  return { type: "FLICKSCREEN", value, _sourceOffset }
}
alias_148 = ([_1, _2, value], _sourceOffset) => {
  return { type: "REQUIRE_PLAYER_MOVEMENT", value: !!value, _sourceOffset }
}
alias_149 = ([_1, _2, value], _sourceOffset) => {
  return { type: "RUN_RULES_ON_LEVEL_START", value: true, _sourceOffset }
}
alias_150 = ([_1, _2, value], _sourceOffset) => {
  return { type: "COLOR_PALETTE", value, _sourceOffset }
}
alias_151 = ([_1, _2, value], _sourceOffset) => {
  return { type: "BACKGROUND_COLOR", value, _sourceOffset }
}
alias_152 = ([_1, _2, value], _sourceOffset) => {
  return { type: "TEXT_COLOR", value, _sourceOffset }
}
alias_153 = ([_1, _2, value], _sourceOffset) => {
  return { type: "REALTIME_INTERVAL", value, _sourceOffset }
}
alias_154 = ([_1, _2, value], _sourceOffset) => {
  return { type: "KEY_REPEAT_INTERVAL", value, _sourceOffset }
}
alias_155 = ([_1, _2, value], _sourceOffset) => {
  return { type: "AGAIN_INTERVAL", value, _sourceOffset }
}
alias_156 = () => {
  return { type: "NOACTION", value: true }
}
alias_157 = () => {
  return { type: "NOUNDO", value: true }
}
alias_158 = () => {
  return { type: "NOREPEAT_ACTION", value: true }
}
alias_159 = () => {
  return { type: "SCANLINE", value: true }
}
alias_160 = () => {
  return { type: "THROTTLE_MOVEMENT", value: true }
}
alias_161 = () => {
  return { type: "NORESTART", value: true }
}
alias_162 = () => {
  return { type: "VERBOSE_LOGGING", value: true }
}
alias_163 = ([width, _1, height]) => {
  return { type: "WIDTH_AND_HEIGHT", width, height }
}
alias_164 = id
alias_165 = id
alias_166 =
  toDebug("SpriteNoPixels") ||
  function([_0, name, mapCharOpt, _2, _3, colors, _5], _sourceOffset) {
    return {
      type: ast.SPRITE_TYPE.NO_PIXELS,
      name: name,
      mapChar: mapCharOpt ? mapCharOpt[1] : null,
      colors,
      _sourceOffset
    }
  }
alias_167 =
  toDebug("SpritePixels") ||
  function(
    [_0, name, mapCharOpt, _2, _3, colors, _5, pixels, _7],
    _sourceOffset
  ) {
    return {
      type: ast.SPRITE_TYPE.WITH_PIXELS,
      name: name,
      mapChar: mapCharOpt ? mapCharOpt[1] : null,
      colors,
      pixels,
      _sourceOffset
    }
  }
alias_168 = ([a]) => extractFirst(a)
alias_169 = ([a, b]) => extractFirst(a.concat(b))
alias_170 = id
alias_171 =
  toDebug("pixelRow", function([_0, entries, _2]) {
    return { type: "PIXEL_ROW", entries: entries }
  }) ||
  function([_0, entries, _2]) {
    return entries
  }
alias_172 = id
alias_173 = id
alias_174 = id
alias_175 = ([r1, r2, r3, r4, rest]) => [r1, r2, r3, r4].concat(rest)
alias_176 = id
alias_177 = id
alias_178 = id
alias_179 =
  toDebug("LegendTileSimple") ||
  function([_0, name, _2, _3, _4, tile, _6, _7], _sourceOffset) {
    return { type: ast.TILE_TYPE.SIMPLE, name, tile, _sourceOffset }
  }
alias_180 =
  toDebug("LegendTileAnd") ||
  function([_0, name, _2, _3, _4, tiles, _6, _7], _sourceOffset) {
    return {
      type: ast.TILE_TYPE.AND,
      name,
      tiles: extractFirst(tiles),
      _sourceOffset
    }
  }
alias_181 =
  toDebug("LegendTileOr") ||
  function([_0, name, _2, _3, _4, tiles, _6, _7], _sourceOffset) {
    return {
      type: ast.TILE_TYPE.OR,
      name,
      tiles: extractFirst(tiles),
      _sourceOffset
    }
  }
alias_182 = toDebug("LegendVarNameDefn") || id
alias_183 = toDebug("LookupLegendVarName") || id
alias_184 = ([_0, sound, _2]) => sound
alias_185 = id
alias_186 = id
alias_187 = id
alias_188 = id
alias_189 = id
alias_190 = upperId
alias_191 = upperId
alias_192 = upperId
alias_193 = upperId
alias_194 = upperId
alias_195 = upperId
alias_196 = upperId
alias_197 = upperId
alias_198 = upperId
alias_199 = ([when, _1, soundCode], _sourceOffset) => {
  return { type: ast.SOUND_TYPE.WHEN, when, soundCode, _sourceOffset }
}
alias_200 = ([soundEffect, _1, soundCode], _sourceOffset) => {
  return { type: ast.SOUND_TYPE.SFX, soundEffect, soundCode, _sourceOffset }
}
alias_201 = ([sprite, _1, _2, _3, direction, _5, soundCode], _sourceOffset) => {
  return {
    type: ast.SOUND_TYPE.SPRITE_DIRECTION,
    sprite,
    direction,
    soundCode,
    _sourceOffset
  }
}
alias_202 = ([sprite, _1, _2, _3, soundCode], _sourceOffset) => {
  return { type: ast.SOUND_TYPE.SPRITE_MOVE, sprite, soundCode, _sourceOffset }
}
alias_203 = ([sprite, _1, eventEnum, _3, soundCode], _sourceOffset) => {
  return {
    type: ast.SOUND_TYPE.SPRITE_EVENT,
    sprite,
    eventEnum,
    soundCode,
    _sourceOffset
  }
}
alias_204 = upperId
alias_205 = upperId
alias_206 = upperId
alias_207 = upperId
alias_208 = upperId
alias_209 = upperId
alias_210 = upperId
alias_211 = upperId
alias_212 = upperId
alias_213 = upperId
alias_214 =
  toDebug("CollisionLayerItem") ||
  function([_0, spriteNames, _2], _sourceOffset) {
    return {
      type: "COLLISION_LAYER",
      tiles: extractFirst(spriteNames),
      _sourceOffset
    }
  }
alias_215 = id
alias_216 = id
alias_217 = id
alias_218 = id
alias_219 = id
alias_220 =
  toDebug("RuleWithoutMessage") ||
  function(
    [_0, modifiers, conditionBrackets, _2, _3, actionBrackets, commands, _6],
    _sourceOffset
  ) {
    const directions = modifiers.filter(
      m => ["RANDOM", "LATE", "RIGID"].indexOf(m) < 0
    )
    const isRandom = modifiers.indexOf("RANDOM") >= 0
    const isLate = modifiers.indexOf("LATE") >= 0
    const isRigid = modifiers.indexOf("RIGID") >= 0
    return {
      type: ast.RULE_TYPE.SIMPLE,
      directions,
      isRandom,
      isLate,
      isRigid,
      conditions: extractFirst(conditionBrackets),
      actions: extractFirst(actionBrackets),
      commands: extractSecond(commands),
      _sourceOffset
    }
  }
alias_221 =
  toDebug("RuleWithoutMessage") ||
  function(
    [
      _0,
      modifiers,
      conditionBrackets,
      _2,
      _3,
      actionBrackets,
      commands,
      _6,
      message,
      _7
    ],
    _sourceOffset
  ) {
    const directions = modifiers.filter(
      m => ["RANDOM", "LATE", "RIGID"].indexOf(m) < 0
    )
    const isRandom = modifiers.indexOf("RANDOM") >= 0
    const isLate = modifiers.indexOf("LATE") >= 0
    const isRigid = modifiers.indexOf("RIGID") >= 0

    const cmds = extractSecond(commands)
    if (message) {
      cmds.push(message)
    }
    return {
      type: ast.RULE_TYPE.SIMPLE,
      directions,
      isRandom,
      isLate,
      isRigid,
      conditions: extractFirst(conditionBrackets),
      actions: extractFirst(actionBrackets),
      commands: cmds,
      _sourceOffset
    }
  }
alias_222 = ([{ neighbors, againHack, debugFlag }], _sourceOffset) => {
  return {
    type: ast.BRACKET_TYPE.SIMPLE,
    neighbors,
    againHack,
    debugFlag,
    _sourceOffset
  }
}
alias_223 = (
  [{ beforeNeighbors, afterNeighbors, debugFlag }],
  _sourceOffset
) => {
  return {
    type: ast.BRACKET_TYPE.ELLIPSIS,
    beforeNeighbors,
    afterNeighbors,
    debugFlag,
    _sourceOffset
  }
}
alias_224 = (
  [modifiers, _1, { neighbors, againHack, debugFlag }],
  _sourceOffset
) => {
  return {
    type: ast.BRACKET_TYPE.SIMPLE,
    neighbors,
    againHack,
    debugFlag,
    _sourceOffset
  }
}
alias_225 = (
  [modifiers, _1, { beforeNeighbors, afterNeighbors, debugFlag }],
  _sourceOffset
) => {
  return {
    type: ast.BRACKET_TYPE.ELLIPSIS,
    beforeNeighbors,
    afterNeighbors,
    debugFlag,
    _sourceOffset
  }
}
alias_226 = ([a]) => extractFirst(a)
alias_227 = () => [] /* No modifiers */
alias_228 = id
alias_229 = id
alias_230 =
  toDebug("NormalRuleBracket") ||
  function([_0, neighbors, againHack, _3, debugFlag], _sourceOffset) {
    return {
      type: "_INNER_BRACKET",
      neighbors: extractFirst(neighbors),
      againHack: againHack ? true : false,
      debugFlag: debugFlag ? debugFlag[1] : null,
      _sourceOffset
    }
  }
alias_231 =
  toDebug("EllipsisRuleBracket") ||
  function(
    [_0, beforeNeighbors, _2, _3, _4, _5, _6, afterNeighbors, _8, debugFlag],
    _sourceOffset
  ) {
    return {
      type: "_INNER_ELLIPSIS_BRACKET",
      beforeNeighbors: extractFirst(beforeNeighbors),
      afterNeighbors: extractFirst(afterNeighbors),
      debugFlag: debugFlag ? debugFlag[1] : null,
      _sourceOffset
    }
  }
alias_232 = id
alias_233 = id
alias_234 =
  toDebug("RuleBracketNoEllipsisNeighbor") ||
  function([_0, tileWithModifiers, debugFlag, _3], _sourceOffset) {
    return {
      type: "NEIGHBOR",
      tileWithModifiers: extractFirst(tileWithModifiers),
      debugFlag: debugFlag ? debugFlag[1] : null,
      _sourceOffset
    }
  }
alias_235 =
  toDebug("RuleBracketEmptyNeighbor") ||
  function([_0], _sourceOffset) {
    return { type: "NEIGHBOR", tileWithModifiers: [], _sourceOffset }
  }
alias_236 =
  toDebug("TileWithModifier") ||
  function([modifier, tile], _sourceOffset) {
    const mod = modifier ? modifier[0] : null
    let direction
    let isNegated = false
    let isRandom = false
    switch (mod) {
      case "NO":
        isNegated = true
        break
      case "RANDOM":
        isRandom = true
        break
      default:
        direction = mod
    }
    return {
      type: "TILE_WITH_MODIFIER",
      direction,
      isNegated,
      isRandom,
      tile,
      _sourceOffset
    }
  }
alias_237 = upperId
alias_238 = upperId
alias_239 = upperId
alias_240 = upperId
alias_241 = upperId
alias_242 = upperId
alias_243 = upperId
alias_244 = upperId
alias_245 = upperId
alias_246 = upperId
alias_247 = upperId
alias_248 = upperId
alias_249 = upperId
alias_250 = upperId
alias_251 = upperId
alias_252 = upperId
alias_253 = upperId
alias_254 = upperId
alias_255 = upperId
alias_256 = upperId
alias_257 = upperId
alias_258 = upperId
alias_259 = upperId
alias_260 = upperId
alias_261 = id
alias_262 = upperId
alias_263 = upperId
alias_264 = (_0, _sourceOffset) => {
  return { type: ast.COMMAND_TYPE.AGAIN, _sourceOffset }
}
alias_265 = (_0, _sourceOffset) => {
  return { type: ast.COMMAND_TYPE.CANCEL, _sourceOffset }
}
alias_266 = (_0, _sourceOffset) => {
  return { type: ast.COMMAND_TYPE.CHECKPOINT, _sourceOffset }
}
alias_267 = (_0, _sourceOffset) => {
  return { type: ast.COMMAND_TYPE.RESTART, _sourceOffset }
}
alias_268 = (_0, _sourceOffset) => {
  return { type: ast.COMMAND_TYPE.WIN, _sourceOffset }
}
alias_269 = ([sound], _sourceOffset) => {
  return { type: ast.COMMAND_TYPE.SFX, sound, _sourceOffset }
}
alias_270 = ([_1, message], _sourceOffset) => {
  return { type: ast.COMMAND_TYPE.MESSAGE, message, _sourceOffset }
}
alias_271 = ([_0, _1, _2, _3, rules, _4, _5, _6]) => {
  return { type: ast.RULE_TYPE.LOOP, rules: extractFirst(rules) }
}
alias_272 = ([firstRule, otherRules], _sourceOffset) => {
  return {
    type: ast.RULE_TYPE.GROUP,
    rules: [firstRule].concat(extractThird(otherRules)),
    _sourceOffset
  }
}
alias_273 =
  toDebug("WinConditionItem") ||
  function([_0, qualifier, _1, tile, _2], _sourceOffset) {
    return {
      type: ast.WIN_CONDITION_TYPE.SIMPLE,
      qualifier,
      tile,
      _sourceOffset
    }
  }
alias_274 =
  toDebug("WinConditionItem") ||
  function([_0, qualifier, _1, tile, _2, _3, _4, onTile, _5], _sourceOffset) {
    return {
      type: ast.WIN_CONDITION_TYPE.ON,
      qualifier,
      tile,
      onTile,
      _sourceOffset
    }
  }
alias_275 = id
alias_276 = id
alias_277 = id
alias_278 = id
alias_279 = id
alias_280 = id
alias_281 = id
alias_282 = ([_0, _1, message], _sourceOffset) => {
  return { type: "LEVEL_MESSAGE", message, _sourceOffset }
}
alias_283 =
  toDebug("messageLine") ||
  function([message, _2]) {
    return message.join("").trim()
  }
alias_284 = ([_0, cols], _sourceOffset, reject) => {
  const str = cols.join("")
  if (str.toUpperCase().startsWith("MESSAGE")) {
    return reject
  } else {
    return {
      type: "LEVEL_ROW",
      cells: cols.map(([char]) => char[0]),
      _sourceOffset
    }
  }
}
alias_285 = (_0, _sourceOffset) => {
  return { type: "LEVEL_SEPARATOR", _sourceOffset }
}
